
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      <link rel="icon" href="../../../img/tenticon.png">
      <meta name="generator" content="mkdocs-1.2.3, mkdocs-material-7.1.5">
    
    
      
        <title>Swap Nodes [Algo] - Campbell's Homepage</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.bde7dde4.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.ef6f36e2.min.css">
        
      
    
    
    
      
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700%7CRoboto+Mono&display=fallback">
        <style>:root{--md-text-font-family:"Roboto";--md-code-font-family:"Roboto Mono"}</style>
      
    
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
    
      
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="" data-md-color-primary="none" data-md-color-accent="none">
  
    
    <script>function __prefix(e){return new URL("../../..",location).pathname+"."+e}function __get(e,t=localStorage){return JSON.parse(t.getItem(__prefix(e)))}</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#swap-nodes-algo" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="Campbell&#39;s Homepage" class="md-header__button md-logo" aria-label="Campbell's Homepage" data-md-component="logo">
      
  <img src="../../../img/tenticon.png" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Campbell's Homepage
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Swap Nodes [Algo]
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
      </label>
      
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" data-md-state="active" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12z"/></svg>
      </label>
      <button type="reset" class="md-search__icon md-icon" aria-label="Clear" tabindex="-1">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z"/></svg>
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="Campbell&#39;s Homepage" class="md-nav__button md-logo" aria-label="Campbell's Homepage" data-md-component="logo">
      
  <img src="../../../img/tenticon.png" alt="logo">

    </a>
    Campbell's Homepage
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        Home
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../../hackerrank/" class="md-nav__link">
        HackerRank
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content" data-md-component="content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="swap-nodes-algo">Swap Nodes [Algo]</h1>
<p><a href="https://www.hackerrank.com/challenges/swap-nodes-algo/problem">Problem</a></p>
<p>Category: Search</p>
<p>Difficulty: Medium</p>
<hr />
<p>Given a binary tree and a list of swap queries, report the state of the tree
after fulfilling each query.</p>
<p>Input: a binary tree with <span class="arithmatex">\(n\)</span> nodes represented by an <span class="arithmatex">\(n \times 2\)</span> array <span class="arithmatex">\(T\)</span>,
and an array <span class="arithmatex">\(q[t]\)</span> of <span class="arithmatex">\(t\)</span> queries. Each node <span class="arithmatex">\(i\)</span> for <span class="arithmatex">\(1 \leq i \leq n\)</span> has left
child <span class="arithmatex">\(T_{i, \ell}\)</span> and right child <span class="arithmatex">\(T_{i, r}\)</span>, either of which can be <span class="arithmatex">\(-1\)</span> if
no such child exists. Also, node 1 is the root, and each node has a lower index
than its children.</p>
<div class="arithmatex">\[ 1 \leq n \leq 2^{10} \]</div>
<div class="arithmatex">\[ T_{i, \ell}, T_{i, r} \in \{-1, i + 1, i + 2, \ldots, n\} \; \; \forall \; i \]</div>
<div class="arithmatex">\[ 1 \leq t \leq 100 \]</div>
<div class="arithmatex">\[ 1 \leq q[i] \leq n \; \; \forall \; i \]</div>
<p>Output: a list of <span class="arithmatex">\(t\)</span> inorder traversals of the tree, one after each of the <span class="arithmatex">\(t\)</span>
swap queries is fulfilled. Each swap query <span class="arithmatex">\(k\)</span> should swap the left and right
subtrees of every node whose depth is a multiple of <span class="arithmatex">\(k\)</span> (the root has depth 1).
Each inorder traversal is a list of the nodes 1 through <span class="arithmatex">\(n\)</span>. If you are not
familiar with pre-order, post-order, or inorder traversals, they are useful
conventions for doing a
<a href="https://en.wikipedia.org/wiki/Tree_traversal#Depth-first_search">depth-first search on a binary tree</a>.
Inorder traversal means that for each node you discover, you traverse its entire
left subtree first, then add the node to the traversal, and then traverse the
entire right subtree.</p>
<p>The tree representation given to us in this problem (an <span class="arithmatex">\(n \times 2\)</span> array) is
nice because we can access any node by index without having to search for it
from the root. Still, it would be a pain if, say for a query <span class="arithmatex">\(k = 2\)</span>, we had to
do a breadth-first search to find and swap the children of every node with depth
2, 4, 6, and so on. It would be nice if we could look up the indices of every
node with depth <span class="arithmatex">\(k\)</span>, because if we know that, it is easy to index into the tree
and swap the children of each node. Note that swapping never changes a node's
parent, so it never changes the depth of any node.</p>
<p>I used a table that maps each possible depth 1 through <span class="arithmatex">\(n\)</span> to the set of nodes
at that depth. To populate the sets in this table, you search the tree and
calculate each node's depth. Since every node has a lower index than its
children, you can use an even simpler dynamic programming approach: set
<span class="arithmatex">\(d[1] \gets 1\)</span> for the root, and for each node <span class="arithmatex">\(i = 1 \ldots n\)</span>, set its
children's depths to <span class="arithmatex">\(d[i] + 1\)</span>.</p>
<p>Once you have populated your depth lookup data structure, for each query <span class="arithmatex">\(k\)</span> and
each integer <span class="arithmatex">\(m \geq 1\)</span> such that <span class="arithmatex">\(mk \leq n\)</span>, you need to look up the set of
nodes with depth <span class="arithmatex">\(mk\)</span> and swap the left and right indices of each. Then, build
the inorder traversal of the tree and append it to the output list. The inorder
traversal is easiest to implement recursively, as the inorder traversal of any
tree is <code>inorderTraversal(left) + root + inorderTraversal(right)</code>.</p>
<p>Note that the indices of the given tree are one-based. In Java and C++, I use a
copy of the tree that has an extra element at the front so that I can use the
one-based index values in the tree to index into the tree itself, but this is
definitely not required. Depending on how you handle this, you will probably
need to watch out for off-by-one indexing errors.</p>
<p>Java 8:
<div class="highlight"><pre><span></span><code><span class="kd">public</span> <span class="kd">static</span> <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="nf">swapNodes</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">indexes</span><span class="p">,</span>
                                            <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">queries</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">indexes</span><span class="p">.</span><span class="na">size</span><span class="p">();</span>
    <span class="kt">int</span><span class="o">[][]</span> <span class="n">tree</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">][</span><span class="mi">2</span><span class="o">]</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">pair</span> <span class="p">:</span> <span class="n">indexes</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tree</span><span class="o">[</span><span class="n">index</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">pair</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
        <span class="n">tree</span><span class="o">[</span><span class="n">index</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">pair</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">index</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">int</span><span class="o">[]</span> <span class="n">depths</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span><span class="p">;</span>
    <span class="n">List</span><span class="o">&lt;</span><span class="n">Set</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">depthLookup</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ArrayList</span><span class="o">&lt;&gt;</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">depthLookup</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="k">new</span> <span class="n">HashSet</span><span class="o">&lt;&gt;</span><span class="p">());</span>
    <span class="p">}</span>
    <span class="n">depths</span><span class="o">[</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">depthLookup</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="na">add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">tree</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">tree</span><span class="o">[</span><span class="n">i</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">nextDepth</span> <span class="o">=</span> <span class="n">depths</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">depths</span><span class="o">[</span><span class="n">left</span><span class="o">]</span> <span class="o">=</span> <span class="n">nextDepth</span><span class="p">;</span>
            <span class="n">depthLookup</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">nextDepth</span><span class="p">).</span><span class="na">add</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">right</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">depths</span><span class="o">[</span><span class="n">right</span><span class="o">]</span> <span class="o">=</span> <span class="n">nextDepth</span><span class="p">;</span>
            <span class="n">depthLookup</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">nextDepth</span><span class="p">).</span><span class="na">add</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">List</span><span class="o">&lt;</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">query</span> <span class="p">:</span> <span class="n">queries</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="n">query</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">node</span> <span class="p">:</span> <span class="n">depthLookup</span><span class="p">.</span><span class="na">get</span><span class="p">(</span><span class="n">k</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">swap</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="n">query</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">traversal</span> <span class="o">=</span> <span class="k">new</span> <span class="n">LinkedList</span><span class="o">&lt;&gt;</span><span class="p">();</span>
        <span class="n">inorderTraversal</span><span class="p">(</span><span class="n">traversal</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">result</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">traversal</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="kt">int</span><span class="o">[][]</span> <span class="n">tree</span><span class="p">,</span> <span class="kt">int</span> <span class="n">node</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">tree</span><span class="o">[</span><span class="n">node</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span><span class="p">;</span>
    <span class="n">tree</span><span class="o">[</span><span class="n">node</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span> <span class="o">=</span> <span class="n">tree</span><span class="o">[</span><span class="n">node</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span><span class="p">;</span>
    <span class="n">tree</span><span class="o">[</span><span class="n">node</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">inorderTraversal</span><span class="p">(</span><span class="n">List</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">&gt;</span> <span class="n">traversal</span><span class="p">,</span> <span class="kt">int</span><span class="o">[][]</span> <span class="n">tree</span><span class="p">,</span>
                                     <span class="kt">int</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">inorderTraversal</span><span class="p">(</span><span class="n">traversal</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">tree</span><span class="o">[</span><span class="n">root</span><span class="o">][</span><span class="mi">0</span><span class="o">]</span><span class="p">);</span>
        <span class="n">traversal</span><span class="p">.</span><span class="na">add</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="n">inorderTraversal</span><span class="p">(</span><span class="n">traversal</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">tree</span><span class="o">[</span><span class="n">root</span><span class="o">][</span><span class="mi">1</span><span class="o">]</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></p>
<p>C++:
<div class="highlight"><pre><span></span><code><span class="kt">void</span> <span class="nf">inorderTraversal</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;&amp;</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">swapNodes</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">indexes</span><span class="p">,</span> 
                              <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">queries</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">tree</span><span class="p">;</span>
    <span class="n">tree</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">index</span> <span class="o">=</span> <span class="n">indexes</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">index</span> <span class="o">!=</span> <span class="n">indexes</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">tree</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">index</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">index</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">indexes</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">depths</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">depthLookup</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">depths</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">depthLookup</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">right</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">nextDepth</span> <span class="o">=</span> <span class="n">depths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">!=</span> <span class="mi">-1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">depths</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">=</span> <span class="n">nextDepth</span><span class="p">;</span>
            <span class="n">depthLookup</span><span class="p">[</span><span class="n">nextDepth</span><span class="p">].</span><span class="n">insert</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">right</span> <span class="o">!=</span> <span class="mi">-1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">depths</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">nextDepth</span><span class="p">;</span>
            <span class="n">depthLookup</span><span class="p">[</span><span class="n">nextDepth</span><span class="p">].</span><span class="n">insert</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">result</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">query</span> <span class="o">=</span> <span class="n">queries</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">query</span> <span class="o">!=</span> <span class="n">queries</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">query</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="o">*</span><span class="n">query</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">set</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;*</span> <span class="n">depthSet</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">depthLookup</span><span class="p">[</span><span class="n">k</span><span class="p">];</span>
            <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">node</span> <span class="o">=</span> <span class="n">depthSet</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">();</span> <span class="n">node</span> <span class="o">!=</span> <span class="n">depthSet</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">();</span>
                                                <span class="n">node</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">swap</span><span class="p">(</span><span class="n">tree</span><span class="p">[</span><span class="o">*</span><span class="n">node</span><span class="p">].</span><span class="n">first</span><span class="p">,</span> <span class="n">tree</span><span class="p">[</span><span class="o">*</span><span class="n">node</span><span class="p">].</span><span class="n">second</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="o">*</span><span class="n">query</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">traversal</span><span class="p">;</span>
        <span class="n">inorderTraversal</span><span class="p">(</span><span class="n">traversal</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">traversal</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">inorderTraversal</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">traversal</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;&amp;</span> <span class="n">tree</span><span class="p">,</span>
                      <span class="kt">int</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">!=</span> <span class="mi">-1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">inorderTraversal</span><span class="p">(</span><span class="n">traversal</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">tree</span><span class="p">[</span><span class="n">root</span><span class="p">].</span><span class="n">first</span><span class="p">);</span>
        <span class="n">traversal</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
        <span class="n">inorderTraversal</span><span class="p">(</span><span class="n">traversal</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">tree</span><span class="p">[</span><span class="n">root</span><span class="p">].</span><span class="n">second</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></p>
<p>For Python, the simple recursive implementation of inorder traversal was
exceeding the recursion limit for some test cases, so I wrote it without
recursion. It's the same idea as the recursive implementation, but instead of
handling nodes in the right order with the call stack by making recursive calls
in the right order, we are using an explicit stack and pushing node indices onto
it. Starting with the root, we make an <code>inorder_push</code> to the stack, which
pushes the node and its children in reverse order (right child, parent, left
child) so that they will be popped in the correct order. We use a list of
boolean flags to keep track of which nodes we have done an <code>inorder_push</code>
on. Until the stack is empty and the traversal is complete, we pop each node
from the stack and do an <code>inorder_push</code> for that node if we haven't before
or append it to the traversal if we have. This method is a bit longer and harder
to write than the recursive method, but it scales better for large trees by
avoiding making tons of recursive calls.</p>
<p>Python 3:
<div class="highlight"><pre><span></span><code><span class="k">def</span> <span class="nf">swapNodes</span><span class="p">(</span><span class="n">indexes</span><span class="p">,</span> <span class="n">queries</span><span class="p">):</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">indexes</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
    <span class="n">depths</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">depth_lookup</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">()]</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">depths</span><span class="p">:</span>
        <span class="n">depth_lookup</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">set</span><span class="p">())</span>
    <span class="n">depths</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">depth_lookup</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">node</span>
        <span class="n">next_depth</span> <span class="o">=</span> <span class="n">depths</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">left</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">depths</span><span class="p">[</span><span class="n">left</span><span class="p">]</span> <span class="o">=</span> <span class="n">next_depth</span>
            <span class="n">depth_lookup</span><span class="p">[</span><span class="n">next_depth</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">right</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">depths</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">=</span> <span class="n">next_depth</span>
            <span class="n">depth_lookup</span><span class="p">[</span><span class="n">next_depth</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>

    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">query</span> <span class="ow">in</span> <span class="n">queries</span><span class="p">:</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">query</span>
        <span class="k">while</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">depth_lookup</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                <span class="n">tree</span><span class="p">[</span><span class="n">node</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="n">k</span> <span class="o">+=</span> <span class="n">query</span>
        <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inorder_traversal</span><span class="p">(</span><span class="n">tree</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">result</span>

<span class="k">def</span> <span class="nf">inorder_traversal</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">inorder_push</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
        <span class="n">left</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">tree</span><span class="p">[</span><span class="n">node</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">right</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">right</span><span class="p">)</span>
        <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">left</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">stack</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">left</span><span class="p">)</span>
        <span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="n">traversal</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">inorder_push</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">stack</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">visited</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
            <span class="n">traversal</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">inorder_push</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">traversal</span>
</code></pre></div></p>
<p><a href="../../../hackerrank/">Back</a></p>
                
              
              
                


              
            </article>
          </div>
        </div>
        
      </main>
      
        
<footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        Made with
        <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
          Material for MkDocs
        </a>
        
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    <script id="__config" type="application/json">{"base": "../../..", "features": [], "translations": {"clipboard.copy": "Copy to clipboard", "clipboard.copied": "Copied to clipboard", "search.config.lang": "en", "search.config.pipeline": "trimmer, stopWordFilter", "search.config.separator": "[\\s\\-]+", "search.placeholder": "Search", "search.result.placeholder": "Type to start searching", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.term.missing": "Missing"}, "search": "../../../assets/javascripts/workers/search.d351de03.min.js", "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.a1609d9a.min.js"></script>
      
        <script src="../../../javascripts/mathjax.js"></script>
      
        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
      
    
  </body>
</html>