{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Campbell's Home Welcome to my page!","title":"Home"},{"location":"#campbells-home","text":"Welcome to my page!","title":"Campbell's Home"},{"location":"hackerrank/","text":"HackerRank Content Interview Preparation Kit Name Category Difficulty Sales by Match Warm-up Challenges Easy Counting Valleys Warm-up Challenges Easy Jumping on the Clouds Warm-up Challenges Easy","title":"HackerRank"},{"location":"hackerrank/#hackerrank-content","text":"","title":"HackerRank Content"},{"location":"hackerrank/#interview-preparation-kit","text":"Name Category Difficulty Sales by Match Warm-up Challenges Easy Counting Valleys Warm-up Challenges Easy Jumping on the Clouds Warm-up Challenges Easy","title":"Interview Preparation Kit"},{"location":"interviewprep/countingvalleys/","text":"Counting Valleys https://www.hackerrank.com/challenges/counting-valleys/problem Category: Warm-up Challenges Difficulty: Easy Given a path of steps, which are either up or down, starting at sea level, determine the number of valleys crossed. A valley is a sequence of steps that starts at sea level, descends below sea level, and then returns to sea level. Input: a number of steps \\(s\\) and a path \\(p \\in \\{U, D\\}^s\\) , where \\(U\\) represents a step up and \\(D\\) represents a step down. The path begins and ends at sea level, so \\(p\\) has an equal number of \\(U\\) 's and \\(D\\) 's. \\(2 \\leq s \\leq 1,000,000\\) \\(|\\{i : p_i = U\\}| = |\\{i : p_i = D\\}| = \\frac{s}{2}\\) Output: the number of valleys (sequences that start at sea level, descend below sea level, and then return up to sea level). Read through the path and keep track of what elevation each step reaches. For example: \"UDDDUDUU\" \\(\\to\\) 0, 1, 0, -1, -2, -1, -2, -1, 0 We can see that a valley ends whenever we step up from elevation -1 to 0. The path is guaranteed to return to sea level (elevation 0) by the end, so every valley ends, and the number of times we step up from -1 to 0 is the number of valleys. Java 8: public static int countingValleys(int steps, String path) { int count = 0; int level = 0; for (int i = 0; i < steps; i++) { if (path.charAt(i) == 'U') { level++; if (level == 0) { count++; } } else { level--; } } return count; } C++: int countingValleys(int steps, string path) { int count = 0; int level = 0; for (int i = 0; i < steps; i++) { if (path[i] == 'U') { level++; count += level == 0; } else { level--; } } return count; } Python 3: def countingValleys(steps, path): level = 0 count = 0 for step in path: if step == \"U\": level += 1 if level == 0: count += 1 else: level -= 1 return count Back","title":"Counting Valleys"},{"location":"interviewprep/countingvalleys/#counting-valleys","text":"https://www.hackerrank.com/challenges/counting-valleys/problem Category: Warm-up Challenges Difficulty: Easy Given a path of steps, which are either up or down, starting at sea level, determine the number of valleys crossed. A valley is a sequence of steps that starts at sea level, descends below sea level, and then returns to sea level. Input: a number of steps \\(s\\) and a path \\(p \\in \\{U, D\\}^s\\) , where \\(U\\) represents a step up and \\(D\\) represents a step down. The path begins and ends at sea level, so \\(p\\) has an equal number of \\(U\\) 's and \\(D\\) 's. \\(2 \\leq s \\leq 1,000,000\\) \\(|\\{i : p_i = U\\}| = |\\{i : p_i = D\\}| = \\frac{s}{2}\\) Output: the number of valleys (sequences that start at sea level, descend below sea level, and then return up to sea level). Read through the path and keep track of what elevation each step reaches. For example: \"UDDDUDUU\" \\(\\to\\) 0, 1, 0, -1, -2, -1, -2, -1, 0 We can see that a valley ends whenever we step up from elevation -1 to 0. The path is guaranteed to return to sea level (elevation 0) by the end, so every valley ends, and the number of times we step up from -1 to 0 is the number of valleys. Java 8: public static int countingValleys(int steps, String path) { int count = 0; int level = 0; for (int i = 0; i < steps; i++) { if (path.charAt(i) == 'U') { level++; if (level == 0) { count++; } } else { level--; } } return count; } C++: int countingValleys(int steps, string path) { int count = 0; int level = 0; for (int i = 0; i < steps; i++) { if (path[i] == 'U') { level++; count += level == 0; } else { level--; } } return count; } Python 3: def countingValleys(steps, path): level = 0 count = 0 for step in path: if step == \"U\": level += 1 if level == 0: count += 1 else: level -= 1 return count Back","title":"Counting Valleys"},{"location":"interviewprep/jumpingontheclouds/","text":"Jumping on the Clouds https://www.hackerrank.com/challenges/jumping-on-the-clouds/problem Category: Warm-Up Challenges Difficulty: Easy Given a pattern of safe and dangerous clouds leading to a goal, determine the minimum number of jumps required to reach the end safely. Input: a number of clouds \\(n\\) and a pattern \\(c_1, \\ldots c_n\\) where \\(c_1 = 0\\) , \\(c_n = 0\\) , and \\(c_i \\in \\{0, 1\\}\\) for \\(1 < i < n\\) . \\(c_i = 0\\) means cloud \\(i\\) is safe, and \\(c_i = 1\\) means cloud \\(i\\) must be avoided. \\(2 \\leq n \\leq 100\\) Output: the minimum number of jumps needed to win the game. The player starts on cloud 1 and must reach cloud \\(n\\) . They can jump forward 1 or 2 clouds at a time. It is guaranteed that the player can win, so there will never be two dangerous clouds in a row. We can be greedy by taking advantage of the fact that there is always a path to the end. If the player is at cloud \\(i\\) (starting at cloud 0), look at cloud \\(i + 2\\) : If cloud \\(i + 2\\) is safe, you should always jump 2 spaces forward to that cloud. If cloud \\(i + 2\\) is dangerous, you can (and should) jump 1 space forward to cloud \\(i + 1\\) instead. The first cloud is safe, and there are no two consecutive dangerous clouds. Therefore, for any safe cloud at \\(i\\) , if you can't jump to \\(i + 2\\) , you can jump to \\(i + 1\\) and then to \\(i + 3\\) and so on. For the Java solution, c is given as a List instead of an array, so my solution converts it into an array first. You only need to read through the list once sequentially to solve the problem, so it is possible to use an iterator over the list instead of converting it into an array and indexing into it. Java 8: public static int jumpingOnClouds(List<Integer> c) { // Write your code here final int N = c.size(); Integer[] clouds = c.toArray(new Integer[N]); int jumps = 0; int position = 0; while (position + 1 < N) { if (position + 2 < N && clouds[position + 2] == 0) { position += 2; } else { position++; } jumps++; } return jumps; } C++: int jumpingOnClouds(vector<int> c) { int n = c.size(); int jumps = 0; int position = 0; while (position + 1 < n) { position += 1 + (position + 2 < n && !c[position + 2]); jumps++; } return jumps; } Python 3: def jumpingOnClouds(c): # Write your code here n = len(c) position = 0 jumps = 0 while position + 1 < n: if position + 2 < n and c[position + 2] == 0: position += 2 else: position += 1 jumps += 1 return jumps","title":"Jumping on the Clouds"},{"location":"interviewprep/jumpingontheclouds/#jumping-on-the-clouds","text":"https://www.hackerrank.com/challenges/jumping-on-the-clouds/problem Category: Warm-Up Challenges Difficulty: Easy Given a pattern of safe and dangerous clouds leading to a goal, determine the minimum number of jumps required to reach the end safely. Input: a number of clouds \\(n\\) and a pattern \\(c_1, \\ldots c_n\\) where \\(c_1 = 0\\) , \\(c_n = 0\\) , and \\(c_i \\in \\{0, 1\\}\\) for \\(1 < i < n\\) . \\(c_i = 0\\) means cloud \\(i\\) is safe, and \\(c_i = 1\\) means cloud \\(i\\) must be avoided. \\(2 \\leq n \\leq 100\\) Output: the minimum number of jumps needed to win the game. The player starts on cloud 1 and must reach cloud \\(n\\) . They can jump forward 1 or 2 clouds at a time. It is guaranteed that the player can win, so there will never be two dangerous clouds in a row. We can be greedy by taking advantage of the fact that there is always a path to the end. If the player is at cloud \\(i\\) (starting at cloud 0), look at cloud \\(i + 2\\) : If cloud \\(i + 2\\) is safe, you should always jump 2 spaces forward to that cloud. If cloud \\(i + 2\\) is dangerous, you can (and should) jump 1 space forward to cloud \\(i + 1\\) instead. The first cloud is safe, and there are no two consecutive dangerous clouds. Therefore, for any safe cloud at \\(i\\) , if you can't jump to \\(i + 2\\) , you can jump to \\(i + 1\\) and then to \\(i + 3\\) and so on. For the Java solution, c is given as a List instead of an array, so my solution converts it into an array first. You only need to read through the list once sequentially to solve the problem, so it is possible to use an iterator over the list instead of converting it into an array and indexing into it. Java 8: public static int jumpingOnClouds(List<Integer> c) { // Write your code here final int N = c.size(); Integer[] clouds = c.toArray(new Integer[N]); int jumps = 0; int position = 0; while (position + 1 < N) { if (position + 2 < N && clouds[position + 2] == 0) { position += 2; } else { position++; } jumps++; } return jumps; } C++: int jumpingOnClouds(vector<int> c) { int n = c.size(); int jumps = 0; int position = 0; while (position + 1 < n) { position += 1 + (position + 2 < n && !c[position + 2]); jumps++; } return jumps; } Python 3: def jumpingOnClouds(c): # Write your code here n = len(c) position = 0 jumps = 0 while position + 1 < n: if position + 2 < n and c[position + 2] == 0: position += 2 else: position += 1 jumps += 1 return jumps","title":"Jumping on the Clouds"},{"location":"interviewprep/salesbymatch/","text":"Sales by Match https://www.hackerrank.com/challenges/sock-merchant/problem Category: Warm-up Challenges Difficulty: Easy Given a list of socks, determine how many pairs of matching-color socks can be made. Input: a list of socks \\(ar[n]\\) , where \\(ar[i]\\) is an integer representing the color of sock \\(i\\) . \\(1 \\leq n \\leq 100, 1 \\leq ar[i] \\leq 100 \\; \\forall \\; i\\) Output: the maximum number of pairs that can be achieved by pairing socks that have the same color We don't need the number of total possible ways to pair the socks; we just need to maximum number of pairs achievable by any pairing where no sock is matched to a sock of a different color. For example, [1, 1, 1, 1, 1] has at most 2 matches: one way to achieve this is by matching sock 0 to sock 1 and sock 2 to sock 3, leaving sock 4 unpaired. Make a set to store available sock colors and loop through the list of socks. Check if each sock's color is in the set so far: If sock \\(i\\) 's color is not in the set, then you have no sock to pair with \\(i\\) . \\(i\\) is a loose sock available for a future pairing. If sock \\(i\\) 's color is in the set, then there is a previous sock available to pair with \\(i\\) . Remove \\(i\\) 's color from the set and record that a pair has been made. Another solution could be to count how many socks there are of each color. If a color appears on \\(k\\) socks, then \\(\\lfloor \\frac{k}{2} \\rfloor\\) is the number of pairs that can be made with that color. Java 8: public static int sockMerchant(int n, List<Integer> ar) { int count = 0; Set<Integer> colors = new HashSet<>(); for (int sock : ar) { if (colors.remove(sock)) { count++; } else { colors.add(sock); } } return count; } C++: int sockMerchant(int n, vector<int> ar) { int count = 0; set<int> colors; for (int i = 0; i < n; i++) { if(colors.erase(ar[i])) { count++; } else { colors.insert(ar[i]); } } return count; } Python 3: def sockMerchant(n, ar): colors = set() count = 0 for i in ar: if i in colors: count += 1 colors.remove(i) else: colors.add(i) return count Python 3 Alternate Solution: def sockMerchant(n, ar): sock_freq = {sock: ar.count(sock) for sock in ar} return sum(v // 2 for _, v in sock_freq.items()) Back","title":"Sales by Match"},{"location":"interviewprep/salesbymatch/#sales-by-match","text":"https://www.hackerrank.com/challenges/sock-merchant/problem Category: Warm-up Challenges Difficulty: Easy Given a list of socks, determine how many pairs of matching-color socks can be made. Input: a list of socks \\(ar[n]\\) , where \\(ar[i]\\) is an integer representing the color of sock \\(i\\) . \\(1 \\leq n \\leq 100, 1 \\leq ar[i] \\leq 100 \\; \\forall \\; i\\) Output: the maximum number of pairs that can be achieved by pairing socks that have the same color We don't need the number of total possible ways to pair the socks; we just need to maximum number of pairs achievable by any pairing where no sock is matched to a sock of a different color. For example, [1, 1, 1, 1, 1] has at most 2 matches: one way to achieve this is by matching sock 0 to sock 1 and sock 2 to sock 3, leaving sock 4 unpaired. Make a set to store available sock colors and loop through the list of socks. Check if each sock's color is in the set so far: If sock \\(i\\) 's color is not in the set, then you have no sock to pair with \\(i\\) . \\(i\\) is a loose sock available for a future pairing. If sock \\(i\\) 's color is in the set, then there is a previous sock available to pair with \\(i\\) . Remove \\(i\\) 's color from the set and record that a pair has been made. Another solution could be to count how many socks there are of each color. If a color appears on \\(k\\) socks, then \\(\\lfloor \\frac{k}{2} \\rfloor\\) is the number of pairs that can be made with that color. Java 8: public static int sockMerchant(int n, List<Integer> ar) { int count = 0; Set<Integer> colors = new HashSet<>(); for (int sock : ar) { if (colors.remove(sock)) { count++; } else { colors.add(sock); } } return count; } C++: int sockMerchant(int n, vector<int> ar) { int count = 0; set<int> colors; for (int i = 0; i < n; i++) { if(colors.erase(ar[i])) { count++; } else { colors.insert(ar[i]); } } return count; } Python 3: def sockMerchant(n, ar): colors = set() count = 0 for i in ar: if i in colors: count += 1 colors.remove(i) else: colors.add(i) return count Python 3 Alternate Solution: def sockMerchant(n, ar): sock_freq = {sock: ar.count(sock) for sock in ar} return sum(v // 2 for _, v in sock_freq.items()) Back","title":"Sales by Match"}]}