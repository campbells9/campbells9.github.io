{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Campbell's Home Welcome to my page! Source","title":"Home"},{"location":"#campbells-home","text":"Welcome to my page! Source","title":"Campbell's Home"},{"location":"hackerrank/","text":"HackerRank Content Interview Preparation Kit Name Category Difficulty Sales by Match Warm-up Challenges Easy Counting Valleys Warm-up Challenges Easy Jumping on the Clouds Warm-up Challenges Easy Repeated String Warm-up Challenges Easy 2D Array - DS Arrays Easy Arrays: Left Rotation Arrays Easy Hash Tables: Ransom Note Dictionaries and Hashmaps Easy Two Strings Dictionaries and Hashmaps Easy Sorting: Bubble Sort Sorting Easy Mark and Toys Sorting Easy Strings: Making Anagrams String Manipulation Easy Alternating Characters String Manipulation Easy Minimum Absolute Difference in an Array Greedy Algorithms Easy Luck Balance Greedy Algorithms Easy Tree: Height of a Binary Tree Trees Easy Binary Search Tree: Lowest Common Ancestor Trees Easy","title":"HackerRank"},{"location":"hackerrank/#hackerrank-content","text":"","title":"HackerRank Content"},{"location":"hackerrank/#interview-preparation-kit","text":"Name Category Difficulty Sales by Match Warm-up Challenges Easy Counting Valleys Warm-up Challenges Easy Jumping on the Clouds Warm-up Challenges Easy Repeated String Warm-up Challenges Easy 2D Array - DS Arrays Easy Arrays: Left Rotation Arrays Easy Hash Tables: Ransom Note Dictionaries and Hashmaps Easy Two Strings Dictionaries and Hashmaps Easy Sorting: Bubble Sort Sorting Easy Mark and Toys Sorting Easy Strings: Making Anagrams String Manipulation Easy Alternating Characters String Manipulation Easy Minimum Absolute Difference in an Array Greedy Algorithms Easy Luck Balance Greedy Algorithms Easy Tree: Height of a Binary Tree Trees Easy Binary Search Tree: Lowest Common Ancestor Trees Easy","title":"Interview Preparation Kit"},{"location":"interviewprep/arrays/ds/","text":"2D Array - DS Problem Category: Arrays Difficulty: Easy Given a 6x6 array, find the maximum \"hourglass sum.\" Input: a 2D array, \\(arr[i][j]\\) for \\(1 \\leq i, j \\leq 6\\) . \\(-9 \\leq arr[i][j] \\leq 9 \\; \\forall \\; i, j\\) Output: the maximum hourglass sum of the array. For any 3x3 block of \\(arr\\) , the hourglass sum is the sum of the top 3, bottom 3, and center entries: [[a, b, c], [d, e, f], [g, h, i]] \\(\\; \\to \\; a + b + c + e + g + h + i\\) Every hourglass sum is at least -63 and at most 63. There are only 16 possible 3x3 blocks in \\(arr\\) , so there are only 16 hourglass sums to check. You can loop through the center entries of each block ( \\(arr[1][1] \\ldots arr[4][4]\\) ) and calculate an hourglass sum for each. Java 8: public static int hourglassSum(List<List<Integer>> arr) { final int SIZE = 6; Integer[][] mat = new Integer[SIZE][SIZE]; int i = 0; for (List<Integer> row : arr) { mat[i] = row.toArray(mat[i]); i++; } final int END = SIZE - 1; final int MIN_VAL = -9; int max = MIN_VAL * 7; for (i = 1; i < END; i++) { for (int j = 1; j < END; j++) { int sum = mat[i - 1][j - 1] + mat[i - 1][j] + mat[i - 1][j + 1]; sum += mat[i][j]; sum += mat[i + 1][j - 1] + mat[i + 1][j] + mat[i + 1][j + 1]; max = Math.max(max, sum); } } return max; } C++: int hourglassSum(vector<vector<int>> arr) { const int minVal = -9; int maxSum = minVal * 7; const int end = arr.size() - 1; for (int i = 1; i < end; i++) { for (int j = 1; j < end; j++) { int sum = arr[i - 1][j - 1] + arr[i - 1][j] + arr[i - 1][j + 1]; sum += arr[i][j]; sum += arr[i + 1][j - 1] + arr[i + 1][j] + arr[i + 1][j + 1]; maxSum = max(maxSum, sum); } } return maxSum; } Python 3: def hourglassSum(arr): min_val = -9 max_sum = min_val * 7 end = len(arr) - 1 for i in range(1, end): for j in range(1, end): hourglass_sum = sum(arr[i - 1][(j - 1):(j + 2)]) hourglass_sum += arr[i][j] hourglass_sum += sum(arr[i + 1][(j - 1):(j + 2)]) max_sum = max(max_sum, hourglass_sum) return max_sum Back","title":"2D Array - DS"},{"location":"interviewprep/arrays/ds/#2d-array-ds","text":"Problem Category: Arrays Difficulty: Easy Given a 6x6 array, find the maximum \"hourglass sum.\" Input: a 2D array, \\(arr[i][j]\\) for \\(1 \\leq i, j \\leq 6\\) . \\(-9 \\leq arr[i][j] \\leq 9 \\; \\forall \\; i, j\\) Output: the maximum hourglass sum of the array. For any 3x3 block of \\(arr\\) , the hourglass sum is the sum of the top 3, bottom 3, and center entries: [[a, b, c], [d, e, f], [g, h, i]] \\(\\; \\to \\; a + b + c + e + g + h + i\\) Every hourglass sum is at least -63 and at most 63. There are only 16 possible 3x3 blocks in \\(arr\\) , so there are only 16 hourglass sums to check. You can loop through the center entries of each block ( \\(arr[1][1] \\ldots arr[4][4]\\) ) and calculate an hourglass sum for each. Java 8: public static int hourglassSum(List<List<Integer>> arr) { final int SIZE = 6; Integer[][] mat = new Integer[SIZE][SIZE]; int i = 0; for (List<Integer> row : arr) { mat[i] = row.toArray(mat[i]); i++; } final int END = SIZE - 1; final int MIN_VAL = -9; int max = MIN_VAL * 7; for (i = 1; i < END; i++) { for (int j = 1; j < END; j++) { int sum = mat[i - 1][j - 1] + mat[i - 1][j] + mat[i - 1][j + 1]; sum += mat[i][j]; sum += mat[i + 1][j - 1] + mat[i + 1][j] + mat[i + 1][j + 1]; max = Math.max(max, sum); } } return max; } C++: int hourglassSum(vector<vector<int>> arr) { const int minVal = -9; int maxSum = minVal * 7; const int end = arr.size() - 1; for (int i = 1; i < end; i++) { for (int j = 1; j < end; j++) { int sum = arr[i - 1][j - 1] + arr[i - 1][j] + arr[i - 1][j + 1]; sum += arr[i][j]; sum += arr[i + 1][j - 1] + arr[i + 1][j] + arr[i + 1][j + 1]; maxSum = max(maxSum, sum); } } return maxSum; } Python 3: def hourglassSum(arr): min_val = -9 max_sum = min_val * 7 end = len(arr) - 1 for i in range(1, end): for j in range(1, end): hourglass_sum = sum(arr[i - 1][(j - 1):(j + 2)]) hourglass_sum += arr[i][j] hourglass_sum += sum(arr[i + 1][(j - 1):(j + 2)]) max_sum = max(max_sum, hourglass_sum) return max_sum Back","title":"2D Array - DS"},{"location":"interviewprep/arrays/leftrotation/","text":"Arrays: Left Rotation Problem Category: Arrays Difficulty: Easy Given an array, rotate it to the left by \\(d\\) elements. Input: an array \\(a[n]\\) and a number of rotations to make, \\(d\\) . \\(1 \\leq d \\leq n \\leq 10^5\\) \\(1 \\leq a[i] \\leq 10^6 \\; \\forall \\; i\\) Output: the array shifted \\(d\\) elements to the left. For example, for the following array, shifting to the left by 1 element gives: [1, 2, 3, 4] \\(\\to\\) [2, 3, 4, 1] By 3 elements: [1, 2, 3, 4] \\(\\to\\) [2, 3, 4, 1] \\(\\to\\) [3, 4, 1, 2] \\(\\to\\) [4, 1, 2, 3] Shifting by 4 elements brings the array back to its original order. The array could be modified in place, but for this problem it is okay to use an extra array to store the values in their new positions without overriding the values in the original array. For the value at position \\(i\\) , you can calculate its new position \\(i'\\) with \\(d\\) : \\(i' \\gets (i - d)\\) mod \\(n\\) Note that using the modulus operator with negative numbers may not always work the way you expect. You might need to add \\(n\\) : \\(i' \\gets (i - d + n)\\) mod \\(n\\) The new array should have the elements from \\(d\\) to the end, followed by the elements from 0 to \\(d - 1\\) . The description suggests that you should modify the array passed to the function, but it also works to create and return a new array with the correct values. Java 8: public static List<Integer> rotLeft(List<Integer> a, int d) { Iterator<Integer> iter = a.iterator(); List<Integer> start = new LinkedList<>(); for (int i = 0; i < d; i++) { start.add(iter.next()); } List<Integer> newList = new LinkedList<>(); while (iter.hasNext()) { newList.add(iter.next()); } a.clear(); a.addAll(newList); a.addAll(start); return a; } C++: vector<int> rotLeft(vector<int> a, int d) { const int n = a.size(); vector<int> newVector(n, 0); for (int i = 0; i < n; i++) { newVector[(i - d + n) % n] = a[i]; } a = newVector; return a; } Python 3: def rotLeft(a, d): new_list = a[d:] + a[:d] a.clear() a.extend(new_list) return a Back","title":"Arrays: Left Rotation"},{"location":"interviewprep/arrays/leftrotation/#arrays-left-rotation","text":"Problem Category: Arrays Difficulty: Easy Given an array, rotate it to the left by \\(d\\) elements. Input: an array \\(a[n]\\) and a number of rotations to make, \\(d\\) . \\(1 \\leq d \\leq n \\leq 10^5\\) \\(1 \\leq a[i] \\leq 10^6 \\; \\forall \\; i\\) Output: the array shifted \\(d\\) elements to the left. For example, for the following array, shifting to the left by 1 element gives: [1, 2, 3, 4] \\(\\to\\) [2, 3, 4, 1] By 3 elements: [1, 2, 3, 4] \\(\\to\\) [2, 3, 4, 1] \\(\\to\\) [3, 4, 1, 2] \\(\\to\\) [4, 1, 2, 3] Shifting by 4 elements brings the array back to its original order. The array could be modified in place, but for this problem it is okay to use an extra array to store the values in their new positions without overriding the values in the original array. For the value at position \\(i\\) , you can calculate its new position \\(i'\\) with \\(d\\) : \\(i' \\gets (i - d)\\) mod \\(n\\) Note that using the modulus operator with negative numbers may not always work the way you expect. You might need to add \\(n\\) : \\(i' \\gets (i - d + n)\\) mod \\(n\\) The new array should have the elements from \\(d\\) to the end, followed by the elements from 0 to \\(d - 1\\) . The description suggests that you should modify the array passed to the function, but it also works to create and return a new array with the correct values. Java 8: public static List<Integer> rotLeft(List<Integer> a, int d) { Iterator<Integer> iter = a.iterator(); List<Integer> start = new LinkedList<>(); for (int i = 0; i < d; i++) { start.add(iter.next()); } List<Integer> newList = new LinkedList<>(); while (iter.hasNext()) { newList.add(iter.next()); } a.clear(); a.addAll(newList); a.addAll(start); return a; } C++: vector<int> rotLeft(vector<int> a, int d) { const int n = a.size(); vector<int> newVector(n, 0); for (int i = 0; i < n; i++) { newVector[(i - d + n) % n] = a[i]; } a = newVector; return a; } Python 3: def rotLeft(a, d): new_list = a[d:] + a[:d] a.clear() a.extend(new_list) return a Back","title":"Arrays: Left Rotation"},{"location":"interviewprep/dicts/ransomnote/","text":"Hash Tables: Ransom Note Problem Category: Dictionaries and Hashmaps Difficulty: Easy Given a list of words in a magazine, determine whether it is possible to cut out enough words to write a given ransom note. Input: arrays \\(magazine[m]\\) and \\(note[n]\\) of strings, each of which is a word made of uppercase and lowercase English letters. \\(1 \\leq m, n \\leq 3 \\times 10^5\\) Output: print Yes if it is possible to arrange the words of \\(magazine\\) to write the \\(note\\) , otherwise print No . For example, if the \\(note\\) is [\"two\", \"plus\", \"two\", \"is\", \"four\"] , then if the \\(magazine\\) contains two \"two\" s, a \"plus\" , an \"is\" , and a \"four\" , then the output is Yes . If it is missing any of those, or it only has one \"two\" , or there is a \"Plus\" instead of a \"plus\" , then the answer is No . Note that the words are case-sensitive. It is not enough to know that every word in \\(note\\) is also in \\(magazine\\) ; there must be as many instances of any word in \\(magazine\\) as there are in \\(note\\) . You can use maps to count the number of occurences in each word of \\(magazine\\) and \\(note\\) . The answer is No if there is a word in your \\(note\\) map that either doesn't occur in \\(magazine\\) or occurs fewer times in \\(magazine\\) than in \\(note\\) . Java 8: public static void checkMagazine ( List < String > magazine , List < String > note ) { Map < String , Integer > magazineFreq = new HashMap <> (); Map < String , Integer > noteFreq = new HashMap <> (); for ( String word : magazine ) { magazineFreq . put ( word , magazineFreq . getOrDefault ( word , 0 ) + 1 ); } for ( String word : note ) { noteFreq . put ( word , noteFreq . getOrDefault ( word , 0 ) + 1 ); } for ( String word : noteFreq . keySet ()) { if ( noteFreq . get ( word ) > magazineFreq . getOrDefault ( word , 0 )) { System . out . println ( \"No\" ); return ; } } System . out . println ( \"Yes\" ); } C++: void checkMagazine ( vector < string > magazine , vector < string > note ) { map < string , int > magazineFreq ; map < string , int > noteFreq ; for ( auto word = magazine . begin (); word != magazine . end (); word ++ ) { magazineFreq [ * word ] ++ ; } for ( auto word = note . begin (); word != note . end (); word ++ ) { noteFreq [ * word ] ++ ; } for ( auto entry = noteFreq . begin (); entry != noteFreq . end (); entry ++ ) { if ( entry -> second > magazineFreq [ entry -> first ]) { cout << \"No\" << endl ; return ; } } cout << \"Yes\" << endl ; } Python 3: def checkMagazine ( magazine , note ): magazine_freq = { word : 0 for word in magazine } note_freq = { word : 0 for word in note } for word in magazine : magazine_freq [ word ] += 1 for word in note : note_freq [ word ] += 1 for word , freq in note_freq . items (): if word not in magazine_freq or magazine_freq [ word ] < freq : print ( \"No\" ) return print ( \"Yes\" ) Back","title":"Hash Tables: Ransom Note"},{"location":"interviewprep/dicts/ransomnote/#hash-tables-ransom-note","text":"Problem Category: Dictionaries and Hashmaps Difficulty: Easy Given a list of words in a magazine, determine whether it is possible to cut out enough words to write a given ransom note. Input: arrays \\(magazine[m]\\) and \\(note[n]\\) of strings, each of which is a word made of uppercase and lowercase English letters. \\(1 \\leq m, n \\leq 3 \\times 10^5\\) Output: print Yes if it is possible to arrange the words of \\(magazine\\) to write the \\(note\\) , otherwise print No . For example, if the \\(note\\) is [\"two\", \"plus\", \"two\", \"is\", \"four\"] , then if the \\(magazine\\) contains two \"two\" s, a \"plus\" , an \"is\" , and a \"four\" , then the output is Yes . If it is missing any of those, or it only has one \"two\" , or there is a \"Plus\" instead of a \"plus\" , then the answer is No . Note that the words are case-sensitive. It is not enough to know that every word in \\(note\\) is also in \\(magazine\\) ; there must be as many instances of any word in \\(magazine\\) as there are in \\(note\\) . You can use maps to count the number of occurences in each word of \\(magazine\\) and \\(note\\) . The answer is No if there is a word in your \\(note\\) map that either doesn't occur in \\(magazine\\) or occurs fewer times in \\(magazine\\) than in \\(note\\) . Java 8: public static void checkMagazine ( List < String > magazine , List < String > note ) { Map < String , Integer > magazineFreq = new HashMap <> (); Map < String , Integer > noteFreq = new HashMap <> (); for ( String word : magazine ) { magazineFreq . put ( word , magazineFreq . getOrDefault ( word , 0 ) + 1 ); } for ( String word : note ) { noteFreq . put ( word , noteFreq . getOrDefault ( word , 0 ) + 1 ); } for ( String word : noteFreq . keySet ()) { if ( noteFreq . get ( word ) > magazineFreq . getOrDefault ( word , 0 )) { System . out . println ( \"No\" ); return ; } } System . out . println ( \"Yes\" ); } C++: void checkMagazine ( vector < string > magazine , vector < string > note ) { map < string , int > magazineFreq ; map < string , int > noteFreq ; for ( auto word = magazine . begin (); word != magazine . end (); word ++ ) { magazineFreq [ * word ] ++ ; } for ( auto word = note . begin (); word != note . end (); word ++ ) { noteFreq [ * word ] ++ ; } for ( auto entry = noteFreq . begin (); entry != noteFreq . end (); entry ++ ) { if ( entry -> second > magazineFreq [ entry -> first ]) { cout << \"No\" << endl ; return ; } } cout << \"Yes\" << endl ; } Python 3: def checkMagazine ( magazine , note ): magazine_freq = { word : 0 for word in magazine } note_freq = { word : 0 for word in note } for word in magazine : magazine_freq [ word ] += 1 for word in note : note_freq [ word ] += 1 for word , freq in note_freq . items (): if word not in magazine_freq or magazine_freq [ word ] < freq : print ( \"No\" ) return print ( \"Yes\" ) Back","title":"Hash Tables: Ransom Note"},{"location":"interviewprep/dicts/twostrings/","text":"Two Strings Problem Category: Dictionaries and Hashmaps Difficulty: Easy Given two strings, determine if they share any common substring. Input: two strings \\(s_1\\) and \\(s_2\\) of lowercase English letters. \\(1 \\leq |s_1|, |s_2| \\leq 10^5\\) Output: the string \"Yes\" if there exists a non-empty string that is a substring of both \\(s_1\\) and \\(s_2\\) , otherwise the string \"No\". If \\(s_1\\) and \\(s_2\\) have a common non-empty substring, then they share at least one letter in common. If \\(s_1\\) and \\(s_2\\) share a letter \\(c\\) in common, then they share the common substring \" \\(c\\) \" and the answer is Yes. Therefore, the answer is Yes if and only if \\(s_1\\) and \\(s_2\\) have at least one letter in common. We need to find one letter that is in both \\(s_1\\) and \\(s_2\\) to determine the answer is Yes, and if the strings have no letters in common, the answer is No. This is the condition we are trying to check: \\(\\{c : c \\in s_1\\} \\cap \\{c : c \\in s_2\\} \\neq \\emptyset\\) There are a few ways to do this. You can make separate sets with the characters of \\(s_1\\) and \\(s_2\\) and calculate the intersection. You can make a set for \\(s_1\\) and then check whether it contains any character of \\(s_2\\) . You can also make a combined set for \\(s_1\\) and \\(s_2\\) and check for independence: \\(|\\{c : c \\in s_1\\} \\cup \\{c : c \\in s_2\\}| = |\\{c : c \\in s_1\\}| + |\\{c : c \\in s_2\\}|\\) If the sets are independent, then the answer is No. Java 8: public static String twoStrings ( String s1 , String s2 ) { Set < Character > s1set = new HashSet <> (); for ( int i = 0 ; i < s1 . length (); i ++ ) { s1set . add ( s1 . charAt ( i )); } for ( int i = 0 ; i < s2 . length (); i ++ ) { if ( s1set . contains ( s2 . charAt ( i ))) { return \"YES\" ; } } return \"NO\" ; } C++: string twoStrings ( string s1 , string s2 ) { set < char > s1set ; for ( auto ch = s1 . begin (); ch != s1 . end (); ch ++ ) { s1set . insert ( * ch ); } for ( auto ch = s2 . begin (); ch != s2 . end (); ch ++ ) { if ( s1set . find ( * ch ) != s1set . end ()) { return \"YES\" ; } } return \"NO\" ; } Python 3: def twoStrings ( s1 , s2 ): return \"YES\" if set ( s1 ) & set ( s2 ) else \"NO\" Back","title":"Two Strings"},{"location":"interviewprep/dicts/twostrings/#two-strings","text":"Problem Category: Dictionaries and Hashmaps Difficulty: Easy Given two strings, determine if they share any common substring. Input: two strings \\(s_1\\) and \\(s_2\\) of lowercase English letters. \\(1 \\leq |s_1|, |s_2| \\leq 10^5\\) Output: the string \"Yes\" if there exists a non-empty string that is a substring of both \\(s_1\\) and \\(s_2\\) , otherwise the string \"No\". If \\(s_1\\) and \\(s_2\\) have a common non-empty substring, then they share at least one letter in common. If \\(s_1\\) and \\(s_2\\) share a letter \\(c\\) in common, then they share the common substring \" \\(c\\) \" and the answer is Yes. Therefore, the answer is Yes if and only if \\(s_1\\) and \\(s_2\\) have at least one letter in common. We need to find one letter that is in both \\(s_1\\) and \\(s_2\\) to determine the answer is Yes, and if the strings have no letters in common, the answer is No. This is the condition we are trying to check: \\(\\{c : c \\in s_1\\} \\cap \\{c : c \\in s_2\\} \\neq \\emptyset\\) There are a few ways to do this. You can make separate sets with the characters of \\(s_1\\) and \\(s_2\\) and calculate the intersection. You can make a set for \\(s_1\\) and then check whether it contains any character of \\(s_2\\) . You can also make a combined set for \\(s_1\\) and \\(s_2\\) and check for independence: \\(|\\{c : c \\in s_1\\} \\cup \\{c : c \\in s_2\\}| = |\\{c : c \\in s_1\\}| + |\\{c : c \\in s_2\\}|\\) If the sets are independent, then the answer is No. Java 8: public static String twoStrings ( String s1 , String s2 ) { Set < Character > s1set = new HashSet <> (); for ( int i = 0 ; i < s1 . length (); i ++ ) { s1set . add ( s1 . charAt ( i )); } for ( int i = 0 ; i < s2 . length (); i ++ ) { if ( s1set . contains ( s2 . charAt ( i ))) { return \"YES\" ; } } return \"NO\" ; } C++: string twoStrings ( string s1 , string s2 ) { set < char > s1set ; for ( auto ch = s1 . begin (); ch != s1 . end (); ch ++ ) { s1set . insert ( * ch ); } for ( auto ch = s2 . begin (); ch != s2 . end (); ch ++ ) { if ( s1set . find ( * ch ) != s1set . end ()) { return \"YES\" ; } } return \"NO\" ; } Python 3: def twoStrings ( s1 , s2 ): return \"YES\" if set ( s1 ) & set ( s2 ) else \"NO\" Back","title":"Two Strings"},{"location":"interviewprep/greedyalgorithms/luckbalance/","text":"Luck Balance Problem Category: Greedy Algorithms Difficulty: Easy Given a list of contests with \"luck\" values, which are either important or unimportant, and a maximum number of important contests that can be lost, determine the maximum possible amount of \"stored luck\" after all contests. Input: two arrays \\(L[n]\\) and \\(T[n]\\) , and \\(k\\) , the maximum number of important contests that can be lost. \\(L[i]\\) is the luck value of contest \\(i\\) , and \\(T[i] = 1\\) if contest \\(i\\) is important, else \\(T[i] = 0\\) . \\(1 \\leq k \\leq n \\leq 100\\) \\(1 \\leq L[i] \\leq 10^4 \\; \\forall \\; i\\) Output: the maximum amount of stored luck attainable after all contests. Luck starts at 0, and winning contest \\(i\\) decreases luck by \\(L[i]\\) , while losing contest \\(i\\) increases luck by \\(L[i]\\) . The idea behind \"saving luck\" is that the more you lose, the greater your chance of winning becomes in the future, and the more you win, the greater your chance of losing becomes in the future. A contest \\(i\\) with a high luck value \\(L[i]\\) costs a lot of luck to win. The first observation to make is that the constraint is that we can lose no more than \\(k\\) important contests, but there is no limit to the number of unimportant contests we can lose. Every contest has a positive luck value, so we should lose every unimportant contest. For important contests, we should lose as many as we are allowed, and we should choose the contests with the largest luck values to lose. Make a list of the luck values for important contests and sort it. Add up to \\(k\\) of the largest values to your overall luck value and subtract any remaining values. Note that if you can lose at most \\(k\\) contests, then you must win at least \\(m.\\text{length} - k\\) important contests, where \\(m\\) is the array of important contests. If \\(k \\geq m.\\text{length}\\) , then you may lose every important contest. You can either start from the highest values and choose \\(k\\) contests to lose, or you can start from the lowest values and choose \\(m.\\text{length} - k\\) contests to win. Java 8: public static int luckBalance ( int k , List < List < Integer >> contests ) { int luck = 0 ; List < Integer > important = new ArrayList <> (); for ( List < Integer > contest : contests ) { final int L = contest . get ( 0 ); final int T = contest . get ( 1 ); if ( T == 1 ) { important . add ( L ); } else { luck += L ; } } Collections . sort ( important ); int requiredWins = important . size () - k ; for ( int l : important ) { if ( requiredWins > 0 ) { luck -= l ; requiredWins -- ; } else { luck += l ; } } return luck ; } C++: int luckBalance ( int k , vector < vector < int >> contests ) { vector < int > important ; int luck = 0 ; for ( auto contest = contests . begin (); contest != contests . end (); contest ++ ) { const int L = contest -> front (); const int T = contest -> back (); if ( T ) { important . push_back ( L ); } else { luck += L ; } } sort ( important . begin (), important . end ()); for ( auto l = important . rbegin (); l != important . rend (); l ++ ) { if ( k ) { luck += * l ; k -- ; } else { luck -= * l ; } } return luck ; } Python 3: def luckBalance ( k , contests ): important = [ contest [ 0 ] for contest in contests if contest [ - 1 ]] important . sort ( reverse = True ) luck = sum ( contest [ 0 ] for contest in contests if not contest [ - 1 ]) for l in important : if k : luck += l k -= 1 else : luck -= l return luck Back","title":"Luck Balance"},{"location":"interviewprep/greedyalgorithms/luckbalance/#luck-balance","text":"Problem Category: Greedy Algorithms Difficulty: Easy Given a list of contests with \"luck\" values, which are either important or unimportant, and a maximum number of important contests that can be lost, determine the maximum possible amount of \"stored luck\" after all contests. Input: two arrays \\(L[n]\\) and \\(T[n]\\) , and \\(k\\) , the maximum number of important contests that can be lost. \\(L[i]\\) is the luck value of contest \\(i\\) , and \\(T[i] = 1\\) if contest \\(i\\) is important, else \\(T[i] = 0\\) . \\(1 \\leq k \\leq n \\leq 100\\) \\(1 \\leq L[i] \\leq 10^4 \\; \\forall \\; i\\) Output: the maximum amount of stored luck attainable after all contests. Luck starts at 0, and winning contest \\(i\\) decreases luck by \\(L[i]\\) , while losing contest \\(i\\) increases luck by \\(L[i]\\) . The idea behind \"saving luck\" is that the more you lose, the greater your chance of winning becomes in the future, and the more you win, the greater your chance of losing becomes in the future. A contest \\(i\\) with a high luck value \\(L[i]\\) costs a lot of luck to win. The first observation to make is that the constraint is that we can lose no more than \\(k\\) important contests, but there is no limit to the number of unimportant contests we can lose. Every contest has a positive luck value, so we should lose every unimportant contest. For important contests, we should lose as many as we are allowed, and we should choose the contests with the largest luck values to lose. Make a list of the luck values for important contests and sort it. Add up to \\(k\\) of the largest values to your overall luck value and subtract any remaining values. Note that if you can lose at most \\(k\\) contests, then you must win at least \\(m.\\text{length} - k\\) important contests, where \\(m\\) is the array of important contests. If \\(k \\geq m.\\text{length}\\) , then you may lose every important contest. You can either start from the highest values and choose \\(k\\) contests to lose, or you can start from the lowest values and choose \\(m.\\text{length} - k\\) contests to win. Java 8: public static int luckBalance ( int k , List < List < Integer >> contests ) { int luck = 0 ; List < Integer > important = new ArrayList <> (); for ( List < Integer > contest : contests ) { final int L = contest . get ( 0 ); final int T = contest . get ( 1 ); if ( T == 1 ) { important . add ( L ); } else { luck += L ; } } Collections . sort ( important ); int requiredWins = important . size () - k ; for ( int l : important ) { if ( requiredWins > 0 ) { luck -= l ; requiredWins -- ; } else { luck += l ; } } return luck ; } C++: int luckBalance ( int k , vector < vector < int >> contests ) { vector < int > important ; int luck = 0 ; for ( auto contest = contests . begin (); contest != contests . end (); contest ++ ) { const int L = contest -> front (); const int T = contest -> back (); if ( T ) { important . push_back ( L ); } else { luck += L ; } } sort ( important . begin (), important . end ()); for ( auto l = important . rbegin (); l != important . rend (); l ++ ) { if ( k ) { luck += * l ; k -- ; } else { luck -= * l ; } } return luck ; } Python 3: def luckBalance ( k , contests ): important = [ contest [ 0 ] for contest in contests if contest [ - 1 ]] important . sort ( reverse = True ) luck = sum ( contest [ 0 ] for contest in contests if not contest [ - 1 ]) for l in important : if k : luck += l k -= 1 else : luck -= l return luck Back","title":"Luck Balance"},{"location":"interviewprep/greedyalgorithms/minabsdiff/","text":"Minimum Absolute Difference in an Array Problem Category: Greedy Algorithms Difficulty: Easy Given an array, find the minimum difference between any two numbers. Input: an array \\(a[n]\\) of integers. \\(2 \\leq n \\leq 10^5\\) \\(-10^9 \\leq a[i] \\leq 10^9 \\; \\forall \\; i\\) Output: the minimum absolute difference between any two values in the array: \\(\\text{min}_{i \\neq j} |a[i] - a[j]|\\) There are \\({n \\choose 2}\\) different absolute differences in \\(a\\) , but many of them cannot be the minimum absolute difference. For example, if \\(a[i] < a[j] < a[k]\\) , then the difference between \\(a[i]\\) and \\(a[j]\\) will be smaller than the difference between \\(a[i]\\) and \\(a[k]\\) . If we sort the array, then the two closest values will be next to each other. Therefore, all we need to do is sort the array and check the difference between each consecutive pair of values. Note that if the array is sorted, we can compute the absolute difference as \\(a[i] - a[i - 1]\\) , because \\(a[i] \\geq a[i - 1]\\) . Java 8: public static int minimumAbsoluteDifference ( List < Integer > arr ) { final int N = arr . size (); Integer [] a = arr . toArray ( new Integer [ N ] ); Arrays . sort ( a ); int minDiff = Integer . MAX_VALUE ; for ( int i = 1 ; i < N ; i ++ ) { minDiff = Math . min ( minDiff , a [ i ] - a [ i - 1 ] ); } return minDiff ; } C++: int minimumAbsoluteDifference ( vector < int > arr ) { vector < int > a = arr ; sort ( a . begin (), a . end ()); int minDiff = ( 1 << 31 ) - 1 ; for ( int i = 1 ; i < a . size (); i ++ ) { minDiff = min ( minDiff , a [ i ] - a [ i - 1 ]); } return minDiff ; } Python 3: def minimumAbsoluteDifference ( arr ): a = sorted ( arr ) return min ( a [ i ] - a [ i - 1 ] for i in range ( 1 , len ( a ))) Back","title":"Minimum Absolute Difference in an Array"},{"location":"interviewprep/greedyalgorithms/minabsdiff/#minimum-absolute-difference-in-an-array","text":"Problem Category: Greedy Algorithms Difficulty: Easy Given an array, find the minimum difference between any two numbers. Input: an array \\(a[n]\\) of integers. \\(2 \\leq n \\leq 10^5\\) \\(-10^9 \\leq a[i] \\leq 10^9 \\; \\forall \\; i\\) Output: the minimum absolute difference between any two values in the array: \\(\\text{min}_{i \\neq j} |a[i] - a[j]|\\) There are \\({n \\choose 2}\\) different absolute differences in \\(a\\) , but many of them cannot be the minimum absolute difference. For example, if \\(a[i] < a[j] < a[k]\\) , then the difference between \\(a[i]\\) and \\(a[j]\\) will be smaller than the difference between \\(a[i]\\) and \\(a[k]\\) . If we sort the array, then the two closest values will be next to each other. Therefore, all we need to do is sort the array and check the difference between each consecutive pair of values. Note that if the array is sorted, we can compute the absolute difference as \\(a[i] - a[i - 1]\\) , because \\(a[i] \\geq a[i - 1]\\) . Java 8: public static int minimumAbsoluteDifference ( List < Integer > arr ) { final int N = arr . size (); Integer [] a = arr . toArray ( new Integer [ N ] ); Arrays . sort ( a ); int minDiff = Integer . MAX_VALUE ; for ( int i = 1 ; i < N ; i ++ ) { minDiff = Math . min ( minDiff , a [ i ] - a [ i - 1 ] ); } return minDiff ; } C++: int minimumAbsoluteDifference ( vector < int > arr ) { vector < int > a = arr ; sort ( a . begin (), a . end ()); int minDiff = ( 1 << 31 ) - 1 ; for ( int i = 1 ; i < a . size (); i ++ ) { minDiff = min ( minDiff , a [ i ] - a [ i - 1 ]); } return minDiff ; } Python 3: def minimumAbsoluteDifference ( arr ): a = sorted ( arr ) return min ( a [ i ] - a [ i - 1 ] for i in range ( 1 , len ( a ))) Back","title":"Minimum Absolute Difference in an Array"},{"location":"interviewprep/sorting/bubblesort/","text":"Sorting: Bubble Sort Problem Category: Sorting Difficulty: Easy Given an array, return how many swaps are needed to sort the array with Bubble Sort. Input: an array \\(a[n]\\) of integers. \\(2 \\leq n \\leq 600\\) \\(1 \\leq a[i] \\leq 2 \\times 10^6 \\; \\forall \\; i\\) Output: a message containing the number of swaps needed to sort \\(a\\) , as well as elements \\(a[0]\\) and \\(a[n - 1]\\) after \\(a\\) is sorted. The problem gives you an example implementation of bubble sort, and it suffices to use bubble sort on \\(a\\) and count the number of times you swapped two elements. Java 8: public static void countSwaps ( List < Integer > a ) { final int N = a . size (); Integer [] arr = a . toArray ( new Integer [ N ] ); int swaps = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N - 1 ; j ++ ) { if ( arr [ j ] > arr [ j + 1 ] ) { swaps ++ ; int temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; } } } a . clear (); for ( int val : arr ) { a . add ( val ); } System . out . println ( \"Array is sorted in \" + swaps + \" swaps.\" ); System . out . println ( \"First Element: \" + arr [ 0 ] ); System . out . println ( \"Last Element: \" + arr [ N - 1 ] ); } C++: void countSwaps ( vector < int > a ) { const int n = a . size (); int swaps = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n - 1 ; j ++ ) { if ( a [ j ] > a [ j + 1 ]) { swaps ++ ; int temp = a [ j ]; a [ j ] = a [ j + 1 ]; a [ j + 1 ] = temp ; } } } cout << \"Array is sorted in \" << swaps << \" swaps.\" << endl ; cout << \"First Element: \" << a [ 0 ] << endl ; cout << \"Last Element: \" << a [ n - 1 ] << endl ; } Python 3: def countSwaps ( a ): swaps = 0 for _ in list ( a ): for i in range ( len ( a ) - 1 ): if a [ i ] > a [ i + 1 ]: swaps += 1 a [ i ], a [ i + 1 ] = a [ i + 1 ], a [ i ] print ( \"Array is sorted in\" , swaps , \"swaps.\" ) print ( \"First Element:\" , a [ 0 ]) print ( \"Last Element:\" , a [ - 1 ]) Back","title":"Sorting: Bubble Sort"},{"location":"interviewprep/sorting/bubblesort/#sorting-bubble-sort","text":"Problem Category: Sorting Difficulty: Easy Given an array, return how many swaps are needed to sort the array with Bubble Sort. Input: an array \\(a[n]\\) of integers. \\(2 \\leq n \\leq 600\\) \\(1 \\leq a[i] \\leq 2 \\times 10^6 \\; \\forall \\; i\\) Output: a message containing the number of swaps needed to sort \\(a\\) , as well as elements \\(a[0]\\) and \\(a[n - 1]\\) after \\(a\\) is sorted. The problem gives you an example implementation of bubble sort, and it suffices to use bubble sort on \\(a\\) and count the number of times you swapped two elements. Java 8: public static void countSwaps ( List < Integer > a ) { final int N = a . size (); Integer [] arr = a . toArray ( new Integer [ N ] ); int swaps = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N - 1 ; j ++ ) { if ( arr [ j ] > arr [ j + 1 ] ) { swaps ++ ; int temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; } } } a . clear (); for ( int val : arr ) { a . add ( val ); } System . out . println ( \"Array is sorted in \" + swaps + \" swaps.\" ); System . out . println ( \"First Element: \" + arr [ 0 ] ); System . out . println ( \"Last Element: \" + arr [ N - 1 ] ); } C++: void countSwaps ( vector < int > a ) { const int n = a . size (); int swaps = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n - 1 ; j ++ ) { if ( a [ j ] > a [ j + 1 ]) { swaps ++ ; int temp = a [ j ]; a [ j ] = a [ j + 1 ]; a [ j + 1 ] = temp ; } } } cout << \"Array is sorted in \" << swaps << \" swaps.\" << endl ; cout << \"First Element: \" << a [ 0 ] << endl ; cout << \"Last Element: \" << a [ n - 1 ] << endl ; } Python 3: def countSwaps ( a ): swaps = 0 for _ in list ( a ): for i in range ( len ( a ) - 1 ): if a [ i ] > a [ i + 1 ]: swaps += 1 a [ i ], a [ i + 1 ] = a [ i + 1 ], a [ i ] print ( \"Array is sorted in\" , swaps , \"swaps.\" ) print ( \"First Element:\" , a [ 0 ]) print ( \"Last Element:\" , a [ - 1 ]) Back","title":"Sorting: Bubble Sort"},{"location":"interviewprep/sorting/countinversions/","text":"Sorting: Bubble Sort Problem Category: Sorting Difficulty: Easy Given an array, return how many swaps are needed to sort the array with Bubble Sort. Input: an array \\(a[n]\\) of integers. \\(2 \\leq n \\leq 600\\) \\(1 \\leq a[i] \\leq 2 \\times 10^6 \\; \\forall \\; i\\) Output: a message containing the number of swaps needed to sort \\(a\\) , as well as elements \\(a[0]\\) and \\(a[n - 1]\\) after \\(a\\) is sorted. The problem gives you an example implementation of bubble sort, so it would be easy enough to use bubble sort on \\(a\\) and count the number of times you swapped two elements. The number of times bubble sort swaps two elements is the same as the number of inversions in the array: an inversion occurs whenever any two elements in the array are out of order and the larger one comes first. You can use a merge sort instead of a bubble sort and count the inversions to get the correct number of swaps. Consider merging two sorted arrays \\(l\\) and \\(r\\) : Start with the first elements of \\(l\\) and \\(r\\) : \\(i \\gets 0, j \\gets 0\\) . If \\(l[i] \\leq r[j]\\) , then add \\(l[i]\\) to the merged array and increment \\(i\\) . If \\(l[i] > r[j]\\) , then add \\(r[j]\\) to the merged array and increment \\(j\\) . If \\(i\\) reaches the end of \\(l\\) , add the remaining elements of \\(r\\) to the merged array. If \\(j\\) reaches the end of \\(r\\) , add the remaining elements of \\(l\\) to the merged array. Note that every value in \\(l\\) occurs before every value in \\(r\\) in the original array. When \\(r[j]\\) is placed before \\(l[i]\\) in the merged array, there is an inversion. But if \\(r[j]\\) is in front of \\(l[i]\\) , it will also go in front of the remaining elements in \\(l\\) after \\(i\\) . So when \\(r[j]\\) is added to the merged array, that represents \\(l.\\text{length} - i\\) inversions. A good way to count the total swaps needed to sort the array is to write a recursive merge sort function that returns the number of swaps made. This way, you can split the array into left and right halves, sum up the swaps incurred by each recursive call, and then add the the number of swaps counted when merging the two sorted arrays. Java 8: static long countInversions(int[] arr) { return mergeSort(Arrays.copyOf(arr, arr.length), 0, arr.length); } private static long mergeSort(int[] arr, int start, int end) { if (start >= end - 1) { return 0; } int mid = (start + end) / 2; long swaps = mergeSort(arr, start, mid); swaps += mergeSort(arr, mid, end); int[] temp = new int[end - start]; int i = start; int j = mid; int pos = 0; while (i < mid && j < end) { if (arr[i] <= arr[j]) { temp[pos] = arr[i]; i++; } else { swaps += mid - i; temp[pos] = arr[j]; j++; } pos++; } while (i < mid) { temp[pos] = arr[i]; i++; pos++; } while (j < end) { temp[pos] = arr[j]; j++; pos++; } for (int k = 0; k < temp.length; k++) { arr[start + k] = temp[k]; } return swaps; } C++: int mergeSort(vector<int>&, int, int); void countSwaps(vector<int> a) { const int n = a.size(); int swaps = mergeSort(a, 0, n); cout << \"Array is sorted in \" << swaps << \" swaps.\" << endl; cout << \"First Element: \" << a[0] << endl; cout << \"Last Element: \" << a[n - 1] << endl; } int mergeSort(vector<int>& a, int start, int end) { if (start >= end - 1) { return 0; } const int mid = (start + end) / 2; int swaps = mergeSort(a, start, mid); swaps += mergeSort(a, mid, end); vector<int> temp; int i = start; int j = mid; while (i < mid && j < end) { if (a[i] <= a[j]) { temp.push_back(a[i]); i++; } else { swaps += mid - i; temp.push_back(a[j]); j++; } } while (i < mid) { temp.push_back(a[i]); i++; } while (j < end) { temp.push_back(a[j]); j++; } for (int k = 0; k < temp.size(); k++) { a[start + k] = temp[k]; } return swaps; } Python 3: def countSwaps(a): swaps = mergeSort(a) print(\"Array is sorted in\", swaps, \"swaps.\") print(\"First Element:\", a[0]) print(\"Last Element:\", a[-1]) def mergeSort(a): if len(a) <= 1: return 0 mid = len(a) // 2 left = a[:mid] right = a[mid:] swaps = mergeSort(left) + mergeSort(right) i = 0 j = 0 a.clear() while i < len(left) and j < len(right): if left[i] <= right[j]: a.append(left[i]) i += 1 else: swaps += len(left) - i a.append(right[j]) j += 1 a.extend(left[i:]) a.extend(right[j:]) return swaps Back","title":"Sorting: Bubble Sort"},{"location":"interviewprep/sorting/countinversions/#sorting-bubble-sort","text":"Problem Category: Sorting Difficulty: Easy Given an array, return how many swaps are needed to sort the array with Bubble Sort. Input: an array \\(a[n]\\) of integers. \\(2 \\leq n \\leq 600\\) \\(1 \\leq a[i] \\leq 2 \\times 10^6 \\; \\forall \\; i\\) Output: a message containing the number of swaps needed to sort \\(a\\) , as well as elements \\(a[0]\\) and \\(a[n - 1]\\) after \\(a\\) is sorted. The problem gives you an example implementation of bubble sort, so it would be easy enough to use bubble sort on \\(a\\) and count the number of times you swapped two elements. The number of times bubble sort swaps two elements is the same as the number of inversions in the array: an inversion occurs whenever any two elements in the array are out of order and the larger one comes first. You can use a merge sort instead of a bubble sort and count the inversions to get the correct number of swaps. Consider merging two sorted arrays \\(l\\) and \\(r\\) : Start with the first elements of \\(l\\) and \\(r\\) : \\(i \\gets 0, j \\gets 0\\) . If \\(l[i] \\leq r[j]\\) , then add \\(l[i]\\) to the merged array and increment \\(i\\) . If \\(l[i] > r[j]\\) , then add \\(r[j]\\) to the merged array and increment \\(j\\) . If \\(i\\) reaches the end of \\(l\\) , add the remaining elements of \\(r\\) to the merged array. If \\(j\\) reaches the end of \\(r\\) , add the remaining elements of \\(l\\) to the merged array. Note that every value in \\(l\\) occurs before every value in \\(r\\) in the original array. When \\(r[j]\\) is placed before \\(l[i]\\) in the merged array, there is an inversion. But if \\(r[j]\\) is in front of \\(l[i]\\) , it will also go in front of the remaining elements in \\(l\\) after \\(i\\) . So when \\(r[j]\\) is added to the merged array, that represents \\(l.\\text{length} - i\\) inversions. A good way to count the total swaps needed to sort the array is to write a recursive merge sort function that returns the number of swaps made. This way, you can split the array into left and right halves, sum up the swaps incurred by each recursive call, and then add the the number of swaps counted when merging the two sorted arrays. Java 8: static long countInversions(int[] arr) { return mergeSort(Arrays.copyOf(arr, arr.length), 0, arr.length); } private static long mergeSort(int[] arr, int start, int end) { if (start >= end - 1) { return 0; } int mid = (start + end) / 2; long swaps = mergeSort(arr, start, mid); swaps += mergeSort(arr, mid, end); int[] temp = new int[end - start]; int i = start; int j = mid; int pos = 0; while (i < mid && j < end) { if (arr[i] <= arr[j]) { temp[pos] = arr[i]; i++; } else { swaps += mid - i; temp[pos] = arr[j]; j++; } pos++; } while (i < mid) { temp[pos] = arr[i]; i++; pos++; } while (j < end) { temp[pos] = arr[j]; j++; pos++; } for (int k = 0; k < temp.length; k++) { arr[start + k] = temp[k]; } return swaps; } C++: int mergeSort(vector<int>&, int, int); void countSwaps(vector<int> a) { const int n = a.size(); int swaps = mergeSort(a, 0, n); cout << \"Array is sorted in \" << swaps << \" swaps.\" << endl; cout << \"First Element: \" << a[0] << endl; cout << \"Last Element: \" << a[n - 1] << endl; } int mergeSort(vector<int>& a, int start, int end) { if (start >= end - 1) { return 0; } const int mid = (start + end) / 2; int swaps = mergeSort(a, start, mid); swaps += mergeSort(a, mid, end); vector<int> temp; int i = start; int j = mid; while (i < mid && j < end) { if (a[i] <= a[j]) { temp.push_back(a[i]); i++; } else { swaps += mid - i; temp.push_back(a[j]); j++; } } while (i < mid) { temp.push_back(a[i]); i++; } while (j < end) { temp.push_back(a[j]); j++; } for (int k = 0; k < temp.size(); k++) { a[start + k] = temp[k]; } return swaps; } Python 3: def countSwaps(a): swaps = mergeSort(a) print(\"Array is sorted in\", swaps, \"swaps.\") print(\"First Element:\", a[0]) print(\"Last Element:\", a[-1]) def mergeSort(a): if len(a) <= 1: return 0 mid = len(a) // 2 left = a[:mid] right = a[mid:] swaps = mergeSort(left) + mergeSort(right) i = 0 j = 0 a.clear() while i < len(left) and j < len(right): if left[i] <= right[j]: a.append(left[i]) i += 1 else: swaps += len(left) - i a.append(right[j]) j += 1 a.extend(left[i:]) a.extend(right[j:]) return swaps Back","title":"Sorting: Bubble Sort"},{"location":"interviewprep/sorting/markandtoys/","text":"Mark and Toys Problem Category: Sorting Difficulty: Easy Given prices of toys and a budget, determine the greatest number of toys that can be bought. Input: an array \\(p[n]\\) of prices of toys, and a budget \\(k\\) . \\(1 \\leq n \\leq 10^5\\) \\(1 \\leq k \\leq 10^9\\) \\(1 \\leq p[i] \\leq 10^9 \\; \\forall \\; i\\) Output: the greatest number of toys that can be bought with \\(k\\) units of currency. For prices \\(p_1, \\ldots, p_n\\) , we are trying to pick toys \\(I \\subseteq \\{1, \\ldots, n\\}\\) with maximum \\(|I|\\) such that: \\(\\sum_{i \\in I} p_i \\leq k\\) To maximize the number of toys purchased, you can use a greedy algorithm to always buy the cheapest toys possible. Sort \\(p\\) from lowest to highest and read through the prices, subtracting each one from the budget. Once the budget or list of prices runs out, the number of toys bought is the correct answer. The greedy approach works because maximumToys \\((p, \\cdot)\\) is monotonic: for any \\(j \\leq k\\) , you can buy at least as many toys from \\(p\\) with \\(k\\) units of currency as you can with \\(j\\) units of currency. Choosing the cheapest toy leaves the greatest amount of currency remaining, which means you can buy the greatest number of toys possible out of the remaining options. Java 8: public static int maximumToys ( List < Integer > prices , int k ) { final int N = prices . size (); Integer [] p = prices . toArray ( new Integer [ N ] ); Arrays . sort ( p ); int toys = 0 ; while ( toys < N && p [ toys ] <= k ) { k -= p [ toys ] ; toys ++ ; } return toys ; } C++: int maximumToys ( vector < int > prices , int k ) { vector < int > p = prices ; sort ( p . begin (), p . end ()); const int n = p . size (); int toys = 0 ; while ( toys < n && p [ toys ] <= k ) { k -= p [ toys ]; toys ++ ; } return toys ; } Python 3: def maximumToys ( prices , k ): toys = 0 for toy in sorted ( prices ): if k >= toy : k -= toy toys += 1 else : return toys return toys Back","title":"Mark and Toys"},{"location":"interviewprep/sorting/markandtoys/#mark-and-toys","text":"Problem Category: Sorting Difficulty: Easy Given prices of toys and a budget, determine the greatest number of toys that can be bought. Input: an array \\(p[n]\\) of prices of toys, and a budget \\(k\\) . \\(1 \\leq n \\leq 10^5\\) \\(1 \\leq k \\leq 10^9\\) \\(1 \\leq p[i] \\leq 10^9 \\; \\forall \\; i\\) Output: the greatest number of toys that can be bought with \\(k\\) units of currency. For prices \\(p_1, \\ldots, p_n\\) , we are trying to pick toys \\(I \\subseteq \\{1, \\ldots, n\\}\\) with maximum \\(|I|\\) such that: \\(\\sum_{i \\in I} p_i \\leq k\\) To maximize the number of toys purchased, you can use a greedy algorithm to always buy the cheapest toys possible. Sort \\(p\\) from lowest to highest and read through the prices, subtracting each one from the budget. Once the budget or list of prices runs out, the number of toys bought is the correct answer. The greedy approach works because maximumToys \\((p, \\cdot)\\) is monotonic: for any \\(j \\leq k\\) , you can buy at least as many toys from \\(p\\) with \\(k\\) units of currency as you can with \\(j\\) units of currency. Choosing the cheapest toy leaves the greatest amount of currency remaining, which means you can buy the greatest number of toys possible out of the remaining options. Java 8: public static int maximumToys ( List < Integer > prices , int k ) { final int N = prices . size (); Integer [] p = prices . toArray ( new Integer [ N ] ); Arrays . sort ( p ); int toys = 0 ; while ( toys < N && p [ toys ] <= k ) { k -= p [ toys ] ; toys ++ ; } return toys ; } C++: int maximumToys ( vector < int > prices , int k ) { vector < int > p = prices ; sort ( p . begin (), p . end ()); const int n = p . size (); int toys = 0 ; while ( toys < n && p [ toys ] <= k ) { k -= p [ toys ]; toys ++ ; } return toys ; } Python 3: def maximumToys ( prices , k ): toys = 0 for toy in sorted ( prices ): if k >= toy : k -= toy toys += 1 else : return toys return toys Back","title":"Mark and Toys"},{"location":"interviewprep/stringmanipulation/alternatingcharacters/","text":"Alternating Characters Problem Category: String Manipulation Difficulty: Easy Given two strings of A's and B's, determine the minimum number of character deletions required to make the string have alternating characters. Input: a string \\(s\\) of which every character is 'A' or 'B' . \\(1 \\leq |s| \\leq 10^5\\) Output: the minimum number of character deletions required to make \\(s\\) have no two consecutive A's or B's in a row (such that it follows the pattern \"ABAB...\" or \"BABA...\" ). If we delete every character that matches the character before it, that is sufficient to leave \\(s\\) with alternating characters. There is no need to actually modify the string or build a new string, because we only need to count how many times a character \\(s[i]\\) matches the character before it, \\(s[i - 1]\\) . Java 8: public static int alternatingCharacters ( String s ) { int deletions = 0 ; for ( int i = 1 ; i < s . length (); i ++ ) { if ( s . charAt ( i ) == s . charAt ( i - 1 )) { deletions ++ ; } } return deletions ; } C++: int alternatingCharacters ( string s ) { int deletions = 0 ; for ( int i = 1 ; i < s . size (); i ++ ) { deletions += s [ i ] == s [ i - 1 ]; } return deletions ; } Python 3: def alternatingCharacters ( s ): return sum ( s [ i ] == s [ i - 1 ] for i in range ( 1 , len ( s ))) Back","title":"Alternating Characters"},{"location":"interviewprep/stringmanipulation/alternatingcharacters/#alternating-characters","text":"Problem Category: String Manipulation Difficulty: Easy Given two strings of A's and B's, determine the minimum number of character deletions required to make the string have alternating characters. Input: a string \\(s\\) of which every character is 'A' or 'B' . \\(1 \\leq |s| \\leq 10^5\\) Output: the minimum number of character deletions required to make \\(s\\) have no two consecutive A's or B's in a row (such that it follows the pattern \"ABAB...\" or \"BABA...\" ). If we delete every character that matches the character before it, that is sufficient to leave \\(s\\) with alternating characters. There is no need to actually modify the string or build a new string, because we only need to count how many times a character \\(s[i]\\) matches the character before it, \\(s[i - 1]\\) . Java 8: public static int alternatingCharacters ( String s ) { int deletions = 0 ; for ( int i = 1 ; i < s . length (); i ++ ) { if ( s . charAt ( i ) == s . charAt ( i - 1 )) { deletions ++ ; } } return deletions ; } C++: int alternatingCharacters ( string s ) { int deletions = 0 ; for ( int i = 1 ; i < s . size (); i ++ ) { deletions += s [ i ] == s [ i - 1 ]; } return deletions ; } Python 3: def alternatingCharacters ( s ): return sum ( s [ i ] == s [ i - 1 ] for i in range ( 1 , len ( s ))) Back","title":"Alternating Characters"},{"location":"interviewprep/stringmanipulation/makinganagrams/","text":"Strings: Making Anagrams Problem Category: String Manipulation Difficulty: Easy Given two strings, determine the minimum number of character deletions required to make the strings anagrams of each other. Input: two strings \\(a\\) and \\(b\\) of lowercase English letters. \\(1 \\leq |a|, |b| \\leq 10^4\\) Output: the minimum number of character deletions required (total character deletions from \\(a\\) and \\(b\\) ) to make \\(a\\) and \\(b\\) anagrams (the letters of \\(a\\) can be rearranged to create \\(b\\) , and vice versa). For this problem, it is useful to create frequency tables that store how many instances of each letter occur in \\(a\\) and \\(b\\) . Two strings are anagrams of each other if their frequency tables are the same. For example, \"hello\" and \"leloh\" are anagrams because both strings contain 1 'h' , 1 'e' , 2 'l' s, and 1 'o' . If \\(a\\) and \\(b\\) have the same frequencies for a letter \\(c\\) , then no instances of \\(c\\) need to be deleted from either string. However, if they do not have the same number of \\(c\\) 's, then the string with more \\(c\\) 's needs to delete some instances until both strings have the same number. Let \\(c_a\\) and \\(c_b\\) be the number of instances of character \\(c \\in [\\text{a-z}]\\) in \\(a\\) and \\(b\\) respectively. The minimum number of deletions needed \\(d\\) is: \\(d = \\sum_{c \\in [\\text{a-z}]} |c_a - c_b|\\) You can use maps for your frequency tables, or you can simply use arrays of 26 integers because the characters are limited to lowercase letters. With maps, it would be easier to extend your solution to allow more characters. Java 8: public static int makeAnagram ( String a , String b ) { Map < Character , Integer > aFreqMap = new HashMap <> (); Map < Character , Integer > bFreqMap = new HashMap <> (); for ( int i = 0 ; i < a . length (); i ++ ) { char ch = a . charAt ( i ); aFreqMap . put ( ch , aFreqMap . getOrDefault ( ch , 0 ) + 1 ); } for ( int i = 0 ; i < b . length (); i ++ ) { char ch = b . charAt ( i ); bFreqMap . put ( ch , bFreqMap . getOrDefault ( ch , 0 ) + 1 ); } int deletions = 0 ; for ( char ch = 'a' ; ch <= 'z' ; ch ++ ) { int aFreq = aFreqMap . getOrDefault ( ch , 0 ); int bFreq = bFreqMap . getOrDefault ( ch , 0 ); deletions += Math . abs ( aFreq - bFreq ); } return deletions ; } C++: int makeAnagram ( string a , string b ) { map < char , int > aFreqMap , bFreqMap ; for ( auto ch = a . begin (); ch != a . end (); ch ++ ) { aFreqMap [ * ch ] ++ ; } for ( auto ch = b . begin (); ch != b . end (); ch ++ ) { bFreqMap [ * ch ] ++ ; } int deletions = 0 ; for ( char ch = 'a' ; ch <= 'z' ; ch ++ ) { deletions += abs ( aFreqMap [ ch ] - bFreqMap [ ch ]); } return deletions ; } Python 3: def makeAnagram ( a , b ): letters = set ( a ) | set ( b ) a_freq = { ch : 0 for ch in letters } b_freq = { ch : 0 for ch in letters } for ch in a : a_freq [ ch ] += 1 for ch in b : b_freq [ ch ] += 1 deletions = 0 for ch in letters : deletions += abs ( a_freq [ ch ] - b_freq [ ch ]) return deletions Back","title":"Strings: Making Anagrams"},{"location":"interviewprep/stringmanipulation/makinganagrams/#strings-making-anagrams","text":"Problem Category: String Manipulation Difficulty: Easy Given two strings, determine the minimum number of character deletions required to make the strings anagrams of each other. Input: two strings \\(a\\) and \\(b\\) of lowercase English letters. \\(1 \\leq |a|, |b| \\leq 10^4\\) Output: the minimum number of character deletions required (total character deletions from \\(a\\) and \\(b\\) ) to make \\(a\\) and \\(b\\) anagrams (the letters of \\(a\\) can be rearranged to create \\(b\\) , and vice versa). For this problem, it is useful to create frequency tables that store how many instances of each letter occur in \\(a\\) and \\(b\\) . Two strings are anagrams of each other if their frequency tables are the same. For example, \"hello\" and \"leloh\" are anagrams because both strings contain 1 'h' , 1 'e' , 2 'l' s, and 1 'o' . If \\(a\\) and \\(b\\) have the same frequencies for a letter \\(c\\) , then no instances of \\(c\\) need to be deleted from either string. However, if they do not have the same number of \\(c\\) 's, then the string with more \\(c\\) 's needs to delete some instances until both strings have the same number. Let \\(c_a\\) and \\(c_b\\) be the number of instances of character \\(c \\in [\\text{a-z}]\\) in \\(a\\) and \\(b\\) respectively. The minimum number of deletions needed \\(d\\) is: \\(d = \\sum_{c \\in [\\text{a-z}]} |c_a - c_b|\\) You can use maps for your frequency tables, or you can simply use arrays of 26 integers because the characters are limited to lowercase letters. With maps, it would be easier to extend your solution to allow more characters. Java 8: public static int makeAnagram ( String a , String b ) { Map < Character , Integer > aFreqMap = new HashMap <> (); Map < Character , Integer > bFreqMap = new HashMap <> (); for ( int i = 0 ; i < a . length (); i ++ ) { char ch = a . charAt ( i ); aFreqMap . put ( ch , aFreqMap . getOrDefault ( ch , 0 ) + 1 ); } for ( int i = 0 ; i < b . length (); i ++ ) { char ch = b . charAt ( i ); bFreqMap . put ( ch , bFreqMap . getOrDefault ( ch , 0 ) + 1 ); } int deletions = 0 ; for ( char ch = 'a' ; ch <= 'z' ; ch ++ ) { int aFreq = aFreqMap . getOrDefault ( ch , 0 ); int bFreq = bFreqMap . getOrDefault ( ch , 0 ); deletions += Math . abs ( aFreq - bFreq ); } return deletions ; } C++: int makeAnagram ( string a , string b ) { map < char , int > aFreqMap , bFreqMap ; for ( auto ch = a . begin (); ch != a . end (); ch ++ ) { aFreqMap [ * ch ] ++ ; } for ( auto ch = b . begin (); ch != b . end (); ch ++ ) { bFreqMap [ * ch ] ++ ; } int deletions = 0 ; for ( char ch = 'a' ; ch <= 'z' ; ch ++ ) { deletions += abs ( aFreqMap [ ch ] - bFreqMap [ ch ]); } return deletions ; } Python 3: def makeAnagram ( a , b ): letters = set ( a ) | set ( b ) a_freq = { ch : 0 for ch in letters } b_freq = { ch : 0 for ch in letters } for ch in a : a_freq [ ch ] += 1 for ch in b : b_freq [ ch ] += 1 deletions = 0 for ch in letters : deletions += abs ( a_freq [ ch ] - b_freq [ ch ]) return deletions Back","title":"Strings: Making Anagrams"},{"location":"interviewprep/trees/heightofbinarytree/","text":"Trees: Height of Binary Tree Problem Category: Trees Difficulty: Easy Determine the height of a given binary tree. Input: the root of a binary tree with \\(n\\) nodes. \\(1 \\leq n \\leq 20\\) class Node { int data; Node* left; Node* right; } Output: the height of the tree, or the number of edges along the longest path from the root to a leaf node. The height of a tree is best found recursively. If the root is a leaf node, then its height is 0. Otherwise, the height of the tree is either the height of the left subtree plus 1, or the height of the right subtree plus 1, whichever is larger. The longest path to a leaf node is either on the left side or the right side of the tree. It is useful to define the height of a null tree as -1. This way, the height of the left/right subtree plus 1 evaluates to 0 if there is no left/right subtree. This is okay because the original tree is guaranteed to have at least one node. Java 8: public static int height ( Node root ) { if ( root == null ) { return - 1 ; } return 1 + Math . max ( height ( root . left ), height ( root . right )); } C++: int height ( Node * root ) { if ( ! root ) { return -1 ; } return 1 + max ( height ( root -> left ), height ( root -> right )); } Python 3: def height ( root ): if not root : return - 1 return 1 + max ( height ( root . left ), height ( root . right )) Back","title":"Trees: Height of Binary Tree"},{"location":"interviewprep/trees/heightofbinarytree/#trees-height-of-binary-tree","text":"Problem Category: Trees Difficulty: Easy Determine the height of a given binary tree. Input: the root of a binary tree with \\(n\\) nodes. \\(1 \\leq n \\leq 20\\) class Node { int data; Node* left; Node* right; } Output: the height of the tree, or the number of edges along the longest path from the root to a leaf node. The height of a tree is best found recursively. If the root is a leaf node, then its height is 0. Otherwise, the height of the tree is either the height of the left subtree plus 1, or the height of the right subtree plus 1, whichever is larger. The longest path to a leaf node is either on the left side or the right side of the tree. It is useful to define the height of a null tree as -1. This way, the height of the left/right subtree plus 1 evaluates to 0 if there is no left/right subtree. This is okay because the original tree is guaranteed to have at least one node. Java 8: public static int height ( Node root ) { if ( root == null ) { return - 1 ; } return 1 + Math . max ( height ( root . left ), height ( root . right )); } C++: int height ( Node * root ) { if ( ! root ) { return -1 ; } return 1 + max ( height ( root -> left ), height ( root -> right )); } Python 3: def height ( root ): if not root : return - 1 return 1 + max ( height ( root . left ), height ( root . right )) Back","title":"Trees: Height of Binary Tree"},{"location":"interviewprep/trees/lowestcommonancestor/","text":"Binary Search Tree: Lowest Common Ancestor Problem Category: Trees Difficulty: Easy Given two values in a binary search tree, find their lowest common ancestor. Input: the root of a binary search tree with \\(n\\) nodes, and two values \\(v_1, v_2\\) from the tree. \\(1 \\leq n \\leq 25\\) \\(1 \\leq v_1, v_2 \\leq 25, \\; v_1 \\neq v_2\\) class Node { int data; Node* left; Node* right; } Output: the lowest common ancestor node of \\(v_1\\) and \\(v_2\\) in the tree. If node \\(k\\) is an ancestor of node \\(v\\) , then the subtree with root \\(k\\) contains \\(v\\) , and the path from the root to \\(v\\) passes through \\(k\\) . The lowest common ancestor is the highest-depth node (lowest in the tree) that is both an ancestor to \\(v_1\\) and \\(v_2\\) . The key observation for this problem is that the answer depends on how the root node's value compares to \\(v_1\\) and \\(v_2\\) . If one of the values is in the left subtree and the other value is in the right subtree, then the root is the lowest common ancestor. If the root's value is equal to \\(v_1\\) or \\(v_2\\) , then the root is also the lowest common ancestor. In these cases, there is no lower common ancestor than the root beacuse no subtrees contain both \\(v_1\\) and \\(v_2\\) . If neither of these conditions are true, then either both values are in the left subtree or both values are in the right subtree, so their common ancestor is also in that subtree. You can determine whether \\(v_1\\) and \\(v_2\\) are to the left or the right of the root because the tree is a binary search tree: all values less than the root's value are in the left subtree, and all values greater than the root's value are in the right subtree. Java 8: public static Node lca ( Node root , int v1 , int v2 ) { if ( root . data == v1 || root . data == v2 ) { return root ; } if ( root . data > v1 && root . data > v2 ) { return lca ( root . left , v1 , v2 ); } if ( root . data < v1 && root . data < v2 ) { return lca ( root . right , v1 , v2 ); } return root ; } C++: Node * lca ( Node * root , int v1 , int v2 ) { if ( root -> data == v1 || root -> data == v2 ) { return root ; } if ( root -> data > v1 && root -> data > v2 ) { return lca ( root -> left , v1 , v2 ); } if ( root -> data < v1 && root -> data < v2 ) { return lca ( root -> right , v1 , v2 ); } return root ; } Python 3: def lca ( root , v1 , v2 ): if root . info == v1 or root . info == v2 : return root if root . info > v1 and root . info > v2 : return lca ( root . left , v1 , v2 ) if root . info < v1 and root . info < v2 : return lca ( root . right , v1 , v2 ) return root Back","title":"Binary Search Tree: Lowest Common Ancestor"},{"location":"interviewprep/trees/lowestcommonancestor/#binary-search-tree-lowest-common-ancestor","text":"Problem Category: Trees Difficulty: Easy Given two values in a binary search tree, find their lowest common ancestor. Input: the root of a binary search tree with \\(n\\) nodes, and two values \\(v_1, v_2\\) from the tree. \\(1 \\leq n \\leq 25\\) \\(1 \\leq v_1, v_2 \\leq 25, \\; v_1 \\neq v_2\\) class Node { int data; Node* left; Node* right; } Output: the lowest common ancestor node of \\(v_1\\) and \\(v_2\\) in the tree. If node \\(k\\) is an ancestor of node \\(v\\) , then the subtree with root \\(k\\) contains \\(v\\) , and the path from the root to \\(v\\) passes through \\(k\\) . The lowest common ancestor is the highest-depth node (lowest in the tree) that is both an ancestor to \\(v_1\\) and \\(v_2\\) . The key observation for this problem is that the answer depends on how the root node's value compares to \\(v_1\\) and \\(v_2\\) . If one of the values is in the left subtree and the other value is in the right subtree, then the root is the lowest common ancestor. If the root's value is equal to \\(v_1\\) or \\(v_2\\) , then the root is also the lowest common ancestor. In these cases, there is no lower common ancestor than the root beacuse no subtrees contain both \\(v_1\\) and \\(v_2\\) . If neither of these conditions are true, then either both values are in the left subtree or both values are in the right subtree, so their common ancestor is also in that subtree. You can determine whether \\(v_1\\) and \\(v_2\\) are to the left or the right of the root because the tree is a binary search tree: all values less than the root's value are in the left subtree, and all values greater than the root's value are in the right subtree. Java 8: public static Node lca ( Node root , int v1 , int v2 ) { if ( root . data == v1 || root . data == v2 ) { return root ; } if ( root . data > v1 && root . data > v2 ) { return lca ( root . left , v1 , v2 ); } if ( root . data < v1 && root . data < v2 ) { return lca ( root . right , v1 , v2 ); } return root ; } C++: Node * lca ( Node * root , int v1 , int v2 ) { if ( root -> data == v1 || root -> data == v2 ) { return root ; } if ( root -> data > v1 && root -> data > v2 ) { return lca ( root -> left , v1 , v2 ); } if ( root -> data < v1 && root -> data < v2 ) { return lca ( root -> right , v1 , v2 ); } return root ; } Python 3: def lca ( root , v1 , v2 ): if root . info == v1 or root . info == v2 : return root if root . info > v1 and root . info > v2 : return lca ( root . left , v1 , v2 ) if root . info < v1 and root . info < v2 : return lca ( root . right , v1 , v2 ) return root Back","title":"Binary Search Tree: Lowest Common Ancestor"},{"location":"interviewprep/warmup/countingvalleys/","text":"Counting Valleys Problem Category: Warm-up Challenges Difficulty: Easy Given a path of steps, which are either up or down, starting at sea level, determine the number of valleys crossed. A valley is a sequence of steps that starts at sea level, descends below sea level, and then returns to sea level. Input: a number of steps \\(s\\) and a path \\(p \\in \\{U, D\\}^s\\) , where \\(U\\) represents a step up and \\(D\\) represents a step down. The path begins and ends at sea level, so \\(p\\) has an equal number of \\(U\\) 's and \\(D\\) 's. \\(2 \\leq s \\leq 10^6\\) \\(|\\{i : p_i = U\\}| = |\\{i : p_i = D\\}| = \\frac{s}{2}\\) Output: the number of valleys (sequences that start at sea level, descend below sea level, and then return up to sea level). Read through the path and keep track of what elevation each step reaches. For example: \"UDDDUDUU\" \\(\\to\\) 0, 1, 0, -1, -2, -1, -2, -1, 0 We can see that a valley ends whenever we step up from elevation -1 to 0. The path is guaranteed to return to sea level (elevation 0) by the end, so every valley ends, and the number of times we step up from -1 to 0 is the number of valleys. Java 8: public static int countingValleys ( int steps , String path ) { int count = 0 ; int level = 0 ; for ( int i = 0 ; i < steps ; i ++ ) { if ( path . charAt ( i ) == 'U' ) { level ++ ; if ( level == 0 ) { count ++ ; } } else { level -- ; } } return count ; } C++: int countingValleys ( int steps , string path ) { int count = 0 ; int level = 0 ; for ( int i = 0 ; i < steps ; i ++ ) { if ( path [ i ] == 'U' ) { level ++ ; count += level == 0 ; } else { level -- ; } } return count ; } Python 3: def countingValleys ( steps , path ): level = 0 count = 0 for step in path : if step == \"U\" : level += 1 if level == 0 : count += 1 else : level -= 1 return count Back","title":"Counting Valleys"},{"location":"interviewprep/warmup/countingvalleys/#counting-valleys","text":"Problem Category: Warm-up Challenges Difficulty: Easy Given a path of steps, which are either up or down, starting at sea level, determine the number of valleys crossed. A valley is a sequence of steps that starts at sea level, descends below sea level, and then returns to sea level. Input: a number of steps \\(s\\) and a path \\(p \\in \\{U, D\\}^s\\) , where \\(U\\) represents a step up and \\(D\\) represents a step down. The path begins and ends at sea level, so \\(p\\) has an equal number of \\(U\\) 's and \\(D\\) 's. \\(2 \\leq s \\leq 10^6\\) \\(|\\{i : p_i = U\\}| = |\\{i : p_i = D\\}| = \\frac{s}{2}\\) Output: the number of valleys (sequences that start at sea level, descend below sea level, and then return up to sea level). Read through the path and keep track of what elevation each step reaches. For example: \"UDDDUDUU\" \\(\\to\\) 0, 1, 0, -1, -2, -1, -2, -1, 0 We can see that a valley ends whenever we step up from elevation -1 to 0. The path is guaranteed to return to sea level (elevation 0) by the end, so every valley ends, and the number of times we step up from -1 to 0 is the number of valleys. Java 8: public static int countingValleys ( int steps , String path ) { int count = 0 ; int level = 0 ; for ( int i = 0 ; i < steps ; i ++ ) { if ( path . charAt ( i ) == 'U' ) { level ++ ; if ( level == 0 ) { count ++ ; } } else { level -- ; } } return count ; } C++: int countingValleys ( int steps , string path ) { int count = 0 ; int level = 0 ; for ( int i = 0 ; i < steps ; i ++ ) { if ( path [ i ] == 'U' ) { level ++ ; count += level == 0 ; } else { level -- ; } } return count ; } Python 3: def countingValleys ( steps , path ): level = 0 count = 0 for step in path : if step == \"U\" : level += 1 if level == 0 : count += 1 else : level -= 1 return count Back","title":"Counting Valleys"},{"location":"interviewprep/warmup/jumpingontheclouds/","text":"Jumping on the Clouds Problem Category: Warm-Up Challenges Difficulty: Easy Given a pattern of safe and dangerous clouds leading to a goal, determine the minimum number of jumps required to reach the end safely. Input: a number of clouds \\(n\\) and a pattern \\(c_1, \\ldots c_n\\) where \\(c_1 = 0\\) , \\(c_n = 0\\) , and \\(c_i \\in \\{0, 1\\}\\) for \\(1 < i < n\\) . \\(c_i = 0\\) means cloud \\(i\\) is safe, and \\(c_i = 1\\) means cloud \\(i\\) must be avoided. \\(2 \\leq n \\leq 100\\) Output: the minimum number of jumps needed to win the game. The player starts on cloud 1 and must reach cloud \\(n\\) . They can jump forward 1 or 2 clouds at a time. It is guaranteed that the player can win, so there will never be two dangerous clouds in a row. We can be greedy by taking advantage of the fact that there is always a path to the end. If the player is at cloud \\(i\\) (starting at cloud 0), look at cloud \\(i + 2\\) : If cloud \\(i + 2\\) is safe, you should always jump 2 spaces forward to that cloud. If cloud \\(i + 2\\) is dangerous, you can (and should) jump 1 space forward to cloud \\(i + 1\\) instead. The first cloud is safe, and there are no two consecutive dangerous clouds. Therefore, for any safe cloud at \\(i\\) , if you can't jump to \\(i + 2\\) , you can jump to \\(i + 1\\) and then to \\(i + 3\\) and so on. For the Java solution, c is given as a List instead of an array, so my solution converts it into an array first. You only need to read through the list once sequentially to solve the problem, so it is possible to use an iterator over the list instead of converting it into an array and indexing into it. Java 8: public static int jumpingOnClouds ( List < Integer > c ) { final int N = c . size (); Integer [] clouds = c . toArray ( new Integer [ N ] ); int jumps = 0 ; int position = 0 ; while ( position + 1 < N ) { if ( position + 2 < N && clouds [ position + 2 ] == 0 ) { position += 2 ; } else { position ++ ; } jumps ++ ; } return jumps ; } C++: int jumpingOnClouds ( vector < int > c ) { const int n = c . size (); int jumps = 0 ; int position = 0 ; while ( position + 1 < n ) { position += 1 + ( position + 2 < n && ! c [ position + 2 ]); jumps ++ ; } return jumps ; } Python 3: def jumpingOnClouds ( c ): n = len ( c ) position = 0 jumps = 0 while position + 1 < n : if position + 2 < n and c [ position + 2 ] == 0 : position += 2 else : position += 1 jumps += 1 return jumps Back","title":"Jumping on the Clouds"},{"location":"interviewprep/warmup/jumpingontheclouds/#jumping-on-the-clouds","text":"Problem Category: Warm-Up Challenges Difficulty: Easy Given a pattern of safe and dangerous clouds leading to a goal, determine the minimum number of jumps required to reach the end safely. Input: a number of clouds \\(n\\) and a pattern \\(c_1, \\ldots c_n\\) where \\(c_1 = 0\\) , \\(c_n = 0\\) , and \\(c_i \\in \\{0, 1\\}\\) for \\(1 < i < n\\) . \\(c_i = 0\\) means cloud \\(i\\) is safe, and \\(c_i = 1\\) means cloud \\(i\\) must be avoided. \\(2 \\leq n \\leq 100\\) Output: the minimum number of jumps needed to win the game. The player starts on cloud 1 and must reach cloud \\(n\\) . They can jump forward 1 or 2 clouds at a time. It is guaranteed that the player can win, so there will never be two dangerous clouds in a row. We can be greedy by taking advantage of the fact that there is always a path to the end. If the player is at cloud \\(i\\) (starting at cloud 0), look at cloud \\(i + 2\\) : If cloud \\(i + 2\\) is safe, you should always jump 2 spaces forward to that cloud. If cloud \\(i + 2\\) is dangerous, you can (and should) jump 1 space forward to cloud \\(i + 1\\) instead. The first cloud is safe, and there are no two consecutive dangerous clouds. Therefore, for any safe cloud at \\(i\\) , if you can't jump to \\(i + 2\\) , you can jump to \\(i + 1\\) and then to \\(i + 3\\) and so on. For the Java solution, c is given as a List instead of an array, so my solution converts it into an array first. You only need to read through the list once sequentially to solve the problem, so it is possible to use an iterator over the list instead of converting it into an array and indexing into it. Java 8: public static int jumpingOnClouds ( List < Integer > c ) { final int N = c . size (); Integer [] clouds = c . toArray ( new Integer [ N ] ); int jumps = 0 ; int position = 0 ; while ( position + 1 < N ) { if ( position + 2 < N && clouds [ position + 2 ] == 0 ) { position += 2 ; } else { position ++ ; } jumps ++ ; } return jumps ; } C++: int jumpingOnClouds ( vector < int > c ) { const int n = c . size (); int jumps = 0 ; int position = 0 ; while ( position + 1 < n ) { position += 1 + ( position + 2 < n && ! c [ position + 2 ]); jumps ++ ; } return jumps ; } Python 3: def jumpingOnClouds ( c ): n = len ( c ) position = 0 jumps = 0 while position + 1 < n : if position + 2 < n and c [ position + 2 ] == 0 : position += 2 else : position += 1 jumps += 1 return jumps Back","title":"Jumping on the Clouds"},{"location":"interviewprep/warmup/repeatedstring/","text":"Repeated String Problem Category: Warm-up Challenges Difficulty: Easy Find the number of a's in the first \\(n\\) letters of an infinitely repeating string. Input: a string \\(s\\) of lowercase English letters, and \\(n\\) , the length of the substring to consider when \\(s\\) is repeated infinitely. \\(1 \\leq |s| \\leq 100, 1 \\leq n \\leq 10^{12}\\) Output: the number of a's in the first \\(n\\) characters of the infinitely repeating string generated by \\(s\\) . \\(n\\) can be a very large number, so you cannot store the entire \\(n\\) -length substring to count the number of a's. However, we know the substring will contain \\(\\lfloor \\frac{n}{|s|} \\rfloor\\) complete instances of \\(s\\) , and then the remainder will be the first \\(k = n\\) mod \\(|s|\\) characters of \\(s\\) . Count the number of a's in the first \\(k\\) characters of \\(s\\) , as well as the number of a's in all of \\(s\\) , and you can calculate the number of a's in the \\(n\\) characters generated by repeating \\(s\\) . Java 8: public static long repeatedString ( String s , long n ) { long fullCount = n / s . length (); int partial = ( int ) ( n % s . length ()); int count = 0 ; int partialCount = 0 ; for ( int i = 0 ; i < s . length (); i ++ ) { if ( s . charAt ( i ) == 'a' ) { if ( i < partial ) { partialCount ++ ; } count ++ ; } } return fullCount * count + partialCount ; } C++: long repeatedString ( string s , long n ) { const long fullCount = n / s . size (); const int part = n % s . size (); int count = 0 ; int partialCount = 0 ; for ( int i = 0 ; i < s . size (); i ++ ) { if ( s [ i ] == 'a' ) { if ( i < part ) { partialCount ++ ; } count ++ ; } i ++ ; } return fullCount * count + partialCount ; } Python 3: def repeatedString ( s , n ): full_count = n // len ( s ) partial = s [:( n % len ( s ))] return full_count * s . count ( 'a' ) + partial . count ( 'a' ) Back","title":"Repeated String"},{"location":"interviewprep/warmup/repeatedstring/#repeated-string","text":"Problem Category: Warm-up Challenges Difficulty: Easy Find the number of a's in the first \\(n\\) letters of an infinitely repeating string. Input: a string \\(s\\) of lowercase English letters, and \\(n\\) , the length of the substring to consider when \\(s\\) is repeated infinitely. \\(1 \\leq |s| \\leq 100, 1 \\leq n \\leq 10^{12}\\) Output: the number of a's in the first \\(n\\) characters of the infinitely repeating string generated by \\(s\\) . \\(n\\) can be a very large number, so you cannot store the entire \\(n\\) -length substring to count the number of a's. However, we know the substring will contain \\(\\lfloor \\frac{n}{|s|} \\rfloor\\) complete instances of \\(s\\) , and then the remainder will be the first \\(k = n\\) mod \\(|s|\\) characters of \\(s\\) . Count the number of a's in the first \\(k\\) characters of \\(s\\) , as well as the number of a's in all of \\(s\\) , and you can calculate the number of a's in the \\(n\\) characters generated by repeating \\(s\\) . Java 8: public static long repeatedString ( String s , long n ) { long fullCount = n / s . length (); int partial = ( int ) ( n % s . length ()); int count = 0 ; int partialCount = 0 ; for ( int i = 0 ; i < s . length (); i ++ ) { if ( s . charAt ( i ) == 'a' ) { if ( i < partial ) { partialCount ++ ; } count ++ ; } } return fullCount * count + partialCount ; } C++: long repeatedString ( string s , long n ) { const long fullCount = n / s . size (); const int part = n % s . size (); int count = 0 ; int partialCount = 0 ; for ( int i = 0 ; i < s . size (); i ++ ) { if ( s [ i ] == 'a' ) { if ( i < part ) { partialCount ++ ; } count ++ ; } i ++ ; } return fullCount * count + partialCount ; } Python 3: def repeatedString ( s , n ): full_count = n // len ( s ) partial = s [:( n % len ( s ))] return full_count * s . count ( 'a' ) + partial . count ( 'a' ) Back","title":"Repeated String"},{"location":"interviewprep/warmup/salesbymatch/","text":"Sales by Match Problem Category: Warm-up Challenges Difficulty: Easy Given a list of socks, determine how many pairs of matching-color socks can be made. Input: a list of socks \\(ar[n]\\) , where \\(ar[i]\\) is an integer representing the color of sock \\(i\\) . \\(1 \\leq n \\leq 100, 1 \\leq ar[i] \\leq 100 \\; \\forall \\; i\\) Output: the maximum number of pairs that can be achieved by pairing socks that have the same color We don't need the number of total possible ways to pair the socks; we just need to maximum number of pairs achievable by any pairing where no sock is matched to a sock of a different color. For example, [1, 1, 1, 1, 1] has at most 2 matches: one way to achieve this is by matching sock 0 to sock 1 and sock 2 to sock 3, leaving sock 4 unpaired. Make a set to store available sock colors and loop through the list of socks. Check if each sock's color is in the set so far: If sock \\(i\\) 's color is not in the set, then you have no sock to pair with \\(i\\) . \\(i\\) is a loose sock available for a future pairing. If sock \\(i\\) 's color is in the set, then there is a previous sock available to pair with \\(i\\) . Remove \\(i\\) 's color from the set and record that a pair has been made. Another solution could be to count how many socks there are of each color. If a color appears on \\(k\\) socks, then \\(\\lfloor \\frac{k}{2} \\rfloor\\) is the number of pairs that can be made with that color. Java 8: public static int sockMerchant ( int n , List < Integer > ar ) { int count = 0 ; Set < Integer > colors = new HashSet <> (); for ( int sock : ar ) { if ( colors . remove ( sock )) { count ++ ; } else { colors . add ( sock ); } } return count ; } C++: int sockMerchant ( int n , vector < int > ar ) { int count = 0 ; set < int > colors ; for ( int i = 0 ; i < n ; i ++ ) { if ( colors . erase ( ar [ i ])) { count ++ ; } else { colors . insert ( ar [ i ]); } } return count ; } Python 3: def sockMerchant ( n , ar ): colors = set () count = 0 for i in ar : if i in colors : count += 1 colors . remove ( i ) else : colors . add ( i ) return count Python 3 Alternate Solution: def sockMerchant ( n , ar ): sock_freq = { sock : ar . count ( sock ) for sock in ar } return sum ( v // 2 for _ , v in sock_freq . items ()) Back","title":"Sales by Match"},{"location":"interviewprep/warmup/salesbymatch/#sales-by-match","text":"Problem Category: Warm-up Challenges Difficulty: Easy Given a list of socks, determine how many pairs of matching-color socks can be made. Input: a list of socks \\(ar[n]\\) , where \\(ar[i]\\) is an integer representing the color of sock \\(i\\) . \\(1 \\leq n \\leq 100, 1 \\leq ar[i] \\leq 100 \\; \\forall \\; i\\) Output: the maximum number of pairs that can be achieved by pairing socks that have the same color We don't need the number of total possible ways to pair the socks; we just need to maximum number of pairs achievable by any pairing where no sock is matched to a sock of a different color. For example, [1, 1, 1, 1, 1] has at most 2 matches: one way to achieve this is by matching sock 0 to sock 1 and sock 2 to sock 3, leaving sock 4 unpaired. Make a set to store available sock colors and loop through the list of socks. Check if each sock's color is in the set so far: If sock \\(i\\) 's color is not in the set, then you have no sock to pair with \\(i\\) . \\(i\\) is a loose sock available for a future pairing. If sock \\(i\\) 's color is in the set, then there is a previous sock available to pair with \\(i\\) . Remove \\(i\\) 's color from the set and record that a pair has been made. Another solution could be to count how many socks there are of each color. If a color appears on \\(k\\) socks, then \\(\\lfloor \\frac{k}{2} \\rfloor\\) is the number of pairs that can be made with that color. Java 8: public static int sockMerchant ( int n , List < Integer > ar ) { int count = 0 ; Set < Integer > colors = new HashSet <> (); for ( int sock : ar ) { if ( colors . remove ( sock )) { count ++ ; } else { colors . add ( sock ); } } return count ; } C++: int sockMerchant ( int n , vector < int > ar ) { int count = 0 ; set < int > colors ; for ( int i = 0 ; i < n ; i ++ ) { if ( colors . erase ( ar [ i ])) { count ++ ; } else { colors . insert ( ar [ i ]); } } return count ; } Python 3: def sockMerchant ( n , ar ): colors = set () count = 0 for i in ar : if i in colors : count += 1 colors . remove ( i ) else : colors . add ( i ) return count Python 3 Alternate Solution: def sockMerchant ( n , ar ): sock_freq = { sock : ar . count ( sock ) for sock in ar } return sum ( v // 2 for _ , v in sock_freq . items ()) Back","title":"Sales by Match"}]}