{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Campbell's Home Welcome to my page! Source","title":"Home"},{"location":"#campbells-home","text":"Welcome to my page! Source","title":"Campbell's Home"},{"location":"hackerrank/","text":"HackerRank Content Interview Preparation Kit These are my solution write-ups for the Interview Preparation Kit problems on HackerRank. In general, I assume you are familiar and comfortable with the syntax of the language you want to use, so I focus more on algorithm design. I provide example implementations of my solutions in Java, C++, and Python 3 that passed all test cases at the time of writing. Name Category Difficulty Sales by Match Warm-up Challenges Easy Counting Valleys Warm-up Challenges Easy Jumping on the Clouds Warm-up Challenges Easy Repeated String Warm-up Challenges Easy 2D Array - DS Arrays Easy Arrays: Left Rotation Arrays Easy New Year Chaos Arrays Medium Minimum Swaps 2 Arrays Medium Hash Tables: Ransom Note Dictionaries and Hashmaps Easy Two Strings Dictionaries and Hashmaps Easy Sherlock and Anagrams Dictionaries and Hashmaps Medium Count Triplets Dictionaries and Hashmaps Medium Frequency Queries Dictionaries and Hashmaps Medium Sorting: Bubble Sort Sorting Easy Mark and Toys Sorting Easy Sorting: Comparator Sorting Medium Fraudulent Activity Notifications Sorting Medium Strings: Making Anagrams String Manipulation Easy Alternating Characters String Manipulation Easy Sherlock and the Valid String String Manipulation Medium Special String Again String Manipulation Medium Common Child String Manipulation Medium Minimum Absolute Difference in an Array Greedy Algorithms Easy Luck Balance Greedy Algorithms Easy Greedy Florist Greedy Algorithms Medium Max Min Greedy Algorithms Medium Hash Tables: Ice Cream Parlor Search Medium Swap Nodes [Algo] Search Medium Pairs Search Medium Triple Sum Search Medium Minimum Time Required Search Medium Max Array Sum Dynamic Programming Medium Abbreviation Dynamic Programming Medium Tree: Height of a Binary Tree Trees Easy Binary Search Tree: Lowest Common Ancestor Trees Easy Insert a Node at a Specific Position in a Linked List Linked Lists Easy Inserting a Node into a Sorted Doubly Linked List Linked Lists Easy Reverse a Doubly Linked List Linked Lists Easy Find Merge Point of Two Lists Linked Lists Easy Linked Lists: Detect a Cycle Linked Lists Easy Recursion: Fibonacci Numbers Recursion and Backtracking Easy Flipping Bits Miscellaneous Easy","title":"HackerRank"},{"location":"hackerrank/#hackerrank-content","text":"","title":"HackerRank Content"},{"location":"hackerrank/#interview-preparation-kit","text":"These are my solution write-ups for the Interview Preparation Kit problems on HackerRank. In general, I assume you are familiar and comfortable with the syntax of the language you want to use, so I focus more on algorithm design. I provide example implementations of my solutions in Java, C++, and Python 3 that passed all test cases at the time of writing. Name Category Difficulty Sales by Match Warm-up Challenges Easy Counting Valleys Warm-up Challenges Easy Jumping on the Clouds Warm-up Challenges Easy Repeated String Warm-up Challenges Easy 2D Array - DS Arrays Easy Arrays: Left Rotation Arrays Easy New Year Chaos Arrays Medium Minimum Swaps 2 Arrays Medium Hash Tables: Ransom Note Dictionaries and Hashmaps Easy Two Strings Dictionaries and Hashmaps Easy Sherlock and Anagrams Dictionaries and Hashmaps Medium Count Triplets Dictionaries and Hashmaps Medium Frequency Queries Dictionaries and Hashmaps Medium Sorting: Bubble Sort Sorting Easy Mark and Toys Sorting Easy Sorting: Comparator Sorting Medium Fraudulent Activity Notifications Sorting Medium Strings: Making Anagrams String Manipulation Easy Alternating Characters String Manipulation Easy Sherlock and the Valid String String Manipulation Medium Special String Again String Manipulation Medium Common Child String Manipulation Medium Minimum Absolute Difference in an Array Greedy Algorithms Easy Luck Balance Greedy Algorithms Easy Greedy Florist Greedy Algorithms Medium Max Min Greedy Algorithms Medium Hash Tables: Ice Cream Parlor Search Medium Swap Nodes [Algo] Search Medium Pairs Search Medium Triple Sum Search Medium Minimum Time Required Search Medium Max Array Sum Dynamic Programming Medium Abbreviation Dynamic Programming Medium Tree: Height of a Binary Tree Trees Easy Binary Search Tree: Lowest Common Ancestor Trees Easy Insert a Node at a Specific Position in a Linked List Linked Lists Easy Inserting a Node into a Sorted Doubly Linked List Linked Lists Easy Reverse a Doubly Linked List Linked Lists Easy Find Merge Point of Two Lists Linked Lists Easy Linked Lists: Detect a Cycle Linked Lists Easy Recursion: Fibonacci Numbers Recursion and Backtracking Easy Flipping Bits Miscellaneous Easy","title":"Interview Preparation Kit"},{"location":"interviewprep/arrays/ds/","text":"2D Array - DS Problem Category: Arrays Difficulty: Easy Given a \\(6 \\times 6\\) array, find the maximum \"hourglass sum.\" Input: a 2D array, \\(arr[i][j]\\) for \\(1 \\leq i, j \\leq 6\\) . \\[ -9 \\leq arr[i][j] \\leq 9 \\; \\forall \\; i, j \\] Output: the maximum hourglass sum of the array. For any \\(3 \\times 3\\) block of \\(arr\\) , the hourglass sum is the sum of the top 3, bottom 3, and center entries: [[a, b, c], [d, e, f], [g, h, i]] \\(\\; \\to \\; a + b + c + e + g + h + i\\) Every hourglass sum is at least -63 and at most 63. There are only 16 possible \\(3 \\times 3\\) blocks in \\(arr\\) , so there are only 16 hourglass sums to check. You can loop through the center entries of each block ( \\(arr[1][1] \\ldots arr[4][4]\\) ) and calculate an hourglass sum for each. Java 8: public static int hourglassSum ( List < List < Integer >> arr ) { final int SIZE = 6 ; Integer [][] mat = new Integer [ SIZE ][ SIZE ] ; int i = 0 ; for ( List < Integer > row : arr ) { mat [ i ] = row . toArray ( mat [ i ] ); i ++ ; } final int END = SIZE - 1 ; final int MIN_VAL = - 9 ; int max = MIN_VAL * 7 ; for ( i = 1 ; i < END ; i ++ ) { for ( int j = 1 ; j < END ; j ++ ) { int sum = mat [ i - 1 ][ j - 1 ] + mat [ i - 1 ][ j ] + mat [ i - 1 ][ j + 1 ] ; sum += mat [ i ][ j ] ; sum += mat [ i + 1 ][ j - 1 ] + mat [ i + 1 ][ j ] + mat [ i + 1 ][ j + 1 ] ; max = Math . max ( max , sum ); } } return max ; } C++: int hourglassSum ( vector < vector < int >> arr ) { const int minVal = -9 ; int maxSum = minVal * 7 ; const int end = arr . size () - 1 ; for ( int i = 1 ; i < end ; i ++ ) { for ( int j = 1 ; j < end ; j ++ ) { int sum = arr [ i - 1 ][ j - 1 ] + arr [ i - 1 ][ j ] + arr [ i - 1 ][ j + 1 ]; sum += arr [ i ][ j ]; sum += arr [ i + 1 ][ j - 1 ] + arr [ i + 1 ][ j ] + arr [ i + 1 ][ j + 1 ]; maxSum = max ( maxSum , sum ); } } return maxSum ; } Python 3: def hourglassSum ( arr ): min_val = - 9 max_sum = min_val * 7 end = len ( arr ) - 1 for i in range ( 1 , end ): for j in range ( 1 , end ): hourglass_sum = sum ( arr [ i - 1 ][( j - 1 ):( j + 2 )]) hourglass_sum += arr [ i ][ j ] hourglass_sum += sum ( arr [ i + 1 ][( j - 1 ):( j + 2 )]) max_sum = max ( max_sum , hourglass_sum ) return max_sum Back","title":"2D Array - DS"},{"location":"interviewprep/arrays/ds/#2d-array-ds","text":"Problem Category: Arrays Difficulty: Easy Given a \\(6 \\times 6\\) array, find the maximum \"hourglass sum.\" Input: a 2D array, \\(arr[i][j]\\) for \\(1 \\leq i, j \\leq 6\\) . \\[ -9 \\leq arr[i][j] \\leq 9 \\; \\forall \\; i, j \\] Output: the maximum hourglass sum of the array. For any \\(3 \\times 3\\) block of \\(arr\\) , the hourglass sum is the sum of the top 3, bottom 3, and center entries: [[a, b, c], [d, e, f], [g, h, i]] \\(\\; \\to \\; a + b + c + e + g + h + i\\) Every hourglass sum is at least -63 and at most 63. There are only 16 possible \\(3 \\times 3\\) blocks in \\(arr\\) , so there are only 16 hourglass sums to check. You can loop through the center entries of each block ( \\(arr[1][1] \\ldots arr[4][4]\\) ) and calculate an hourglass sum for each. Java 8: public static int hourglassSum ( List < List < Integer >> arr ) { final int SIZE = 6 ; Integer [][] mat = new Integer [ SIZE ][ SIZE ] ; int i = 0 ; for ( List < Integer > row : arr ) { mat [ i ] = row . toArray ( mat [ i ] ); i ++ ; } final int END = SIZE - 1 ; final int MIN_VAL = - 9 ; int max = MIN_VAL * 7 ; for ( i = 1 ; i < END ; i ++ ) { for ( int j = 1 ; j < END ; j ++ ) { int sum = mat [ i - 1 ][ j - 1 ] + mat [ i - 1 ][ j ] + mat [ i - 1 ][ j + 1 ] ; sum += mat [ i ][ j ] ; sum += mat [ i + 1 ][ j - 1 ] + mat [ i + 1 ][ j ] + mat [ i + 1 ][ j + 1 ] ; max = Math . max ( max , sum ); } } return max ; } C++: int hourglassSum ( vector < vector < int >> arr ) { const int minVal = -9 ; int maxSum = minVal * 7 ; const int end = arr . size () - 1 ; for ( int i = 1 ; i < end ; i ++ ) { for ( int j = 1 ; j < end ; j ++ ) { int sum = arr [ i - 1 ][ j - 1 ] + arr [ i - 1 ][ j ] + arr [ i - 1 ][ j + 1 ]; sum += arr [ i ][ j ]; sum += arr [ i + 1 ][ j - 1 ] + arr [ i + 1 ][ j ] + arr [ i + 1 ][ j + 1 ]; maxSum = max ( maxSum , sum ); } } return maxSum ; } Python 3: def hourglassSum ( arr ): min_val = - 9 max_sum = min_val * 7 end = len ( arr ) - 1 for i in range ( 1 , end ): for j in range ( 1 , end ): hourglass_sum = sum ( arr [ i - 1 ][( j - 1 ):( j + 2 )]) hourglass_sum += arr [ i ][ j ] hourglass_sum += sum ( arr [ i + 1 ][( j - 1 ):( j + 2 )]) max_sum = max ( max_sum , hourglass_sum ) return max_sum Back","title":"2D Array - DS"},{"location":"interviewprep/arrays/leftrotation/","text":"Arrays: Left Rotation Problem Category: Arrays Difficulty: Easy Given an array, rotate it to the left by \\(d\\) elements. Input: an array \\(a[n]\\) and a number of rotations to make, \\(d\\) . \\[ 1 \\leq d \\leq n \\leq 10^5 \\] \\[ 1 \\leq a[i] \\leq 10^6 \\; \\forall \\; i \\] Output: the array shifted \\(d\\) elements to the left. For example, for the following array, shifting to the left by 1 element gives: [1, 2, 3, 4] \\(\\to\\) [2, 3, 4, 1] By 3 elements: [1, 2, 3, 4] \\(\\to\\) [2, 3, 4, 1] \\(\\to\\) [3, 4, 1, 2] \\(\\to\\) [4, 1, 2, 3] Shifting by 4 elements brings the array back to its original order. The array could be modified in place, but for this problem it is okay to use an extra array to store the values in their new positions without overriding the values in the original array. For the value at position \\(i\\) , you can calculate its new position \\(i'\\) with \\(d\\) : \\[ i' \\gets (i - d) \\bmod n \\] Note that using the modulus operator with negative numbers may not always work the way you expect. You might need to add \\(n\\) : \\[ i' \\gets (i - d + n) \\bmod n \\] The new array should have the elements from \\(d\\) to the end, followed by the elements from 0 to \\(d - 1\\) . The description suggests that you should modify the array passed to the function, but it also works to create and return a new array with the correct values. Java 8: public static List < Integer > rotLeft ( List < Integer > a , int d ) { Iterator < Integer > iter = a . iterator (); List < Integer > start = new LinkedList <> (); for ( int i = 0 ; i < d ; i ++ ) { start . add ( iter . next ()); } List < Integer > newList = new LinkedList <> (); while ( iter . hasNext ()) { newList . add ( iter . next ()); } a . clear (); a . addAll ( newList ); a . addAll ( start ); return a ; } C++: vector < int > rotLeft ( vector < int > a , int d ) { const int n = a . size (); vector < int > newVector ( n , 0 ); for ( int i = 0 ; i < n ; i ++ ) { newVector [( i - d + n ) % n ] = a [ i ]; } a = newVector ; return a ; } Python 3: def rotLeft ( a , d ): new_list = a [ d :] + a [: d ] a . clear () a . extend ( new_list ) return a Back","title":"Arrays: Left Rotation"},{"location":"interviewprep/arrays/leftrotation/#arrays-left-rotation","text":"Problem Category: Arrays Difficulty: Easy Given an array, rotate it to the left by \\(d\\) elements. Input: an array \\(a[n]\\) and a number of rotations to make, \\(d\\) . \\[ 1 \\leq d \\leq n \\leq 10^5 \\] \\[ 1 \\leq a[i] \\leq 10^6 \\; \\forall \\; i \\] Output: the array shifted \\(d\\) elements to the left. For example, for the following array, shifting to the left by 1 element gives: [1, 2, 3, 4] \\(\\to\\) [2, 3, 4, 1] By 3 elements: [1, 2, 3, 4] \\(\\to\\) [2, 3, 4, 1] \\(\\to\\) [3, 4, 1, 2] \\(\\to\\) [4, 1, 2, 3] Shifting by 4 elements brings the array back to its original order. The array could be modified in place, but for this problem it is okay to use an extra array to store the values in their new positions without overriding the values in the original array. For the value at position \\(i\\) , you can calculate its new position \\(i'\\) with \\(d\\) : \\[ i' \\gets (i - d) \\bmod n \\] Note that using the modulus operator with negative numbers may not always work the way you expect. You might need to add \\(n\\) : \\[ i' \\gets (i - d + n) \\bmod n \\] The new array should have the elements from \\(d\\) to the end, followed by the elements from 0 to \\(d - 1\\) . The description suggests that you should modify the array passed to the function, but it also works to create and return a new array with the correct values. Java 8: public static List < Integer > rotLeft ( List < Integer > a , int d ) { Iterator < Integer > iter = a . iterator (); List < Integer > start = new LinkedList <> (); for ( int i = 0 ; i < d ; i ++ ) { start . add ( iter . next ()); } List < Integer > newList = new LinkedList <> (); while ( iter . hasNext ()) { newList . add ( iter . next ()); } a . clear (); a . addAll ( newList ); a . addAll ( start ); return a ; } C++: vector < int > rotLeft ( vector < int > a , int d ) { const int n = a . size (); vector < int > newVector ( n , 0 ); for ( int i = 0 ; i < n ; i ++ ) { newVector [( i - d + n ) % n ] = a [ i ]; } a = newVector ; return a ; } Python 3: def rotLeft ( a , d ): new_list = a [ d :] + a [: d ] a . clear () a . extend ( new_list ) return a Back","title":"Arrays: Left Rotation"},{"location":"interviewprep/arrays/minimumswaps2/","text":"Minimum Swaps 2 Problem Category: Arrays Difficulty: Medium Given an array of numbers 1 through \\(n\\) , determine the minimum number of swaps needed to sort the array in ascending order. Input: an array \\(a[n]\\) , which stores a permutation of the values \\(\\{1, 2, \\ldots, n\\}\\) . \\[ 1 \\leq n \\leq 10^5 \\] Output: the minimum number of swaps needed to sort \\(a\\) in ascending order. We need at most \\(n - 1\\) swaps to sort the array: take an element that is not in the correct position and swap it to its correct position, and repeat up to \\(n - 2\\) times until there are only two values out of order, and swap them as your \\((n - 1)^{\\text{th}}\\) swap. Every time a value is in the wrong position in the array, you need to use a swap to move it to the right position, and then you never have to touch it again. For \\(1 \\leq i \\leq n\\) , we already know that the value \\(i\\) belongs at index \\(i - 1\\) in the sorted array. For some fixed \\(i\\) , let \\(a[j] = i\\) and \\(a[i - 1] = k\\) , so \\(j\\) is the current position of \\(i\\) and \\(k\\) is the value in the entry where \\(i\\) belongs. Swap \\(i\\) and \\(k\\) so that \\(a[j] = k\\) and \\(a[i - 1] = i\\) . Now, \\(i\\) is in its correct position. \\(k\\) may be in its correct position too if it happens that \\(j = k - 1\\) . Otherwise, we can repeat the process with \\(i = k\\) . Each swap we make puts at least one value in the correct spot, so we will achieve the optimal number of swaps. Java 8: static int minimumSwaps ( int [] arr ) { int [] a = Arrays . copyOf ( arr , arr . length ); int swaps = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { while ( a [ i ] > i + 1 ) { int temp = a [ i ] ; a [ i ] = a [ temp - 1 ] ; a [ temp - 1 ] = temp ; swaps ++ ; } } return swaps ; } C++: int minimumSwaps ( vector < int > arr ) { vector < int > a = arr ; int swaps = 0 ; for ( int i = 0 ; i < a . size (); i ++ ) { while ( a [ i ] > i + 1 ) { int temp = a [ i ]; a [ i ] = a [ temp - 1 ]; a [ temp - 1 ] = temp ; swaps ++ ; } } return swaps ; } Python 3: def minimumSwaps ( arr ): a = list ( arr ) swaps = 0 for i in range ( len ( a )): while a [ i ] > i + 1 : temp = a [ i ] a [ i ], a [ temp - 1 ] = a [ temp - 1 ], temp swaps += 1 return swaps Back","title":"Minimum Swaps 2"},{"location":"interviewprep/arrays/minimumswaps2/#minimum-swaps-2","text":"Problem Category: Arrays Difficulty: Medium Given an array of numbers 1 through \\(n\\) , determine the minimum number of swaps needed to sort the array in ascending order. Input: an array \\(a[n]\\) , which stores a permutation of the values \\(\\{1, 2, \\ldots, n\\}\\) . \\[ 1 \\leq n \\leq 10^5 \\] Output: the minimum number of swaps needed to sort \\(a\\) in ascending order. We need at most \\(n - 1\\) swaps to sort the array: take an element that is not in the correct position and swap it to its correct position, and repeat up to \\(n - 2\\) times until there are only two values out of order, and swap them as your \\((n - 1)^{\\text{th}}\\) swap. Every time a value is in the wrong position in the array, you need to use a swap to move it to the right position, and then you never have to touch it again. For \\(1 \\leq i \\leq n\\) , we already know that the value \\(i\\) belongs at index \\(i - 1\\) in the sorted array. For some fixed \\(i\\) , let \\(a[j] = i\\) and \\(a[i - 1] = k\\) , so \\(j\\) is the current position of \\(i\\) and \\(k\\) is the value in the entry where \\(i\\) belongs. Swap \\(i\\) and \\(k\\) so that \\(a[j] = k\\) and \\(a[i - 1] = i\\) . Now, \\(i\\) is in its correct position. \\(k\\) may be in its correct position too if it happens that \\(j = k - 1\\) . Otherwise, we can repeat the process with \\(i = k\\) . Each swap we make puts at least one value in the correct spot, so we will achieve the optimal number of swaps. Java 8: static int minimumSwaps ( int [] arr ) { int [] a = Arrays . copyOf ( arr , arr . length ); int swaps = 0 ; for ( int i = 0 ; i < a . length ; i ++ ) { while ( a [ i ] > i + 1 ) { int temp = a [ i ] ; a [ i ] = a [ temp - 1 ] ; a [ temp - 1 ] = temp ; swaps ++ ; } } return swaps ; } C++: int minimumSwaps ( vector < int > arr ) { vector < int > a = arr ; int swaps = 0 ; for ( int i = 0 ; i < a . size (); i ++ ) { while ( a [ i ] > i + 1 ) { int temp = a [ i ]; a [ i ] = a [ temp - 1 ]; a [ temp - 1 ] = temp ; swaps ++ ; } } return swaps ; } Python 3: def minimumSwaps ( arr ): a = list ( arr ) swaps = 0 for i in range ( len ( a )): while a [ i ] > i + 1 : temp = a [ i ] a [ i ], a [ temp - 1 ] = a [ temp - 1 ], temp swaps += 1 return swaps Back","title":"Minimum Swaps 2"},{"location":"interviewprep/arrays/newyearchaos/","text":"New Year Chaos Problem Category: Arrays Difficulty: Medium Given the order of a group of people waiting in line, determine the minimum number of times it must have occurred that a person swapped places with the person in front of them. Input: an array \\(q[n]\\) , which stores a permutation of the values \\(\\{1, 2, \\ldots, n\\}\\) . \\[ 1 \\leq n \\leq 10^5 \\] Output: the minimum number of \"bribes\" that must have taken place in \\(q\\) . When a person commits a bribe, they swap places with the person immediately in front of them. For example, if \\(n = 4\\) , the line starts out as [1, 2, 3, 4] . If person 3 bribes the person in front of them, the line becomes [1, 3, 2, 4] . If they bribe the person in front of them again, the line becomes [3, 1, 2, 4] . Nobody is allowed to make more than 2 bribes, so if \\(q\\) suggests that a person must have made more than 2 brides, print the message \"Too chaotic\" . \\(q\\) represents a line of people, where \\(q[0]\\) is the person at the front and \\(q[n - 1]\\) is the last person in line. From now on, think of \"moving forward\" as going to the left and \"moving backward\" as going to the right in the array. For a person \\(q[i]\\) , the people \\(q[j]\\) for \\(j < i\\) are ahead of \\(q[i]\\) in line, and the people \\(q[j]\\) for \\(j > i\\) are behind \\(q[i]\\) in line. Here are a few observations to make: Person \\(q[i]\\) starts at index \\(q[i] - 1\\) . Every time they make a bribe, they move forward one position, and every time another person bribes them, they move backward one position. Person \\(q[i]\\) can only bribe two times at most, so they can be at most two positions in front of their starting position. \\(q[i]\\) started at \\(q[i] - 1\\) , so their new position \\(i\\) must be at least \\(q[i] - 3\\) . \\(i < q[i] - 3\\) implies that the person \\(q[i]\\) must have bribed at least 3 people, so \\(q\\) is too chaotic. Any person in front of \\(q[i]\\) whose value is greater than \\(q[i]\\) must have bribed them. If \\(q[j] > q[i]\\) and \\(j < i\\) , then \\(q[j]\\) bribed \\(q[i]\\) . Any person who bribed \\(q[i]\\) could only have bribed one other person. They can be at most one position in front of \\(q[i]\\) 's starting position \\(q[i] - 1\\) . If \\(q[j]\\) bribed \\(q[i]\\) , then \\(q[i] - 2 \\leq j < i\\) . It turns out that \\(i < q[i] - 3\\) if and only if \\(q[i]\\) must have bribed at least 3 people. You may wonder about a situation where \\(q[i]\\) bribes more than 2 people, but then gets bribed by many others and ends up behind where they started. In order for this to happen, some of the people \\(q[i]\\) bribed would have to have bribed them back, making those bribes unnecessary. We are looking for the minimum possible number bribes that could have been made to achieve \\(q\\) , so we are only interested in counting bribes that are strictly necessary. For each person \\(q[i]\\) in the array, check whether \\(i \\geq q[i] - 3\\) to determine if the person made no more than 2 bribes, and then count how many bribes \\(q[i]\\) must have received. Anyone who bribed \\(q[i]\\) must be between positions \\(q[i] - 2\\) and \\(i\\) . Java 8: public static void minimumBribes ( List < Integer > q ) { final int N = q . size (); Integer [] arr = q . toArray ( new Integer [ N ] ); int result = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i < arr [ i ] - 3 ) { System . out . println ( \"Too chaotic\" ); return ; } for ( int j = Math . max ( arr [ i ] - 2 , 0 ); j < i ; j ++ ) { if ( arr [ j ] > arr [ i ] ) { result ++ ; } } } System . out . println ( result ); } C++: void minimumBribes ( vector < int > q ) { const int n = q . size (); int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < q [ i ] - 3 ) { cout << \"Too chaotic\" << endl ; return ; } for ( int j = max ( q [ i ] - 2 , 0 ); j < i ; j ++ ) { result += q [ j ] > q [ i ]; } } cout << result << endl ; } Python 3: def minimumBribes ( q ): result = 0 for i , val in enumerate ( q ): if i < val - 3 : return print ( \"Too chaotic\" ) result += sum ( q [ j ] > q [ i ] for j in range ( max ( val - 2 , 0 ), i )) print ( result ) Back","title":"New Year Chaos"},{"location":"interviewprep/arrays/newyearchaos/#new-year-chaos","text":"Problem Category: Arrays Difficulty: Medium Given the order of a group of people waiting in line, determine the minimum number of times it must have occurred that a person swapped places with the person in front of them. Input: an array \\(q[n]\\) , which stores a permutation of the values \\(\\{1, 2, \\ldots, n\\}\\) . \\[ 1 \\leq n \\leq 10^5 \\] Output: the minimum number of \"bribes\" that must have taken place in \\(q\\) . When a person commits a bribe, they swap places with the person immediately in front of them. For example, if \\(n = 4\\) , the line starts out as [1, 2, 3, 4] . If person 3 bribes the person in front of them, the line becomes [1, 3, 2, 4] . If they bribe the person in front of them again, the line becomes [3, 1, 2, 4] . Nobody is allowed to make more than 2 bribes, so if \\(q\\) suggests that a person must have made more than 2 brides, print the message \"Too chaotic\" . \\(q\\) represents a line of people, where \\(q[0]\\) is the person at the front and \\(q[n - 1]\\) is the last person in line. From now on, think of \"moving forward\" as going to the left and \"moving backward\" as going to the right in the array. For a person \\(q[i]\\) , the people \\(q[j]\\) for \\(j < i\\) are ahead of \\(q[i]\\) in line, and the people \\(q[j]\\) for \\(j > i\\) are behind \\(q[i]\\) in line. Here are a few observations to make: Person \\(q[i]\\) starts at index \\(q[i] - 1\\) . Every time they make a bribe, they move forward one position, and every time another person bribes them, they move backward one position. Person \\(q[i]\\) can only bribe two times at most, so they can be at most two positions in front of their starting position. \\(q[i]\\) started at \\(q[i] - 1\\) , so their new position \\(i\\) must be at least \\(q[i] - 3\\) . \\(i < q[i] - 3\\) implies that the person \\(q[i]\\) must have bribed at least 3 people, so \\(q\\) is too chaotic. Any person in front of \\(q[i]\\) whose value is greater than \\(q[i]\\) must have bribed them. If \\(q[j] > q[i]\\) and \\(j < i\\) , then \\(q[j]\\) bribed \\(q[i]\\) . Any person who bribed \\(q[i]\\) could only have bribed one other person. They can be at most one position in front of \\(q[i]\\) 's starting position \\(q[i] - 1\\) . If \\(q[j]\\) bribed \\(q[i]\\) , then \\(q[i] - 2 \\leq j < i\\) . It turns out that \\(i < q[i] - 3\\) if and only if \\(q[i]\\) must have bribed at least 3 people. You may wonder about a situation where \\(q[i]\\) bribes more than 2 people, but then gets bribed by many others and ends up behind where they started. In order for this to happen, some of the people \\(q[i]\\) bribed would have to have bribed them back, making those bribes unnecessary. We are looking for the minimum possible number bribes that could have been made to achieve \\(q\\) , so we are only interested in counting bribes that are strictly necessary. For each person \\(q[i]\\) in the array, check whether \\(i \\geq q[i] - 3\\) to determine if the person made no more than 2 bribes, and then count how many bribes \\(q[i]\\) must have received. Anyone who bribed \\(q[i]\\) must be between positions \\(q[i] - 2\\) and \\(i\\) . Java 8: public static void minimumBribes ( List < Integer > q ) { final int N = q . size (); Integer [] arr = q . toArray ( new Integer [ N ] ); int result = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( i < arr [ i ] - 3 ) { System . out . println ( \"Too chaotic\" ); return ; } for ( int j = Math . max ( arr [ i ] - 2 , 0 ); j < i ; j ++ ) { if ( arr [ j ] > arr [ i ] ) { result ++ ; } } } System . out . println ( result ); } C++: void minimumBribes ( vector < int > q ) { const int n = q . size (); int result = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i < q [ i ] - 3 ) { cout << \"Too chaotic\" << endl ; return ; } for ( int j = max ( q [ i ] - 2 , 0 ); j < i ; j ++ ) { result += q [ j ] > q [ i ]; } } cout << result << endl ; } Python 3: def minimumBribes ( q ): result = 0 for i , val in enumerate ( q ): if i < val - 3 : return print ( \"Too chaotic\" ) result += sum ( q [ j ] > q [ i ] for j in range ( max ( val - 2 , 0 ), i )) print ( result ) Back","title":"New Year Chaos"},{"location":"interviewprep/dicts/counttriplets/","text":"Count Triplets Problem Category: Dictionaries and Hashmaps Difficulty: Medium Given an array of integers and a base \\(r\\) , count the number triplets with values that are geometric progressions with common ratio \\(r\\) . Input: an array \\(a[n]\\) and a value \\(r\\) . \\[ 1 \\leq n \\leq 10^5 \\] \\[ 1 \\leq r \\leq 10^9 \\] \\[ 1 \\leq a[i] \\leq 10^9 \\; \\forall \\; i \\] Output: the number of triplet subarrays \\((i, j, k)\\) for \\(0 \\leq i < j < k < n\\) where \\(a[k] = a[j] * r = a[i] * r^2\\) . For example, for \\(r = 2\\) , the array [5, 10, 20, 30, 40] has 2 geometric triplets: (0, 1, 2) and (1, 2, 4), which correspond to values [5, 10, 20] and [10, 20, 40] respectively. For each value \\(a[i]\\) in the array, it seems that we need to know two pieces of information: How many values before a[i] have we seen that are equal to \\(\\frac{a[i]}{r}\\) ? \\[ A_i = \\left\\{j : j < i, a[j] = \\frac{a[i]}{r}\\right\\} \\] For each of those values, how many values came before them that are equal to \\(\\frac{a[i]}{r^2}\\) ? \\[ \\sum_{j \\in A_i} |A_j| \\] With this information, we can count the number of triplets for which \\(a[i]\\) is the last value. Use one map to count how many times each value \\(v\\) has occurred in the array: \\[ \\begin{align*} V_i(v) & \\gets \\{j : j < i, a[j] = v\\} \\\\ f_i(v) & \\gets |V_i(v)| \\end{align*} \\] Use another map to count how many pairs of the form \\((\\frac{a[i]}{r}, a[i])\\) you can make so far for each value. \\[ g_i(v) \\gets \\sum_{j \\in V_i(v)} |A_j| \\] \\[ V_i\\left(\\frac{a[i]}{r}\\right) = A_i \\implies g_i(v) = \\sum_{j \\in V_i(v)} f_i\\left(\\frac{a[j]}{r}\\right) \\] In my code, I refer to \\(f\\) and \\(g\\) as iTable and jTable , respectively. For each value \\(v\\) in \\(a\\) , check if \\(v\\) is divisible by \\(r\\) . If it is not, then it does not end any triplets, but it could be the start of a later one, so increment \\(f(v)\\) . Otherwise, \\(g(\\frac{v}{r})\\) is the number of triplets ending in \\(v\\) . Increment \\(g(v)\\) by the number of times you have seen \\(\\frac{v}{r}\\) , which is \\(f(\\frac{v}{r})\\) , and also increment \\(f(v)\\) by one. Java 8: static long countTriplets ( List < Long > arr , long r ) { Map < Long , Long > iTable = new HashMap <> (); Map < Long , Long > jTable = new HashMap <> (); long result = 0 L ; for ( long val : arr ) { if ( val % r == 0 ) { long prev = val / r ; result += jTable . getOrDefault ( prev , 0 L ); long tripletsAsJ = jTable . getOrDefault ( val , 0 L ); tripletsAsJ += iTable . getOrDefault ( prev , 0 L ); jTable . put ( val , tripletsAsJ ); } iTable . put ( val , iTable . getOrDefault ( val , 0 L ) + 1L ); } return result ; } C++: long countTriplets ( vector < long > arr , long r ) { map < long , long > iTable ; map < long , long > jTable ; long result = 0L ; for ( auto val = arr . begin (); val != arr . end (); val ++ ) { if ( ! ( * val % r )) { long prev = * val / r ; result += jTable [ prev ]; jTable [ * val ] += iTable [ prev ]; } iTable [ * val ] ++ ; } return result ; } Python 3: def countTriplets ( arr , r ): i_table = {} j_table = {} result = 0 for val in arr : if not val % r : prev = val // r result += j_table . get ( prev , 0 ) j_table [ val ] = j_table . get ( val , 0 ) + i_table . get ( prev , 0 ) i_table [ val ] = i_table . get ( val , 0 ) + 1 return result Back","title":"Count Triplets"},{"location":"interviewprep/dicts/counttriplets/#count-triplets","text":"Problem Category: Dictionaries and Hashmaps Difficulty: Medium Given an array of integers and a base \\(r\\) , count the number triplets with values that are geometric progressions with common ratio \\(r\\) . Input: an array \\(a[n]\\) and a value \\(r\\) . \\[ 1 \\leq n \\leq 10^5 \\] \\[ 1 \\leq r \\leq 10^9 \\] \\[ 1 \\leq a[i] \\leq 10^9 \\; \\forall \\; i \\] Output: the number of triplet subarrays \\((i, j, k)\\) for \\(0 \\leq i < j < k < n\\) where \\(a[k] = a[j] * r = a[i] * r^2\\) . For example, for \\(r = 2\\) , the array [5, 10, 20, 30, 40] has 2 geometric triplets: (0, 1, 2) and (1, 2, 4), which correspond to values [5, 10, 20] and [10, 20, 40] respectively. For each value \\(a[i]\\) in the array, it seems that we need to know two pieces of information: How many values before a[i] have we seen that are equal to \\(\\frac{a[i]}{r}\\) ? \\[ A_i = \\left\\{j : j < i, a[j] = \\frac{a[i]}{r}\\right\\} \\] For each of those values, how many values came before them that are equal to \\(\\frac{a[i]}{r^2}\\) ? \\[ \\sum_{j \\in A_i} |A_j| \\] With this information, we can count the number of triplets for which \\(a[i]\\) is the last value. Use one map to count how many times each value \\(v\\) has occurred in the array: \\[ \\begin{align*} V_i(v) & \\gets \\{j : j < i, a[j] = v\\} \\\\ f_i(v) & \\gets |V_i(v)| \\end{align*} \\] Use another map to count how many pairs of the form \\((\\frac{a[i]}{r}, a[i])\\) you can make so far for each value. \\[ g_i(v) \\gets \\sum_{j \\in V_i(v)} |A_j| \\] \\[ V_i\\left(\\frac{a[i]}{r}\\right) = A_i \\implies g_i(v) = \\sum_{j \\in V_i(v)} f_i\\left(\\frac{a[j]}{r}\\right) \\] In my code, I refer to \\(f\\) and \\(g\\) as iTable and jTable , respectively. For each value \\(v\\) in \\(a\\) , check if \\(v\\) is divisible by \\(r\\) . If it is not, then it does not end any triplets, but it could be the start of a later one, so increment \\(f(v)\\) . Otherwise, \\(g(\\frac{v}{r})\\) is the number of triplets ending in \\(v\\) . Increment \\(g(v)\\) by the number of times you have seen \\(\\frac{v}{r}\\) , which is \\(f(\\frac{v}{r})\\) , and also increment \\(f(v)\\) by one. Java 8: static long countTriplets ( List < Long > arr , long r ) { Map < Long , Long > iTable = new HashMap <> (); Map < Long , Long > jTable = new HashMap <> (); long result = 0 L ; for ( long val : arr ) { if ( val % r == 0 ) { long prev = val / r ; result += jTable . getOrDefault ( prev , 0 L ); long tripletsAsJ = jTable . getOrDefault ( val , 0 L ); tripletsAsJ += iTable . getOrDefault ( prev , 0 L ); jTable . put ( val , tripletsAsJ ); } iTable . put ( val , iTable . getOrDefault ( val , 0 L ) + 1L ); } return result ; } C++: long countTriplets ( vector < long > arr , long r ) { map < long , long > iTable ; map < long , long > jTable ; long result = 0L ; for ( auto val = arr . begin (); val != arr . end (); val ++ ) { if ( ! ( * val % r )) { long prev = * val / r ; result += jTable [ prev ]; jTable [ * val ] += iTable [ prev ]; } iTable [ * val ] ++ ; } return result ; } Python 3: def countTriplets ( arr , r ): i_table = {} j_table = {} result = 0 for val in arr : if not val % r : prev = val // r result += j_table . get ( prev , 0 ) j_table [ val ] = j_table . get ( val , 0 ) + i_table . get ( prev , 0 ) i_table [ val ] = i_table . get ( val , 0 ) + 1 return result Back","title":"Count Triplets"},{"location":"interviewprep/dicts/frequencyqueries/","text":"Frequency Queries Problem Category: Dictionaries and Hashmaps Difficulty: Medium Respond to a list of queries for how many times a number appears in a data structure. Input: a list of operations \\(q\\) where \\(q_i = (t_i, v_i)\\) . \\(t_i\\) indicates the type of the \\(i^{\\text{th}}\\) operation: \\(t_i = 1\\) : add an instance of \\(v_i\\) to the data structure. \\(t_i = 2\\) : remove an instance of \\(v_i\\) from the data structure. \\(t_i = 3\\) : query whether there is a number in the data structure that occurs exactly \\(v_i\\) times. \\[ 1 \\leq |q| \\leq 10^5 \\] \\[ 1 \\leq v_i \\leq 10^9 \\; \\forall \\; i \\] Output: a list of integers that contains a response to each \\(t_i = 3\\) query in order: 1 if there is a number with frequency \\(v_i\\) in the data structure, 0 otherwise. The list will be \\(|\\{i : t_i = 3\\}|\\) elements long. We could solve this problem with a map that stores the frequency of each value. Type 1 and 2 operations update the map's \\(v_i\\) entry, and then for each type 3 query, we need to search the keys of the map until we find one that has frequency \\(v_i\\) . However, it would be better if we could look up values by frequency in order to answer queries without checking the frequency of every value. We can accomplish this with a second map that is keyed by frequencies. Multiple values can have the same frequency, so you want to map each frequency to the set of values that occur with that frequency. If \\(f(v)\\) is your lookup table, where \\(f_i(v)\\) is the number of instances of \\(v\\) in the data structure by the \\(i^{\\text{th}}\\) iteration, then your other map \\(f^{-1}(v)\\) should store the pullbacks of \\(f\\) : \\[ f_i^{-1}(v) = \\{u : f_i(u) = v\\} \\] Now, you can read through the operations and handle them as follows: \\(t_i = 1\\) : remove \\(v_i\\) from \\(f^{-1}(f(v_i))\\) and add it to \\(f^{-1}(f(v_i) + 1)\\) , then increment \\(f(v_i)\\) . \\(t_i = 2\\) : remove \\(v_i\\) from \\(f^{-1}(f(v_i))\\) and add it to \\(f^{-1}(f(v_i) - 1)\\) , then decrement \\(f(v_i)\\) . \\(t_i = 3\\) : add 0 to the output if \\(f^{-1}(v_i) = \\emptyset\\) , else add 1 For my reference solutions, I implemented this data structure as a class called FrequencyTable . I refer to \\(f\\) and \\(f^{-1}\\) as freq and freqLookup respectively. Java 8: static List < Integer > freqQuery ( List < List < Integer >> queries ) { FrequencyTable freqTable = new FrequencyTable (); List < Integer > result = new ArrayList <> (); for ( List < Integer > q : queries ) { int type = q . get ( 0 ); int val = q . get ( 1 ); if ( type == 1 ) { freqTable . insert ( val ); } else if ( type == 2 ) { freqTable . delete ( val ); } else { result . add ( freqTable . hasFrequency ( val ) ? 1 : 0 ); } } return result ; } private static class FrequencyTable { private Map < Integer , Integer > freq ; private Map < Integer , Set < Integer >> freqLookup ; public FrequencyTable () { freq = new HashMap <> (); freqLookup = new HashMap <> (); } public void insert ( int x ) { int f = freq . getOrDefault ( x , 0 ); freq . put ( x , f + 1 ); if ( f > 0 ) { freqLookup . get ( f ). remove ( x ); } if ( ! freqLookup . containsKey ( f + 1 )) { freqLookup . put ( f + 1 , new HashSet <> ()); } freqLookup . get ( f + 1 ). add ( x ); } public void delete ( int y ) { int f = freq . getOrDefault ( y , 0 ); if ( f > 0 ) { freq . put ( y , f - 1 ); freqLookup . get ( f ). remove ( y ); if ( f > 1 ) { freqLookup . get ( f - 1 ). add ( y ); } } } public boolean hasFrequency ( int z ) { Set < Integer > freqSet = freqLookup . get ( z ); return freqSet != null && ! freqSet . isEmpty (); } } C++: class FrequencyTable { private : map < int , int > freq ; map < int , set < int >*> freqLookup ; public : void insert ( int x ) { int f = freq [ x ]; freq [ x ] ++ ; if ( f > 0 ) { freqLookup [ f ] -> erase ( x ); } if ( freqLookup . find ( f + 1 ) == freqLookup . end ()) { freqLookup [ f + 1 ] = new set < int > (); } freqLookup [ f + 1 ] -> insert ( x ); } void remove ( int y ) { int f = freq [ y ]; if ( f > 0 ) { freq [ y ] -- ; freqLookup [ f ] -> erase ( y ); if ( f > 1 ) { freqLookup [ f - 1 ] -> insert ( y ); } } } bool hasFrequency ( int z ) { bool present = freqLookup . find ( z ) != freqLookup . end (); return present && ! freqLookup [ z ] -> empty (); } }; vector < int > freqQuery ( vector < vector < int >> queries ) { FrequencyTable freqTable ; vector < int > result ; for ( auto q = queries . begin (); q != queries . end (); q ++ ) { int type = ( * q )[ 0 ]; int val = ( * q )[ 1 ]; if ( type == 1 ) { freqTable . insert ( val ); } else if ( type == 2 ) { freqTable . remove ( val ); } else { result . push_back ( freqTable . hasFrequency ( val )); } } return result ; } Python 3: def freqQuery ( queries ): freq_table = FrequencyTable () result = [] for op , val in queries : if op == 1 : freq_table . insert ( val ) elif op == 2 : freq_table . delete ( val ) else : result . append ( int ( freq_table . has_frequency ( val ))) return result class FrequencyTable : def __init__ ( self ): self . freq = {} self . freq_lookup = {} def insert ( self , x ): f = self . freq . get ( x , 0 ) self . freq [ x ] = f + 1 if f > 0 : self . freq_lookup [ f ] . remove ( x ) if f + 1 not in self . freq_lookup : self . freq_lookup [ f + 1 ] = set () self . freq_lookup [ f + 1 ] . add ( x ) def delete ( self , y ): f = self . freq . get ( y , 0 ) if f > 0 : self . freq [ y ] = f - 1 self . freq_lookup [ f ] . remove ( y ) if f > 1 : self . freq_lookup [ f - 1 ] . add ( y ) def has_frequency ( self , z ): return len ( self . freq_lookup . get ( z , set ())) > 0 Back","title":"Frequency Queries"},{"location":"interviewprep/dicts/frequencyqueries/#frequency-queries","text":"Problem Category: Dictionaries and Hashmaps Difficulty: Medium Respond to a list of queries for how many times a number appears in a data structure. Input: a list of operations \\(q\\) where \\(q_i = (t_i, v_i)\\) . \\(t_i\\) indicates the type of the \\(i^{\\text{th}}\\) operation: \\(t_i = 1\\) : add an instance of \\(v_i\\) to the data structure. \\(t_i = 2\\) : remove an instance of \\(v_i\\) from the data structure. \\(t_i = 3\\) : query whether there is a number in the data structure that occurs exactly \\(v_i\\) times. \\[ 1 \\leq |q| \\leq 10^5 \\] \\[ 1 \\leq v_i \\leq 10^9 \\; \\forall \\; i \\] Output: a list of integers that contains a response to each \\(t_i = 3\\) query in order: 1 if there is a number with frequency \\(v_i\\) in the data structure, 0 otherwise. The list will be \\(|\\{i : t_i = 3\\}|\\) elements long. We could solve this problem with a map that stores the frequency of each value. Type 1 and 2 operations update the map's \\(v_i\\) entry, and then for each type 3 query, we need to search the keys of the map until we find one that has frequency \\(v_i\\) . However, it would be better if we could look up values by frequency in order to answer queries without checking the frequency of every value. We can accomplish this with a second map that is keyed by frequencies. Multiple values can have the same frequency, so you want to map each frequency to the set of values that occur with that frequency. If \\(f(v)\\) is your lookup table, where \\(f_i(v)\\) is the number of instances of \\(v\\) in the data structure by the \\(i^{\\text{th}}\\) iteration, then your other map \\(f^{-1}(v)\\) should store the pullbacks of \\(f\\) : \\[ f_i^{-1}(v) = \\{u : f_i(u) = v\\} \\] Now, you can read through the operations and handle them as follows: \\(t_i = 1\\) : remove \\(v_i\\) from \\(f^{-1}(f(v_i))\\) and add it to \\(f^{-1}(f(v_i) + 1)\\) , then increment \\(f(v_i)\\) . \\(t_i = 2\\) : remove \\(v_i\\) from \\(f^{-1}(f(v_i))\\) and add it to \\(f^{-1}(f(v_i) - 1)\\) , then decrement \\(f(v_i)\\) . \\(t_i = 3\\) : add 0 to the output if \\(f^{-1}(v_i) = \\emptyset\\) , else add 1 For my reference solutions, I implemented this data structure as a class called FrequencyTable . I refer to \\(f\\) and \\(f^{-1}\\) as freq and freqLookup respectively. Java 8: static List < Integer > freqQuery ( List < List < Integer >> queries ) { FrequencyTable freqTable = new FrequencyTable (); List < Integer > result = new ArrayList <> (); for ( List < Integer > q : queries ) { int type = q . get ( 0 ); int val = q . get ( 1 ); if ( type == 1 ) { freqTable . insert ( val ); } else if ( type == 2 ) { freqTable . delete ( val ); } else { result . add ( freqTable . hasFrequency ( val ) ? 1 : 0 ); } } return result ; } private static class FrequencyTable { private Map < Integer , Integer > freq ; private Map < Integer , Set < Integer >> freqLookup ; public FrequencyTable () { freq = new HashMap <> (); freqLookup = new HashMap <> (); } public void insert ( int x ) { int f = freq . getOrDefault ( x , 0 ); freq . put ( x , f + 1 ); if ( f > 0 ) { freqLookup . get ( f ). remove ( x ); } if ( ! freqLookup . containsKey ( f + 1 )) { freqLookup . put ( f + 1 , new HashSet <> ()); } freqLookup . get ( f + 1 ). add ( x ); } public void delete ( int y ) { int f = freq . getOrDefault ( y , 0 ); if ( f > 0 ) { freq . put ( y , f - 1 ); freqLookup . get ( f ). remove ( y ); if ( f > 1 ) { freqLookup . get ( f - 1 ). add ( y ); } } } public boolean hasFrequency ( int z ) { Set < Integer > freqSet = freqLookup . get ( z ); return freqSet != null && ! freqSet . isEmpty (); } } C++: class FrequencyTable { private : map < int , int > freq ; map < int , set < int >*> freqLookup ; public : void insert ( int x ) { int f = freq [ x ]; freq [ x ] ++ ; if ( f > 0 ) { freqLookup [ f ] -> erase ( x ); } if ( freqLookup . find ( f + 1 ) == freqLookup . end ()) { freqLookup [ f + 1 ] = new set < int > (); } freqLookup [ f + 1 ] -> insert ( x ); } void remove ( int y ) { int f = freq [ y ]; if ( f > 0 ) { freq [ y ] -- ; freqLookup [ f ] -> erase ( y ); if ( f > 1 ) { freqLookup [ f - 1 ] -> insert ( y ); } } } bool hasFrequency ( int z ) { bool present = freqLookup . find ( z ) != freqLookup . end (); return present && ! freqLookup [ z ] -> empty (); } }; vector < int > freqQuery ( vector < vector < int >> queries ) { FrequencyTable freqTable ; vector < int > result ; for ( auto q = queries . begin (); q != queries . end (); q ++ ) { int type = ( * q )[ 0 ]; int val = ( * q )[ 1 ]; if ( type == 1 ) { freqTable . insert ( val ); } else if ( type == 2 ) { freqTable . remove ( val ); } else { result . push_back ( freqTable . hasFrequency ( val )); } } return result ; } Python 3: def freqQuery ( queries ): freq_table = FrequencyTable () result = [] for op , val in queries : if op == 1 : freq_table . insert ( val ) elif op == 2 : freq_table . delete ( val ) else : result . append ( int ( freq_table . has_frequency ( val ))) return result class FrequencyTable : def __init__ ( self ): self . freq = {} self . freq_lookup = {} def insert ( self , x ): f = self . freq . get ( x , 0 ) self . freq [ x ] = f + 1 if f > 0 : self . freq_lookup [ f ] . remove ( x ) if f + 1 not in self . freq_lookup : self . freq_lookup [ f + 1 ] = set () self . freq_lookup [ f + 1 ] . add ( x ) def delete ( self , y ): f = self . freq . get ( y , 0 ) if f > 0 : self . freq [ y ] = f - 1 self . freq_lookup [ f ] . remove ( y ) if f > 1 : self . freq_lookup [ f - 1 ] . add ( y ) def has_frequency ( self , z ): return len ( self . freq_lookup . get ( z , set ())) > 0 Back","title":"Frequency Queries"},{"location":"interviewprep/dicts/ransomnote/","text":"Hash Tables: Ransom Note Problem Category: Dictionaries and Hashmaps Difficulty: Easy Given a list of words in a magazine, determine whether it is possible to cut out enough words to write a given ransom note. Input: arrays \\(magazine[m]\\) and \\(note[n]\\) of strings, each of which is a word made of uppercase and lowercase English letters. \\[ 1 \\leq m, n \\leq 3 \\times 10^5 \\] Output: print Yes if it is possible to arrange the words of \\(magazine\\) to write the \\(note\\) , otherwise print No . For example, if the \\(note\\) is [\"two\", \"plus\", \"two\", \"is\", \"four\"] , then if the \\(magazine\\) contains two \"two\" s, a \"plus\" , an \"is\" , and a \"four\" , then the output is Yes . If it is missing any of those, or it only has one \"two\" , or there is a \"Plus\" instead of a \"plus\" , then the answer is No . Note that the words are case-sensitive. It is not enough to know that every word in \\(note\\) is also in \\(magazine\\) ; there must be as many instances of any word in \\(magazine\\) as there are in \\(note\\) . You can use maps to count the number of occurences in each word of \\(magazine\\) and \\(note\\) . The answer is No if there is a word in your \\(note\\) map that either doesn't occur in \\(magazine\\) or occurs fewer times in \\(magazine\\) than in \\(note\\) . Java 8: public static void checkMagazine ( List < String > magazine , List < String > note ) { Map < String , Integer > magazineFreq = new HashMap <> (); Map < String , Integer > noteFreq = new HashMap <> (); for ( String word : magazine ) { magazineFreq . put ( word , magazineFreq . getOrDefault ( word , 0 ) + 1 ); } for ( String word : note ) { noteFreq . put ( word , noteFreq . getOrDefault ( word , 0 ) + 1 ); } for ( String word : noteFreq . keySet ()) { if ( noteFreq . get ( word ) > magazineFreq . getOrDefault ( word , 0 )) { System . out . println ( \"No\" ); return ; } } System . out . println ( \"Yes\" ); } C++: void checkMagazine ( vector < string > magazine , vector < string > note ) { map < string , int > magazineFreq ; map < string , int > noteFreq ; for ( auto word = magazine . begin (); word != magazine . end (); word ++ ) { magazineFreq [ * word ] ++ ; } for ( auto word = note . begin (); word != note . end (); word ++ ) { noteFreq [ * word ] ++ ; } for ( auto entry = noteFreq . begin (); entry != noteFreq . end (); entry ++ ) { if ( entry -> second > magazineFreq [ entry -> first ]) { cout << \"No\" << endl ; return ; } } cout << \"Yes\" << endl ; } Python 3: def checkMagazine ( magazine , note ): magazine_freq = { word : 0 for word in magazine } note_freq = { word : 0 for word in note } for word in magazine : magazine_freq [ word ] += 1 for word in note : note_freq [ word ] += 1 for word , freq in note_freq . items (): if word not in magazine_freq or magazine_freq [ word ] < freq : print ( \"No\" ) return print ( \"Yes\" ) Back","title":"Hash Tables: Ransom Note"},{"location":"interviewprep/dicts/ransomnote/#hash-tables-ransom-note","text":"Problem Category: Dictionaries and Hashmaps Difficulty: Easy Given a list of words in a magazine, determine whether it is possible to cut out enough words to write a given ransom note. Input: arrays \\(magazine[m]\\) and \\(note[n]\\) of strings, each of which is a word made of uppercase and lowercase English letters. \\[ 1 \\leq m, n \\leq 3 \\times 10^5 \\] Output: print Yes if it is possible to arrange the words of \\(magazine\\) to write the \\(note\\) , otherwise print No . For example, if the \\(note\\) is [\"two\", \"plus\", \"two\", \"is\", \"four\"] , then if the \\(magazine\\) contains two \"two\" s, a \"plus\" , an \"is\" , and a \"four\" , then the output is Yes . If it is missing any of those, or it only has one \"two\" , or there is a \"Plus\" instead of a \"plus\" , then the answer is No . Note that the words are case-sensitive. It is not enough to know that every word in \\(note\\) is also in \\(magazine\\) ; there must be as many instances of any word in \\(magazine\\) as there are in \\(note\\) . You can use maps to count the number of occurences in each word of \\(magazine\\) and \\(note\\) . The answer is No if there is a word in your \\(note\\) map that either doesn't occur in \\(magazine\\) or occurs fewer times in \\(magazine\\) than in \\(note\\) . Java 8: public static void checkMagazine ( List < String > magazine , List < String > note ) { Map < String , Integer > magazineFreq = new HashMap <> (); Map < String , Integer > noteFreq = new HashMap <> (); for ( String word : magazine ) { magazineFreq . put ( word , magazineFreq . getOrDefault ( word , 0 ) + 1 ); } for ( String word : note ) { noteFreq . put ( word , noteFreq . getOrDefault ( word , 0 ) + 1 ); } for ( String word : noteFreq . keySet ()) { if ( noteFreq . get ( word ) > magazineFreq . getOrDefault ( word , 0 )) { System . out . println ( \"No\" ); return ; } } System . out . println ( \"Yes\" ); } C++: void checkMagazine ( vector < string > magazine , vector < string > note ) { map < string , int > magazineFreq ; map < string , int > noteFreq ; for ( auto word = magazine . begin (); word != magazine . end (); word ++ ) { magazineFreq [ * word ] ++ ; } for ( auto word = note . begin (); word != note . end (); word ++ ) { noteFreq [ * word ] ++ ; } for ( auto entry = noteFreq . begin (); entry != noteFreq . end (); entry ++ ) { if ( entry -> second > magazineFreq [ entry -> first ]) { cout << \"No\" << endl ; return ; } } cout << \"Yes\" << endl ; } Python 3: def checkMagazine ( magazine , note ): magazine_freq = { word : 0 for word in magazine } note_freq = { word : 0 for word in note } for word in magazine : magazine_freq [ word ] += 1 for word in note : note_freq [ word ] += 1 for word , freq in note_freq . items (): if word not in magazine_freq or magazine_freq [ word ] < freq : print ( \"No\" ) return print ( \"Yes\" ) Back","title":"Hash Tables: Ransom Note"},{"location":"interviewprep/dicts/sherlockanagrams/","text":"Sherlock and Anagrams Problem Category: Dictionaries and Hashmaps Difficulty: Medium Given a string, determine how many pairs of substrings of the string are anagrams of each other. Input: a string \\(s\\) of lowercase English letters. \\[ 2 \\leq |s| \\leq 100 \\] Output: the number of anagrammatic pairs of substrings in the string. The substrings can overlap, and separate pairs can have substrings with the same content. For example, \"lolol\" has 12 anagrams: 3 pairs of \"l\" and \"l\" \"o\" and \"o\" 4 pairs of \"lo\" and \"ol\" \"lo\" and \"lo\" \"ol\" and \"ol\" \"lol\" and \"lol\" \"lolo\" and \"olol\" Two substrings can only be anagrams if they are the same length. For any \\(1 \\leq k < |s|\\) , there are \\(|s| - (k - 1)\\) substrings of length \\(k\\) . You will need to check every pair of \\(k\\) -length substrings for each \\(k\\) from 1 to \\(|s|\\) , making the total number of pairs to check: \\[ \\sum_{k=1}^{|s|} {|s| - (k - 1) \\choose 2} \\] We won't need to check every single pair of substrings, but we will need to at least look at every substring once. The number of substrings of \\(s\\) is: \\[ \\sum_{k=1}^{|s|} (|s| - (k - 1)) = {|s| \\choose 2} = \\frac{|s|(|s| + 1)}{2} \\] Note that \\({|s| \\choose 2}\\) is the number of ways to choose a start index and a stop index in \\(s\\) , and therefore the number of ways to choose a substring. There are a few ways to check if two strings are anagrams, but one way that is particularly useful for this problem is to sort the characters of each string and check if the strings become equal . The strings will become equal after sorting if and only if they are anagrams of each other. For each substring in \\(s\\) , sort the characters to get a sorted substring. Use a map to keep track of how many occurences of each sorted substring you find. If you find a sorted substring \\(n\\) times, then there are \\(n\\) substrings of \\(s\\) which sort to that sorted substring, and those \\(n\\) substrings are all anagrams of each other. That means that those \\(n\\) substrings account for \\({n \\choose 2} = \\frac{n(n + 1)}{2}\\) anagrammatic pairs. Java 8: public static int sherlockAndAnagrams ( String s ) { int anagrams = 0 ; Map < String , Integer > substringFreq = new HashMap <> (); for ( int i = 0 ; i < s . length (); i ++ ) { for ( int j = i + 1 ; j <= s . length (); j ++ ) { String sub = s . substring ( i , j ); sub = sortedString ( sub ); substringFreq . put ( sub , substringFreq . getOrDefault ( sub , 0 ) + 1 ); } } for ( String sub : substringFreq . keySet ()) { int count = substringFreq . get ( sub ); anagrams += count * ( count - 1 ) / 2 ; } return anagrams ; } private static String sortedString ( String s ) { char [] chars = s . toCharArray (); Arrays . sort ( chars ); return new String ( chars ); } C++: int sherlockAndAnagrams ( string s ) { map < string , int > substringFreq ; for ( int k = 1 ; k < s . size (); k ++ ) { for ( int i = 0 ; i <= s . size () - k ; i ++ ) { string sub = s . substr ( i , k ); sort ( sub . begin (), sub . end ()); substringFreq [ sub ] ++ ; } } int anagrams = 0 ; for ( auto sub = substringFreq . begin (); sub != substringFreq . end (); sub ++ ) { anagrams += sub -> second * ( sub -> second - 1 ) / 2 ; } return anagrams ; } Python 3: def sherlockAndAnagrams ( s ): freq = {} for i in range ( len ( s )): for j in range ( i + 1 , len ( s ) + 1 ): sub = \"\" . join ( sorted ( s [ i : j ])) freq [ sub ] = freq . get ( sub , 0 ) + 1 anagrams = 0 for val in freq . values (): anagrams += val * ( val - 1 ) // 2 return anagrams Back","title":"Sherlock and Anagrams"},{"location":"interviewprep/dicts/sherlockanagrams/#sherlock-and-anagrams","text":"Problem Category: Dictionaries and Hashmaps Difficulty: Medium Given a string, determine how many pairs of substrings of the string are anagrams of each other. Input: a string \\(s\\) of lowercase English letters. \\[ 2 \\leq |s| \\leq 100 \\] Output: the number of anagrammatic pairs of substrings in the string. The substrings can overlap, and separate pairs can have substrings with the same content. For example, \"lolol\" has 12 anagrams: 3 pairs of \"l\" and \"l\" \"o\" and \"o\" 4 pairs of \"lo\" and \"ol\" \"lo\" and \"lo\" \"ol\" and \"ol\" \"lol\" and \"lol\" \"lolo\" and \"olol\" Two substrings can only be anagrams if they are the same length. For any \\(1 \\leq k < |s|\\) , there are \\(|s| - (k - 1)\\) substrings of length \\(k\\) . You will need to check every pair of \\(k\\) -length substrings for each \\(k\\) from 1 to \\(|s|\\) , making the total number of pairs to check: \\[ \\sum_{k=1}^{|s|} {|s| - (k - 1) \\choose 2} \\] We won't need to check every single pair of substrings, but we will need to at least look at every substring once. The number of substrings of \\(s\\) is: \\[ \\sum_{k=1}^{|s|} (|s| - (k - 1)) = {|s| \\choose 2} = \\frac{|s|(|s| + 1)}{2} \\] Note that \\({|s| \\choose 2}\\) is the number of ways to choose a start index and a stop index in \\(s\\) , and therefore the number of ways to choose a substring. There are a few ways to check if two strings are anagrams, but one way that is particularly useful for this problem is to sort the characters of each string and check if the strings become equal . The strings will become equal after sorting if and only if they are anagrams of each other. For each substring in \\(s\\) , sort the characters to get a sorted substring. Use a map to keep track of how many occurences of each sorted substring you find. If you find a sorted substring \\(n\\) times, then there are \\(n\\) substrings of \\(s\\) which sort to that sorted substring, and those \\(n\\) substrings are all anagrams of each other. That means that those \\(n\\) substrings account for \\({n \\choose 2} = \\frac{n(n + 1)}{2}\\) anagrammatic pairs. Java 8: public static int sherlockAndAnagrams ( String s ) { int anagrams = 0 ; Map < String , Integer > substringFreq = new HashMap <> (); for ( int i = 0 ; i < s . length (); i ++ ) { for ( int j = i + 1 ; j <= s . length (); j ++ ) { String sub = s . substring ( i , j ); sub = sortedString ( sub ); substringFreq . put ( sub , substringFreq . getOrDefault ( sub , 0 ) + 1 ); } } for ( String sub : substringFreq . keySet ()) { int count = substringFreq . get ( sub ); anagrams += count * ( count - 1 ) / 2 ; } return anagrams ; } private static String sortedString ( String s ) { char [] chars = s . toCharArray (); Arrays . sort ( chars ); return new String ( chars ); } C++: int sherlockAndAnagrams ( string s ) { map < string , int > substringFreq ; for ( int k = 1 ; k < s . size (); k ++ ) { for ( int i = 0 ; i <= s . size () - k ; i ++ ) { string sub = s . substr ( i , k ); sort ( sub . begin (), sub . end ()); substringFreq [ sub ] ++ ; } } int anagrams = 0 ; for ( auto sub = substringFreq . begin (); sub != substringFreq . end (); sub ++ ) { anagrams += sub -> second * ( sub -> second - 1 ) / 2 ; } return anagrams ; } Python 3: def sherlockAndAnagrams ( s ): freq = {} for i in range ( len ( s )): for j in range ( i + 1 , len ( s ) + 1 ): sub = \"\" . join ( sorted ( s [ i : j ])) freq [ sub ] = freq . get ( sub , 0 ) + 1 anagrams = 0 for val in freq . values (): anagrams += val * ( val - 1 ) // 2 return anagrams Back","title":"Sherlock and Anagrams"},{"location":"interviewprep/dicts/twostrings/","text":"Two Strings Problem Category: Dictionaries and Hashmaps Difficulty: Easy Given two strings, determine if they share any common substring. Input: two strings \\(s_1\\) and \\(s_2\\) of lowercase English letters. \\[ 1 \\leq |s_1|, |s_2| \\leq 10^5 \\] Output: the string \"YES\" if there exists a non-empty string that is a substring of both \\(s_1\\) and \\(s_2\\) , otherwise the string \"NO\". If \\(s_1\\) and \\(s_2\\) have a common non-empty substring, then they share at least one letter in common. If \\(s_1\\) and \\(s_2\\) share a letter \\(c\\) in common, then they share the common substring \" \\(c\\) \" and the answer is Yes. Therefore, the answer is Yes if and only if \\(s_1\\) and \\(s_2\\) have at least one letter in common. We need to find one letter that is in both \\(s_1\\) and \\(s_2\\) to determine the answer is Yes, and if the strings have no letters in common, the answer is No. This is the condition we are trying to check: \\[ \\{c : c \\in s_1\\} \\cap \\{c : c \\in s_2\\} \\neq \\emptyset \\] There are a few ways to do this. You can make separate sets with the characters of \\(s_1\\) and \\(s_2\\) and calculate the intersection. You can make a set for \\(s_1\\) and then check whether it contains any character of \\(s_2\\) . You can also make a combined set for \\(s_1\\) and \\(s_2\\) and check for independence: \\[ |\\{c : c \\in s_1\\} \\cup \\{c : c \\in s_2\\}| = |\\{c : c \\in s_1\\}| + |\\{c : c \\in s_2\\}| \\] If the sets are independent, then the answer is No. Java 8: public static String twoStrings ( String s1 , String s2 ) { Set < Character > s1set = new HashSet <> (); for ( int i = 0 ; i < s1 . length (); i ++ ) { s1set . add ( s1 . charAt ( i )); } for ( int i = 0 ; i < s2 . length (); i ++ ) { if ( s1set . contains ( s2 . charAt ( i ))) { return \"YES\" ; } } return \"NO\" ; } C++: string twoStrings ( string s1 , string s2 ) { set < char > s1set ; for ( auto ch = s1 . begin (); ch != s1 . end (); ch ++ ) { s1set . insert ( * ch ); } for ( auto ch = s2 . begin (); ch != s2 . end (); ch ++ ) { if ( s1set . find ( * ch ) != s1set . end ()) { return \"YES\" ; } } return \"NO\" ; } Python 3: def twoStrings ( s1 , s2 ): return \"YES\" if set ( s1 ) & set ( s2 ) else \"NO\" Back","title":"Two Strings"},{"location":"interviewprep/dicts/twostrings/#two-strings","text":"Problem Category: Dictionaries and Hashmaps Difficulty: Easy Given two strings, determine if they share any common substring. Input: two strings \\(s_1\\) and \\(s_2\\) of lowercase English letters. \\[ 1 \\leq |s_1|, |s_2| \\leq 10^5 \\] Output: the string \"YES\" if there exists a non-empty string that is a substring of both \\(s_1\\) and \\(s_2\\) , otherwise the string \"NO\". If \\(s_1\\) and \\(s_2\\) have a common non-empty substring, then they share at least one letter in common. If \\(s_1\\) and \\(s_2\\) share a letter \\(c\\) in common, then they share the common substring \" \\(c\\) \" and the answer is Yes. Therefore, the answer is Yes if and only if \\(s_1\\) and \\(s_2\\) have at least one letter in common. We need to find one letter that is in both \\(s_1\\) and \\(s_2\\) to determine the answer is Yes, and if the strings have no letters in common, the answer is No. This is the condition we are trying to check: \\[ \\{c : c \\in s_1\\} \\cap \\{c : c \\in s_2\\} \\neq \\emptyset \\] There are a few ways to do this. You can make separate sets with the characters of \\(s_1\\) and \\(s_2\\) and calculate the intersection. You can make a set for \\(s_1\\) and then check whether it contains any character of \\(s_2\\) . You can also make a combined set for \\(s_1\\) and \\(s_2\\) and check for independence: \\[ |\\{c : c \\in s_1\\} \\cup \\{c : c \\in s_2\\}| = |\\{c : c \\in s_1\\}| + |\\{c : c \\in s_2\\}| \\] If the sets are independent, then the answer is No. Java 8: public static String twoStrings ( String s1 , String s2 ) { Set < Character > s1set = new HashSet <> (); for ( int i = 0 ; i < s1 . length (); i ++ ) { s1set . add ( s1 . charAt ( i )); } for ( int i = 0 ; i < s2 . length (); i ++ ) { if ( s1set . contains ( s2 . charAt ( i ))) { return \"YES\" ; } } return \"NO\" ; } C++: string twoStrings ( string s1 , string s2 ) { set < char > s1set ; for ( auto ch = s1 . begin (); ch != s1 . end (); ch ++ ) { s1set . insert ( * ch ); } for ( auto ch = s2 . begin (); ch != s2 . end (); ch ++ ) { if ( s1set . find ( * ch ) != s1set . end ()) { return \"YES\" ; } } return \"NO\" ; } Python 3: def twoStrings ( s1 , s2 ): return \"YES\" if set ( s1 ) & set ( s2 ) else \"NO\" Back","title":"Two Strings"},{"location":"interviewprep/dynamicprogramming/abbreviation/","text":"Abbreviation Problem Category: Dynamic Programming Difficulty: Medium Given two strings, determine if it is possible to make the first string equal to the second one by only deleting lowercase letters from it. Input: two strings \\(a\\) and \\(b\\) . \\(a\\) can have lowercase or uppercase letters, but \\(b\\) only has uppercase letters. \\[ 1 \\leq |a|, |b| \\leq 1000 \\] Output: the string \"YES\" if \\(a\\) can be made equal to \\(b\\) by, for each lowercase letter in \\(a\\) , either making it uppercase or deleting it. You can think of \\(a\\) 's lowercase letters as the letters we are allowed to remove, and its uppercase letters as the letters we are not allowed to remove. Note that we can't add any letters to \\(a\\) : if \\(a\\) is shorter than \\(b\\) , the answer must be No. If any letters in \\(b\\) aren't in \\(a\\) , the answer is No. If any uppercase letters in \\(a\\) aren't in \\(b\\) , the answer is No because we can't remove them. The challenge is that you need to determine whether it is possible to get \\(b\\) from \\(a\\) by capitalizing any number of lowercase letters and deleting the rest. Passing over \\(a\\) , it is hard to decide greedily for each lowercase letter whether to capitalize or remove it. Let \\(m = |a|\\) and \\(n = |b|\\) , and let \\(A_{0,0} \\ldots A_{m,n}\\) be an \\((m + 1) \\times (n + 1)\\) 0-1 matrix. \\(A_{i,j}\\) will be 1 if the answer is Yes when we consider only the first \\(i\\) letters of \\(a\\) and the first \\(j\\) letters of \\(b\\) , otherwise it will be 0. If \\(a\\) and \\(b\\) are both empty, they are already equal, so \\(A_{0,0} = 1\\) . If the first \\(i\\) letters of \\(a\\) are lowercase, then the first \\(i\\) values in column 0 below \\(A_{0,0}\\) are 1, and the remaining values are 0, because once \\(a\\) has an uppercase letter, it cannot match the empty string. \\(A_{0,j}\\) is going to be 0 for all \\(j > 0\\) (in general, \\(A_{i,j} = 0\\) for all \\(i < j\\) ). For \\(A_{i,j}\\) , let \\(a_i\\) be the \\(i^\\text{th}\\) letter of \\(a\\) , and let \\(b_j\\) be the \\(j^\\text{th}\\) letter of \\(b\\) . If \\(a_i\\) is lowercase, we have the option of deleting \\(a_i\\) and taking \\(A_{i,j} = 1\\) if \\(A_{i-1,j} = 1\\) . We also have the option of making \\(a_i\\) uppercase. In this case, or if it was uppercase to begin with, we need \\(a_i = b_j\\) and \\(A_{i-1,j-1} = 1\\) to hold. Therefore, \\(A_{i,j}\\) indicates the following event: \\[ (\\{a_i \\in [\\text{a-z}]\\} \\cap \\{A_{i-1,j} = 1\\}) \\cup (\\{\\left\\lceil a_i\\right\\rceil = b_j\\} \\cap \\{A_{i-1,j-1} = 1\\}) \\] where \\(\\left\\lceil a_i\\right\\rceil\\) denotes \\(a_i\\) capitalized. This lends itself to a dynamic programming algorithm that computes \\(A_{0,0}\\) through \\(A_{m,n}\\) , where the answer is Yes if \\(A_{m,n} = 1\\) , otherwise No. Java 8: public static String abbreviation ( String a , String b ) { int m = a . length (); int n = b . length (); boolean [][] dp = new boolean [ m + 1 ][ n + 1 ] ; dp [ 0 ][ 0 ] = true ; for ( int i = 1 ; i <= m ; i ++ ) { char ch1 = a . charAt ( i - 1 ); if ( Character . isLowerCase ( ch1 )) { dp [ i ][ 0 ] = dp [ i - 1 ][ 0 ] ; } for ( int j = 1 ; j <= n ; j ++ ) { char ch2 = b . charAt ( j - 1 ); dp [ i ][ j ] = Character . toUpperCase ( ch1 ) == ch2 && dp [ i - 1 ][ j - 1 ] || dp [ i - 1 ][ j ] && Character . isLowerCase ( ch1 ); } } return dp [ m ][ n ] ? \"YES\" : \"NO\" ; } C++: string abbreviation ( string a , string b ) { int m = a . size (); int n = b . size (); vector < vector < bool >> dp ; for ( int i = 0 ; i <= m ; i ++ ) { dp . emplace_back ( n + 1 ); } dp [ 0 ][ 0 ] = true ; for ( int i = 1 ; i <= m ; i ++ ) { if ( islower ( a [ i - 1 ])) { dp [ i ][ 0 ] = dp [ i - 1 ][ 0 ]; } for ( int j = 1 ; j <= n ; j ++ ) { dp [ i ][ j ] = toupper ( a [ i - 1 ]) == b [ j - 1 ] && dp [ i - 1 ][ j - 1 ] || dp [ i - 1 ][ j ] && islower ( a [ i - 1 ]); } } return dp [ m ][ n ] ? \"YES\" : \"NO\" ; } Python 3: def abbreviation ( a , b ): m , n = len ( a ), len ( b ) dp = [[ False for _ in range ( n + 1 )] for _ in range ( m + 1 )] dp [ 0 ][ 0 ] = True for i , ch1 in enumerate ( a ): if ch1 . islower (): dp [ i + 1 ][ 0 ] = dp [ i ][ 0 ] for j , ch2 in enumerate ( b ): dp [ i + 1 ][ j + 1 ] = ( ch1 . upper () == ch2 and dp [ i ][ j ] or ch1 . islower () and dp [ i ][ j + 1 ] ) return \"YES\" if dp [ - 1 ][ - 1 ] else \"NO\" Back","title":"Abbreviation"},{"location":"interviewprep/dynamicprogramming/abbreviation/#abbreviation","text":"Problem Category: Dynamic Programming Difficulty: Medium Given two strings, determine if it is possible to make the first string equal to the second one by only deleting lowercase letters from it. Input: two strings \\(a\\) and \\(b\\) . \\(a\\) can have lowercase or uppercase letters, but \\(b\\) only has uppercase letters. \\[ 1 \\leq |a|, |b| \\leq 1000 \\] Output: the string \"YES\" if \\(a\\) can be made equal to \\(b\\) by, for each lowercase letter in \\(a\\) , either making it uppercase or deleting it. You can think of \\(a\\) 's lowercase letters as the letters we are allowed to remove, and its uppercase letters as the letters we are not allowed to remove. Note that we can't add any letters to \\(a\\) : if \\(a\\) is shorter than \\(b\\) , the answer must be No. If any letters in \\(b\\) aren't in \\(a\\) , the answer is No. If any uppercase letters in \\(a\\) aren't in \\(b\\) , the answer is No because we can't remove them. The challenge is that you need to determine whether it is possible to get \\(b\\) from \\(a\\) by capitalizing any number of lowercase letters and deleting the rest. Passing over \\(a\\) , it is hard to decide greedily for each lowercase letter whether to capitalize or remove it. Let \\(m = |a|\\) and \\(n = |b|\\) , and let \\(A_{0,0} \\ldots A_{m,n}\\) be an \\((m + 1) \\times (n + 1)\\) 0-1 matrix. \\(A_{i,j}\\) will be 1 if the answer is Yes when we consider only the first \\(i\\) letters of \\(a\\) and the first \\(j\\) letters of \\(b\\) , otherwise it will be 0. If \\(a\\) and \\(b\\) are both empty, they are already equal, so \\(A_{0,0} = 1\\) . If the first \\(i\\) letters of \\(a\\) are lowercase, then the first \\(i\\) values in column 0 below \\(A_{0,0}\\) are 1, and the remaining values are 0, because once \\(a\\) has an uppercase letter, it cannot match the empty string. \\(A_{0,j}\\) is going to be 0 for all \\(j > 0\\) (in general, \\(A_{i,j} = 0\\) for all \\(i < j\\) ). For \\(A_{i,j}\\) , let \\(a_i\\) be the \\(i^\\text{th}\\) letter of \\(a\\) , and let \\(b_j\\) be the \\(j^\\text{th}\\) letter of \\(b\\) . If \\(a_i\\) is lowercase, we have the option of deleting \\(a_i\\) and taking \\(A_{i,j} = 1\\) if \\(A_{i-1,j} = 1\\) . We also have the option of making \\(a_i\\) uppercase. In this case, or if it was uppercase to begin with, we need \\(a_i = b_j\\) and \\(A_{i-1,j-1} = 1\\) to hold. Therefore, \\(A_{i,j}\\) indicates the following event: \\[ (\\{a_i \\in [\\text{a-z}]\\} \\cap \\{A_{i-1,j} = 1\\}) \\cup (\\{\\left\\lceil a_i\\right\\rceil = b_j\\} \\cap \\{A_{i-1,j-1} = 1\\}) \\] where \\(\\left\\lceil a_i\\right\\rceil\\) denotes \\(a_i\\) capitalized. This lends itself to a dynamic programming algorithm that computes \\(A_{0,0}\\) through \\(A_{m,n}\\) , where the answer is Yes if \\(A_{m,n} = 1\\) , otherwise No. Java 8: public static String abbreviation ( String a , String b ) { int m = a . length (); int n = b . length (); boolean [][] dp = new boolean [ m + 1 ][ n + 1 ] ; dp [ 0 ][ 0 ] = true ; for ( int i = 1 ; i <= m ; i ++ ) { char ch1 = a . charAt ( i - 1 ); if ( Character . isLowerCase ( ch1 )) { dp [ i ][ 0 ] = dp [ i - 1 ][ 0 ] ; } for ( int j = 1 ; j <= n ; j ++ ) { char ch2 = b . charAt ( j - 1 ); dp [ i ][ j ] = Character . toUpperCase ( ch1 ) == ch2 && dp [ i - 1 ][ j - 1 ] || dp [ i - 1 ][ j ] && Character . isLowerCase ( ch1 ); } } return dp [ m ][ n ] ? \"YES\" : \"NO\" ; } C++: string abbreviation ( string a , string b ) { int m = a . size (); int n = b . size (); vector < vector < bool >> dp ; for ( int i = 0 ; i <= m ; i ++ ) { dp . emplace_back ( n + 1 ); } dp [ 0 ][ 0 ] = true ; for ( int i = 1 ; i <= m ; i ++ ) { if ( islower ( a [ i - 1 ])) { dp [ i ][ 0 ] = dp [ i - 1 ][ 0 ]; } for ( int j = 1 ; j <= n ; j ++ ) { dp [ i ][ j ] = toupper ( a [ i - 1 ]) == b [ j - 1 ] && dp [ i - 1 ][ j - 1 ] || dp [ i - 1 ][ j ] && islower ( a [ i - 1 ]); } } return dp [ m ][ n ] ? \"YES\" : \"NO\" ; } Python 3: def abbreviation ( a , b ): m , n = len ( a ), len ( b ) dp = [[ False for _ in range ( n + 1 )] for _ in range ( m + 1 )] dp [ 0 ][ 0 ] = True for i , ch1 in enumerate ( a ): if ch1 . islower (): dp [ i + 1 ][ 0 ] = dp [ i ][ 0 ] for j , ch2 in enumerate ( b ): dp [ i + 1 ][ j + 1 ] = ( ch1 . upper () == ch2 and dp [ i ][ j ] or ch1 . islower () and dp [ i ][ j + 1 ] ) return \"YES\" if dp [ - 1 ][ - 1 ] else \"NO\" Back","title":"Abbreviation"},{"location":"interviewprep/dynamicprogramming/maxarraysum/","text":"Max Array Sum Problem Category: Dynamic Programming Difficulty: Medium Given an array of integers, find the maximum sum that can be achieved by taking a subset of non-adjacent values. Input: an array of integers \\(a[n]\\) . \\[ 1 \\leq n \\leq 10^5 \\] \\[ \\left|a[i]\\right| \\leq 10^4 \\; \\; \\forall \\; i \\] Output: the maximum sum that can be achieved by taking a subset of elements that cannot be adjacent in \\(a\\) . For example, if \\(a\\) is [1, 2, 3, 4, 5] , we can take [1, 3] , [2, 4] , [1, 3, 5] , [1, 4] , and so on, but not [1, 2] . In this case, the greatest sum is 9, which we achieve by taking [1, 3, 5] . Note that the integers can be positive or negative. We should never take a nonpositive element into our subset because it can't increase the value of our sum and it only prevents us from taking the values adjacent to it. If all of the values were nonpositive, the answer would be 0 because it would be optimal to take none of them. Some simple cases are when \\(n = 1\\) , where we should take \\(a[0]\\) only if it is positive, and the answer is \\(\\max(a[0], \\; 0)\\) . If \\(n = 2\\) : we can't take both \\(a[0]\\) and \\(a[1]\\) , so we have to choose one or the other or neither, and the answer is \\(\\max(a[0], \\; a[1], \\; 0)\\) . For \\(n > 2\\) , we can't build an optimal subset greedily and there are too many subsets to check, but we can use dynamic programming. Let \\(d[i]\\) represent the max array sum using only the first \\(i\\) elements of \\(a\\) (we will use zero-based indexing, so rather it is the first \\(i + 1\\) elements, up to index \\(i\\) ). We can initialize \\(d[0]\\) and \\(d[1]\\) as in the simple cases above: \\[ \\begin{align*} d[0] & \\gets \\max(a[0], \\; 0) \\\\ d[1] & \\gets \\max(a[1], \\; d[0]) \\end{align*} \\] For \\(i = 2, 3, \\ldots n - 1\\) , we should choose whether or not to take \\(a[i]\\) into our subset. If we take \\(a[i]\\) , we can't take \\(a[i - 1]\\) , but we can take any elements before it, so our subset sum is \\(d[i - 2] + a[i]\\) . Otherwise, if we don't take \\(a[i]\\) , we can take anything before it, and our subset sum is \\(d[i - 1]\\) . \\[ d[i] \\gets \\left\\{ \\begin{array}{ll} \\max(a[0], \\; 0) & i = 0 \\\\ \\max(a[1], \\; d[0]) & i = 1 \\\\ \\max(d[i - 2] + a[i], \\; d[i - 1]) & 1 < i < n \\end{array} \\right. \\] The answer is \\(d[n - 1]\\) , the max array sum that considers all elements of \\(a\\) . Java 8: static int maxSubsetSum ( int [] arr ) { int n = arr . length ; int [] sums = new int [ n ] ; sums [ 0 ] = Math . max ( arr [ 0 ] , 0 ); if ( n > 1 ) { sums [ 1 ] = Math . max ( sums [ 0 ] , arr [ 1 ] ); } for ( int i = 2 ; i < n ; i ++ ) { sums [ i ] = Math . max ( sums [ i - 2 ] + arr [ i ] , sums [ i - 1 ] ); } return sums [ n - 1 ] ; } C++: int maxSubsetSum ( vector < int > arr ) { int n = arr . size (); vector < int > sums ( n ); sums [ 0 ] = max ( arr [ 0 ], 0 ); if ( n > 1 ) { sums [ 1 ] = max ( sums [ 0 ], arr [ 1 ]); } for ( int i = 2 ; i < n ; i ++ ) { sums [ i ] = max ( sums [ i - 2 ] + arr [ i ], sums [ i - 1 ]); } return sums [ n - 1 ]; } Python 3: def maxSubsetSum ( arr ): sums = [ max ( arr [ 0 ], 0 )] if len ( arr ) > 1 : sums . append ( max ( arr [ 1 ], sums [ - 1 ])) for val in arr [ 2 :]: sums . append ( max ( sums [ - 2 ] + val , sums [ - 1 ])) return sums [ - 1 ] Back","title":"Max Array Sum"},{"location":"interviewprep/dynamicprogramming/maxarraysum/#max-array-sum","text":"Problem Category: Dynamic Programming Difficulty: Medium Given an array of integers, find the maximum sum that can be achieved by taking a subset of non-adjacent values. Input: an array of integers \\(a[n]\\) . \\[ 1 \\leq n \\leq 10^5 \\] \\[ \\left|a[i]\\right| \\leq 10^4 \\; \\; \\forall \\; i \\] Output: the maximum sum that can be achieved by taking a subset of elements that cannot be adjacent in \\(a\\) . For example, if \\(a\\) is [1, 2, 3, 4, 5] , we can take [1, 3] , [2, 4] , [1, 3, 5] , [1, 4] , and so on, but not [1, 2] . In this case, the greatest sum is 9, which we achieve by taking [1, 3, 5] . Note that the integers can be positive or negative. We should never take a nonpositive element into our subset because it can't increase the value of our sum and it only prevents us from taking the values adjacent to it. If all of the values were nonpositive, the answer would be 0 because it would be optimal to take none of them. Some simple cases are when \\(n = 1\\) , where we should take \\(a[0]\\) only if it is positive, and the answer is \\(\\max(a[0], \\; 0)\\) . If \\(n = 2\\) : we can't take both \\(a[0]\\) and \\(a[1]\\) , so we have to choose one or the other or neither, and the answer is \\(\\max(a[0], \\; a[1], \\; 0)\\) . For \\(n > 2\\) , we can't build an optimal subset greedily and there are too many subsets to check, but we can use dynamic programming. Let \\(d[i]\\) represent the max array sum using only the first \\(i\\) elements of \\(a\\) (we will use zero-based indexing, so rather it is the first \\(i + 1\\) elements, up to index \\(i\\) ). We can initialize \\(d[0]\\) and \\(d[1]\\) as in the simple cases above: \\[ \\begin{align*} d[0] & \\gets \\max(a[0], \\; 0) \\\\ d[1] & \\gets \\max(a[1], \\; d[0]) \\end{align*} \\] For \\(i = 2, 3, \\ldots n - 1\\) , we should choose whether or not to take \\(a[i]\\) into our subset. If we take \\(a[i]\\) , we can't take \\(a[i - 1]\\) , but we can take any elements before it, so our subset sum is \\(d[i - 2] + a[i]\\) . Otherwise, if we don't take \\(a[i]\\) , we can take anything before it, and our subset sum is \\(d[i - 1]\\) . \\[ d[i] \\gets \\left\\{ \\begin{array}{ll} \\max(a[0], \\; 0) & i = 0 \\\\ \\max(a[1], \\; d[0]) & i = 1 \\\\ \\max(d[i - 2] + a[i], \\; d[i - 1]) & 1 < i < n \\end{array} \\right. \\] The answer is \\(d[n - 1]\\) , the max array sum that considers all elements of \\(a\\) . Java 8: static int maxSubsetSum ( int [] arr ) { int n = arr . length ; int [] sums = new int [ n ] ; sums [ 0 ] = Math . max ( arr [ 0 ] , 0 ); if ( n > 1 ) { sums [ 1 ] = Math . max ( sums [ 0 ] , arr [ 1 ] ); } for ( int i = 2 ; i < n ; i ++ ) { sums [ i ] = Math . max ( sums [ i - 2 ] + arr [ i ] , sums [ i - 1 ] ); } return sums [ n - 1 ] ; } C++: int maxSubsetSum ( vector < int > arr ) { int n = arr . size (); vector < int > sums ( n ); sums [ 0 ] = max ( arr [ 0 ], 0 ); if ( n > 1 ) { sums [ 1 ] = max ( sums [ 0 ], arr [ 1 ]); } for ( int i = 2 ; i < n ; i ++ ) { sums [ i ] = max ( sums [ i - 2 ] + arr [ i ], sums [ i - 1 ]); } return sums [ n - 1 ]; } Python 3: def maxSubsetSum ( arr ): sums = [ max ( arr [ 0 ], 0 )] if len ( arr ) > 1 : sums . append ( max ( arr [ 1 ], sums [ - 1 ])) for val in arr [ 2 :]: sums . append ( max ( sums [ - 2 ] + val , sums [ - 1 ])) return sums [ - 1 ] Back","title":"Max Array Sum"},{"location":"interviewprep/greedyalgorithms/greedyflorist/","text":"Greedy Florist Problem Category: Greedy Algorithms Difficulty: Medium Given a list of flower prices and a number of customers, determine the minimum possible cost of buying every flower. Input: an array \\(c[n]\\) of the cost of each flower, and \\(k\\) , the number of customers in the group. \\[ 1 \\leq n, k \\leq 100 \\] \\[ 1 \\leq c[i] \\leq 10^6 \\; \\; \\forall \\; i \\] Output: the minimum possible cost of buying every flower. Each customer can buy any number of the flowers in any order. The catch is that for each purchase, the florist multiplies the price by 1 plus the number of flowers that customer has already bought. If a customer first buys flower \\(i\\) , it costs \\(c[i]\\) , and if they next buy flower \\(j\\) , it costs \\(2c[j]\\) , then the next cost is multiplied by 3, and so on. The group has to buy all \\(n\\) flowers in the list, so we have to incur every price. In general, the more expensive a flower is, the lower we want the multiplier to be when we purchase it. Therefore, it makes sense to buy the most expensive flowers first when the multiplier is low, and save the cheapest flowers for when the multiplier is highest. Also, we should try to distribute the flower purchases as evenly as possible among the customers. For example, it would never be optimal to have one customer buy three flowers while another only buys one flower. That third flower \\(i\\) costs \\(3c[i]\\) for the first customer, but it would only cost \\(2c[i]\\) if the other customer bought it instead. Here is the greedy strategy: the \\(k\\) customers each buy the most expensive flower available, getting the \\(k\\) most expensive flowers with multiplier 1. Then, they repeat, buying the next \\(k\\) most expensive flowers with multiplier 2. They repeat until there are no more flowers left to buy. Think of the multipler as the number of times the customer has to buy that flower. We want to buy the most expensive flowers as few times as possible, and we should save the cheapest flowers for when we have to buy many of them. Here's a quick exchange argument for why this is always optimal: suppose an optimal solution differs from ours, such that for some flower \\(i\\) that we bought with multiplier \\(k\\) , the optimal solution buys \\(i\\) later with a higher multiplier \\(\\ell > k\\) , and instead buys some other flower \\(j\\) with multiplier \\(k\\) . If our algorithm picked \\(i\\) instead of \\(j\\) to buy with multiplier \\(k\\) , it must be the case that \\[ \\begin{align*} c[j] & \\leq c[i] \\\\ (\\ell - k)c[j] & \\leq (\\ell - k)c[i] \\\\ \\ell c[j] - k c[j] & \\leq \\ell c[i] - k c[i] \\\\ k c[i] + \\ell c[j] & \\leq \\ell c[i] + k c[j] \\end{align*} \\] using \\(\\ell - k > 0\\) . Therefore, if you were to swap \\(i\\) and \\(j\\) in the optimal solution to purchase \\(i\\) with multiplier \\(k\\) (like our algorithm does) and \\(j\\) with multiplier \\(\\ell\\) , it would not increase the total cost. You could continuously swap flowers like this for every point at which the optimal solution chooses differently from ours, and the cost would never increase. Therefore, our algorithm's solution must be an optimal solution. Java 8: static int getMinimumCost ( int k , int [] c ) { c = Arrays . copyOf ( c , c . length ); Arrays . sort ( c ); int multiplier = 1 ; int cost = 0 ; int customers = k ; int index = c . length - 1 ; while ( index >= 0 ) { if ( customers == 0 ) { customers = k ; multiplier ++ ; } cost += c [ index ] * multiplier ; customers -- ; index -- ; } return cost ; } C++: int getMinimumCost ( int k , vector < int > c ) { vector < int > prices = c ; sort ( prices . begin (), prices . end ()); reverse ( prices . begin (), prices . end ()); int multiplier = 1 ; int totalCost = 0 ; int customers = k ; for ( auto price = prices . begin (); price != prices . end (); price ++ ) { if ( ! customers ) { customers = k ; multiplier ++ ; } totalCost += * price * multiplier ; customers -- ; } return totalCost ; } Python 3: def getMinimumCost ( k , c ): cost = 0 multiplier = 1 customers = k for price in sorted ( c , reverse = True ): if not customers : customers = k multiplier += 1 cost += price * multiplier customers -= 1 return cost Back","title":"Greedy Florist"},{"location":"interviewprep/greedyalgorithms/greedyflorist/#greedy-florist","text":"Problem Category: Greedy Algorithms Difficulty: Medium Given a list of flower prices and a number of customers, determine the minimum possible cost of buying every flower. Input: an array \\(c[n]\\) of the cost of each flower, and \\(k\\) , the number of customers in the group. \\[ 1 \\leq n, k \\leq 100 \\] \\[ 1 \\leq c[i] \\leq 10^6 \\; \\; \\forall \\; i \\] Output: the minimum possible cost of buying every flower. Each customer can buy any number of the flowers in any order. The catch is that for each purchase, the florist multiplies the price by 1 plus the number of flowers that customer has already bought. If a customer first buys flower \\(i\\) , it costs \\(c[i]\\) , and if they next buy flower \\(j\\) , it costs \\(2c[j]\\) , then the next cost is multiplied by 3, and so on. The group has to buy all \\(n\\) flowers in the list, so we have to incur every price. In general, the more expensive a flower is, the lower we want the multiplier to be when we purchase it. Therefore, it makes sense to buy the most expensive flowers first when the multiplier is low, and save the cheapest flowers for when the multiplier is highest. Also, we should try to distribute the flower purchases as evenly as possible among the customers. For example, it would never be optimal to have one customer buy three flowers while another only buys one flower. That third flower \\(i\\) costs \\(3c[i]\\) for the first customer, but it would only cost \\(2c[i]\\) if the other customer bought it instead. Here is the greedy strategy: the \\(k\\) customers each buy the most expensive flower available, getting the \\(k\\) most expensive flowers with multiplier 1. Then, they repeat, buying the next \\(k\\) most expensive flowers with multiplier 2. They repeat until there are no more flowers left to buy. Think of the multipler as the number of times the customer has to buy that flower. We want to buy the most expensive flowers as few times as possible, and we should save the cheapest flowers for when we have to buy many of them. Here's a quick exchange argument for why this is always optimal: suppose an optimal solution differs from ours, such that for some flower \\(i\\) that we bought with multiplier \\(k\\) , the optimal solution buys \\(i\\) later with a higher multiplier \\(\\ell > k\\) , and instead buys some other flower \\(j\\) with multiplier \\(k\\) . If our algorithm picked \\(i\\) instead of \\(j\\) to buy with multiplier \\(k\\) , it must be the case that \\[ \\begin{align*} c[j] & \\leq c[i] \\\\ (\\ell - k)c[j] & \\leq (\\ell - k)c[i] \\\\ \\ell c[j] - k c[j] & \\leq \\ell c[i] - k c[i] \\\\ k c[i] + \\ell c[j] & \\leq \\ell c[i] + k c[j] \\end{align*} \\] using \\(\\ell - k > 0\\) . Therefore, if you were to swap \\(i\\) and \\(j\\) in the optimal solution to purchase \\(i\\) with multiplier \\(k\\) (like our algorithm does) and \\(j\\) with multiplier \\(\\ell\\) , it would not increase the total cost. You could continuously swap flowers like this for every point at which the optimal solution chooses differently from ours, and the cost would never increase. Therefore, our algorithm's solution must be an optimal solution. Java 8: static int getMinimumCost ( int k , int [] c ) { c = Arrays . copyOf ( c , c . length ); Arrays . sort ( c ); int multiplier = 1 ; int cost = 0 ; int customers = k ; int index = c . length - 1 ; while ( index >= 0 ) { if ( customers == 0 ) { customers = k ; multiplier ++ ; } cost += c [ index ] * multiplier ; customers -- ; index -- ; } return cost ; } C++: int getMinimumCost ( int k , vector < int > c ) { vector < int > prices = c ; sort ( prices . begin (), prices . end ()); reverse ( prices . begin (), prices . end ()); int multiplier = 1 ; int totalCost = 0 ; int customers = k ; for ( auto price = prices . begin (); price != prices . end (); price ++ ) { if ( ! customers ) { customers = k ; multiplier ++ ; } totalCost += * price * multiplier ; customers -- ; } return totalCost ; } Python 3: def getMinimumCost ( k , c ): cost = 0 multiplier = 1 customers = k for price in sorted ( c , reverse = True ): if not customers : customers = k multiplier += 1 cost += price * multiplier customers -= 1 return cost Back","title":"Greedy Florist"},{"location":"interviewprep/greedyalgorithms/luckbalance/","text":"Luck Balance Problem Category: Greedy Algorithms Difficulty: Easy Given a list of contests with \"luck\" values, which are either important or unimportant, and a maximum number of important contests that can be lost, determine the maximum possible amount of \"stored luck\" after all contests. Input: two arrays \\(L[n]\\) and \\(T[n]\\) , and \\(k\\) , the maximum number of important contests that can be lost. \\(L[i]\\) is the luck value of contest \\(i\\) , and \\(T[i] = 1\\) if contest \\(i\\) is important, else \\(T[i] = 0\\) . \\[ 1 \\leq k \\leq n \\leq 100 \\] \\[ 1 \\leq L[i] \\leq 10^4 \\; \\forall \\; i \\] Output: the maximum amount of stored luck attainable after all contests. Luck starts at 0, and winning contest \\(i\\) decreases luck by \\(L[i]\\) , while losing contest \\(i\\) increases luck by \\(L[i]\\) . The idea behind \"saving luck\" is that the more you lose, the greater your chance of winning becomes in the future, and the more you win, the greater your chance of losing becomes in the future. A contest \\(i\\) with a high luck value \\(L[i]\\) costs a lot of luck to win. The first observation to make is that the constraint is that we can lose no more than \\(k\\) important contests, but there is no limit to the number of unimportant contests we can lose. Every contest has a positive luck value, so we should lose every unimportant contest. For important contests, we should lose as many as we are allowed, and we should choose the contests with the largest luck values to lose. Make a list of the luck values for important contests and sort it. Add up to \\(k\\) of the largest values to your overall luck value and subtract any remaining values. Note that if you can lose at most \\(k\\) contests, then you must win at least \\(m.\\text{length} - k\\) important contests, where \\(m\\) is the array of important contests. If \\(k \\geq m.\\text{length}\\) , then you may lose every important contest. You can either start from the highest values and choose \\(k\\) contests to lose, or you can start from the lowest values and choose \\(m.\\text{length} - k\\) contests to win. Java 8: public static int luckBalance ( int k , List < List < Integer >> contests ) { int luck = 0 ; List < Integer > important = new ArrayList <> (); for ( List < Integer > contest : contests ) { final int L = contest . get ( 0 ); final int T = contest . get ( 1 ); if ( T == 1 ) { important . add ( L ); } else { luck += L ; } } Collections . sort ( important ); int requiredWins = important . size () - k ; for ( int l : important ) { if ( requiredWins > 0 ) { luck -= l ; requiredWins -- ; } else { luck += l ; } } return luck ; } C++: int luckBalance ( int k , vector < vector < int >> contests ) { vector < int > important ; int luck = 0 ; for ( auto contest = contests . begin (); contest != contests . end (); contest ++ ) { const int L = contest -> front (); const int T = contest -> back (); if ( T ) { important . push_back ( L ); } else { luck += L ; } } sort ( important . begin (), important . end ()); for ( auto l = important . rbegin (); l != important . rend (); l ++ ) { if ( k ) { luck += * l ; k -- ; } else { luck -= * l ; } } return luck ; } Python 3: def luckBalance ( k , contests ): important = [ contest [ 0 ] for contest in contests if contest [ - 1 ]] important . sort ( reverse = True ) luck = sum ( contest [ 0 ] for contest in contests if not contest [ - 1 ]) for l in important : if k : luck += l k -= 1 else : luck -= l return luck Back","title":"Luck Balance"},{"location":"interviewprep/greedyalgorithms/luckbalance/#luck-balance","text":"Problem Category: Greedy Algorithms Difficulty: Easy Given a list of contests with \"luck\" values, which are either important or unimportant, and a maximum number of important contests that can be lost, determine the maximum possible amount of \"stored luck\" after all contests. Input: two arrays \\(L[n]\\) and \\(T[n]\\) , and \\(k\\) , the maximum number of important contests that can be lost. \\(L[i]\\) is the luck value of contest \\(i\\) , and \\(T[i] = 1\\) if contest \\(i\\) is important, else \\(T[i] = 0\\) . \\[ 1 \\leq k \\leq n \\leq 100 \\] \\[ 1 \\leq L[i] \\leq 10^4 \\; \\forall \\; i \\] Output: the maximum amount of stored luck attainable after all contests. Luck starts at 0, and winning contest \\(i\\) decreases luck by \\(L[i]\\) , while losing contest \\(i\\) increases luck by \\(L[i]\\) . The idea behind \"saving luck\" is that the more you lose, the greater your chance of winning becomes in the future, and the more you win, the greater your chance of losing becomes in the future. A contest \\(i\\) with a high luck value \\(L[i]\\) costs a lot of luck to win. The first observation to make is that the constraint is that we can lose no more than \\(k\\) important contests, but there is no limit to the number of unimportant contests we can lose. Every contest has a positive luck value, so we should lose every unimportant contest. For important contests, we should lose as many as we are allowed, and we should choose the contests with the largest luck values to lose. Make a list of the luck values for important contests and sort it. Add up to \\(k\\) of the largest values to your overall luck value and subtract any remaining values. Note that if you can lose at most \\(k\\) contests, then you must win at least \\(m.\\text{length} - k\\) important contests, where \\(m\\) is the array of important contests. If \\(k \\geq m.\\text{length}\\) , then you may lose every important contest. You can either start from the highest values and choose \\(k\\) contests to lose, or you can start from the lowest values and choose \\(m.\\text{length} - k\\) contests to win. Java 8: public static int luckBalance ( int k , List < List < Integer >> contests ) { int luck = 0 ; List < Integer > important = new ArrayList <> (); for ( List < Integer > contest : contests ) { final int L = contest . get ( 0 ); final int T = contest . get ( 1 ); if ( T == 1 ) { important . add ( L ); } else { luck += L ; } } Collections . sort ( important ); int requiredWins = important . size () - k ; for ( int l : important ) { if ( requiredWins > 0 ) { luck -= l ; requiredWins -- ; } else { luck += l ; } } return luck ; } C++: int luckBalance ( int k , vector < vector < int >> contests ) { vector < int > important ; int luck = 0 ; for ( auto contest = contests . begin (); contest != contests . end (); contest ++ ) { const int L = contest -> front (); const int T = contest -> back (); if ( T ) { important . push_back ( L ); } else { luck += L ; } } sort ( important . begin (), important . end ()); for ( auto l = important . rbegin (); l != important . rend (); l ++ ) { if ( k ) { luck += * l ; k -- ; } else { luck -= * l ; } } return luck ; } Python 3: def luckBalance ( k , contests ): important = [ contest [ 0 ] for contest in contests if contest [ - 1 ]] important . sort ( reverse = True ) luck = sum ( contest [ 0 ] for contest in contests if not contest [ - 1 ]) for l in important : if k : luck += l k -= 1 else : luck -= l return luck Back","title":"Luck Balance"},{"location":"interviewprep/greedyalgorithms/maxmin/","text":"Max Min Problem Category: Greedy Algorithms Difficulty: Medium Given an array of integers and \\(k\\) , choose \\(k\\) integers from the array such that unfairness is minimized. Input: an array \\(a[n]\\) of integers, and \\(k\\) , the number elements you must choose from \\(a\\) . \\[ 2 \\leq k \\leq n \\leq 10^5 \\] \\[ 0 \\leq a[i] \\leq 10^9 \\; \\; \\forall \\; i \\] Output: the minimum possible unfairness that can be achieved by choosing \\(k\\) elements from \\(a\\) . The unfairness of a subarray \\(a'[k]\\) is defined as \\(\\max(a') - \\min(a')\\) , or the difference between the largest value you chose and the smallest value you chose. The elements need not be consecutive in the original array \\(a\\) . There are \\({n \\choose k}\\) ways to choose \\(k\\) elements for our subarray \\(a'\\) , but we don't have to check every single one. For some element \\(a[i]\\) , consider all of the subarray choices such that \\(a[i]\\) is the minimum value. How should we choose the other \\(k - 1\\) elements to minimize unfairness? We can't choose anything smaller than \\(a[i]\\) , since we are considering the case when it is the minimum element. We should pick the smallest \\(k - 1\\) elements that are greater than or equal to \\(a[i]\\) . If we picked any other elements instead, that could only give us a larger max value and more unfairness. Therefore, if we sort \\(a\\) , the only subarrays we need to consider are each \\(k\\) -length contiguous subarray. For each starting (minimum) element \\(a[i]\\) , the optimal subarray to choose would be \\(a[i]\\) through \\(a[i + k - 1]\\) . The overall optimum subarray must have one of the elements as its minimum, so we will certainly find it when we get to that minimum element. Java 8: static int maxMin ( int k , int [] arr ) { int [] sorted = arr . clone (); Arrays . sort ( sorted ); int result = sorted [ k - 1 ] - sorted [ 0 ] ; for ( int i = 1 ; i + k <= arr . length ; i ++ ) { int j = i + k - 1 ; int unfairness = sorted [ j ] - sorted [ i ] ; result = Math . min ( result , unfairness ); } return result ; } C++: int maxMin ( int k , vector < int > arr ) { vector < int > sorted = arr ; sort ( sorted . begin (), sorted . end ()); int result = sorted [ k - 1 ] - sorted [ 0 ]; for ( int i = 1 ; i + k <= arr . size (); i ++ ) { int j = i + k - 1 ; int unfairness = sorted [ j ] - sorted [ i ]; result = min ( result , unfairness ); } return result ; } Python 3: def maxMin ( k , arr ): a = sorted ( arr ) result = a [ k - 1 ] - a [ 0 ] for i , val in enumerate ( a [:( 1 - k )]): j = i + k - 1 unfairness = a [ j ] - val result = min ( result , unfairness ) return result Back","title":"Max Min"},{"location":"interviewprep/greedyalgorithms/maxmin/#max-min","text":"Problem Category: Greedy Algorithms Difficulty: Medium Given an array of integers and \\(k\\) , choose \\(k\\) integers from the array such that unfairness is minimized. Input: an array \\(a[n]\\) of integers, and \\(k\\) , the number elements you must choose from \\(a\\) . \\[ 2 \\leq k \\leq n \\leq 10^5 \\] \\[ 0 \\leq a[i] \\leq 10^9 \\; \\; \\forall \\; i \\] Output: the minimum possible unfairness that can be achieved by choosing \\(k\\) elements from \\(a\\) . The unfairness of a subarray \\(a'[k]\\) is defined as \\(\\max(a') - \\min(a')\\) , or the difference between the largest value you chose and the smallest value you chose. The elements need not be consecutive in the original array \\(a\\) . There are \\({n \\choose k}\\) ways to choose \\(k\\) elements for our subarray \\(a'\\) , but we don't have to check every single one. For some element \\(a[i]\\) , consider all of the subarray choices such that \\(a[i]\\) is the minimum value. How should we choose the other \\(k - 1\\) elements to minimize unfairness? We can't choose anything smaller than \\(a[i]\\) , since we are considering the case when it is the minimum element. We should pick the smallest \\(k - 1\\) elements that are greater than or equal to \\(a[i]\\) . If we picked any other elements instead, that could only give us a larger max value and more unfairness. Therefore, if we sort \\(a\\) , the only subarrays we need to consider are each \\(k\\) -length contiguous subarray. For each starting (minimum) element \\(a[i]\\) , the optimal subarray to choose would be \\(a[i]\\) through \\(a[i + k - 1]\\) . The overall optimum subarray must have one of the elements as its minimum, so we will certainly find it when we get to that minimum element. Java 8: static int maxMin ( int k , int [] arr ) { int [] sorted = arr . clone (); Arrays . sort ( sorted ); int result = sorted [ k - 1 ] - sorted [ 0 ] ; for ( int i = 1 ; i + k <= arr . length ; i ++ ) { int j = i + k - 1 ; int unfairness = sorted [ j ] - sorted [ i ] ; result = Math . min ( result , unfairness ); } return result ; } C++: int maxMin ( int k , vector < int > arr ) { vector < int > sorted = arr ; sort ( sorted . begin (), sorted . end ()); int result = sorted [ k - 1 ] - sorted [ 0 ]; for ( int i = 1 ; i + k <= arr . size (); i ++ ) { int j = i + k - 1 ; int unfairness = sorted [ j ] - sorted [ i ]; result = min ( result , unfairness ); } return result ; } Python 3: def maxMin ( k , arr ): a = sorted ( arr ) result = a [ k - 1 ] - a [ 0 ] for i , val in enumerate ( a [:( 1 - k )]): j = i + k - 1 unfairness = a [ j ] - val result = min ( result , unfairness ) return result Back","title":"Max Min"},{"location":"interviewprep/greedyalgorithms/minabsdiff/","text":"Minimum Absolute Difference in an Array Problem Category: Greedy Algorithms Difficulty: Easy Given an array, find the minimum difference between any two numbers. Input: an array \\(a[n]\\) of integers. \\[ 2 \\leq n \\leq 10^5 \\] \\[ -10^9 \\leq a[i] \\leq 10^9 \\; \\forall \\; i \\] Output: the minimum absolute difference between any two values in the array: \\[ \\min_{i \\neq j} |a[i] - a[j]| \\] There are \\({n \\choose 2}\\) different absolute differences in \\(a\\) , but many of them cannot be the minimum absolute difference. For example, if \\(a[i] < a[j] < a[k]\\) , then the difference between \\(a[i]\\) and \\(a[j]\\) will be smaller than the difference between \\(a[i]\\) and \\(a[k]\\) . If we sort the array, then the two closest values will be next to each other. Therefore, all we need to do is sort the array and check the difference between each consecutive pair of values. Note that if the array is sorted, we can compute the absolute difference as \\(a[i] - a[i - 1]\\) , because \\(a[i] \\geq a[i - 1]\\) . Java 8: public static int minimumAbsoluteDifference ( List < Integer > arr ) { final int N = arr . size (); Integer [] a = arr . toArray ( new Integer [ N ] ); Arrays . sort ( a ); int minDiff = Integer . MAX_VALUE ; for ( int i = 1 ; i < N ; i ++ ) { minDiff = Math . min ( minDiff , a [ i ] - a [ i - 1 ] ); } return minDiff ; } C++: int minimumAbsoluteDifference ( vector < int > arr ) { vector < int > a = arr ; sort ( a . begin (), a . end ()); int minDiff = ( 1 << 31 ) - 1 ; for ( int i = 1 ; i < a . size (); i ++ ) { minDiff = min ( minDiff , a [ i ] - a [ i - 1 ]); } return minDiff ; } Python 3: def minimumAbsoluteDifference ( arr ): a = sorted ( arr ) return min ( a [ i ] - a [ i - 1 ] for i in range ( 1 , len ( a ))) Back","title":"Minimum Absolute Difference in an Array"},{"location":"interviewprep/greedyalgorithms/minabsdiff/#minimum-absolute-difference-in-an-array","text":"Problem Category: Greedy Algorithms Difficulty: Easy Given an array, find the minimum difference between any two numbers. Input: an array \\(a[n]\\) of integers. \\[ 2 \\leq n \\leq 10^5 \\] \\[ -10^9 \\leq a[i] \\leq 10^9 \\; \\forall \\; i \\] Output: the minimum absolute difference between any two values in the array: \\[ \\min_{i \\neq j} |a[i] - a[j]| \\] There are \\({n \\choose 2}\\) different absolute differences in \\(a\\) , but many of them cannot be the minimum absolute difference. For example, if \\(a[i] < a[j] < a[k]\\) , then the difference between \\(a[i]\\) and \\(a[j]\\) will be smaller than the difference between \\(a[i]\\) and \\(a[k]\\) . If we sort the array, then the two closest values will be next to each other. Therefore, all we need to do is sort the array and check the difference between each consecutive pair of values. Note that if the array is sorted, we can compute the absolute difference as \\(a[i] - a[i - 1]\\) , because \\(a[i] \\geq a[i - 1]\\) . Java 8: public static int minimumAbsoluteDifference ( List < Integer > arr ) { final int N = arr . size (); Integer [] a = arr . toArray ( new Integer [ N ] ); Arrays . sort ( a ); int minDiff = Integer . MAX_VALUE ; for ( int i = 1 ; i < N ; i ++ ) { minDiff = Math . min ( minDiff , a [ i ] - a [ i - 1 ] ); } return minDiff ; } C++: int minimumAbsoluteDifference ( vector < int > arr ) { vector < int > a = arr ; sort ( a . begin (), a . end ()); int minDiff = ( 1 << 31 ) - 1 ; for ( int i = 1 ; i < a . size (); i ++ ) { minDiff = min ( minDiff , a [ i ] - a [ i - 1 ]); } return minDiff ; } Python 3: def minimumAbsoluteDifference ( arr ): a = sorted ( arr ) return min ( a [ i ] - a [ i - 1 ] for i in range ( 1 , len ( a ))) Back","title":"Minimum Absolute Difference in an Array"},{"location":"interviewprep/linkedlists/detectcycle/","text":"Linked Lists: Detect a Cycle Problem Category: Linked Lists Difficulty: Easy Determine whether a given linked list has a cycle. Input: the head of a linked list with \\(n\\) nodes. \\[ 0 \\leq n \\leq 100 \\] struct Node { int data; struct Node* next; } Output: true if the list has a cycle and false if it terminates. One way to detect a cycle in the linked list is to iterate over the list and use a set to mark each node as visited. If you reach a node that has already been added to the set, there is a cycle. The list terminates if and only if there is no cycle. Another way to detect a cycle comes from Floyd's Tortoise and Hare : use two pointers to read through the list, where one pointer iterates sequentially ( \\(c \\gets c\\) .next) and the other iterates over every other node ( \\(c \\gets c\\) .next.next). If you ever see the end of the list with the faster pointer, there is no cycle. If there is a cycle, then eventually, both pointers will point to the same node. If you think about lists with different lengths and different cycle lengths, it may not be obvious that this is always true. Assume that the list of \\(n\\) nodes has \\(m\\) nodes at the beginning, followed by a cycle of \\(\\ell\\) nodes ( \\(n = m + \\ell\\) ). Let \\(c_i\\) be the node at index \\(i\\) in the list. Once the nodes enter the cycle ( \\(i \\geq m\\) ), it becomes true that \\(c_i = c_{i + k\\ell}\\) for all \\(k \\geq 0\\) . If you can write \\(i = k\\ell\\) for some \\(k\\) that makes \\(i \\geq m\\) , then you can say that \\(c_i = c_{i + k\\ell} = c_{2i}\\) . On the \\(i^{\\text{th}}\\) iteration, the slow pointer will point to \\(c_i\\) and the fast pointer will point to \\(c_{2i}\\) . Eventually, you will reach an \\(i = k\\ell \\geq m\\) for some \\(k\\) , and \\(c_i\\) and \\(c_{2i}\\) will be the same node. Many other approaches are viable to solve this problem. Notice that the list has at most 100 nodes. If you iterate over 100 nodes in the list and still haven't found the end, there must have been a cycle. Java 7: boolean hasCycle ( Node head ) { Set < Node > nodes = new HashSet <> (); Node current = head ; while ( current != null ) { if ( nodes . contains ( current )) { return true ; } nodes . add ( current ); current = current . next ; } return false ; } C++: bool has_cycle ( Node * head ) { if ( ! head ) { return false ; } Node * current = head ; Node * next = current -> next ; while ( current != next ) { if ( ! next || ! next -> next ) { return false ; } current = current -> next ; next = next -> next -> next ; } return true ; } Python 3: def has_cycle ( head ): nodes = set () current = head while current : if current in nodes : return True nodes . add ( current ) current = current . next return False Alternate Python 3 Solution: def has_cycle ( head ): MAX_NODES = 100 node_count = 0 current = head while current and node_count <= MAX_NODES : node_count += 1 current = current . next return node_count > MAX_NODES Back","title":"Linked Lists: Detect a Cycle"},{"location":"interviewprep/linkedlists/detectcycle/#linked-lists-detect-a-cycle","text":"Problem Category: Linked Lists Difficulty: Easy Determine whether a given linked list has a cycle. Input: the head of a linked list with \\(n\\) nodes. \\[ 0 \\leq n \\leq 100 \\] struct Node { int data; struct Node* next; } Output: true if the list has a cycle and false if it terminates. One way to detect a cycle in the linked list is to iterate over the list and use a set to mark each node as visited. If you reach a node that has already been added to the set, there is a cycle. The list terminates if and only if there is no cycle. Another way to detect a cycle comes from Floyd's Tortoise and Hare : use two pointers to read through the list, where one pointer iterates sequentially ( \\(c \\gets c\\) .next) and the other iterates over every other node ( \\(c \\gets c\\) .next.next). If you ever see the end of the list with the faster pointer, there is no cycle. If there is a cycle, then eventually, both pointers will point to the same node. If you think about lists with different lengths and different cycle lengths, it may not be obvious that this is always true. Assume that the list of \\(n\\) nodes has \\(m\\) nodes at the beginning, followed by a cycle of \\(\\ell\\) nodes ( \\(n = m + \\ell\\) ). Let \\(c_i\\) be the node at index \\(i\\) in the list. Once the nodes enter the cycle ( \\(i \\geq m\\) ), it becomes true that \\(c_i = c_{i + k\\ell}\\) for all \\(k \\geq 0\\) . If you can write \\(i = k\\ell\\) for some \\(k\\) that makes \\(i \\geq m\\) , then you can say that \\(c_i = c_{i + k\\ell} = c_{2i}\\) . On the \\(i^{\\text{th}}\\) iteration, the slow pointer will point to \\(c_i\\) and the fast pointer will point to \\(c_{2i}\\) . Eventually, you will reach an \\(i = k\\ell \\geq m\\) for some \\(k\\) , and \\(c_i\\) and \\(c_{2i}\\) will be the same node. Many other approaches are viable to solve this problem. Notice that the list has at most 100 nodes. If you iterate over 100 nodes in the list and still haven't found the end, there must have been a cycle. Java 7: boolean hasCycle ( Node head ) { Set < Node > nodes = new HashSet <> (); Node current = head ; while ( current != null ) { if ( nodes . contains ( current )) { return true ; } nodes . add ( current ); current = current . next ; } return false ; } C++: bool has_cycle ( Node * head ) { if ( ! head ) { return false ; } Node * current = head ; Node * next = current -> next ; while ( current != next ) { if ( ! next || ! next -> next ) { return false ; } current = current -> next ; next = next -> next -> next ; } return true ; } Python 3: def has_cycle ( head ): nodes = set () current = head while current : if current in nodes : return True nodes . add ( current ) current = current . next return False Alternate Python 3 Solution: def has_cycle ( head ): MAX_NODES = 100 node_count = 0 current = head while current and node_count <= MAX_NODES : node_count += 1 current = current . next return node_count > MAX_NODES Back","title":"Linked Lists: Detect a Cycle"},{"location":"interviewprep/linkedlists/findmergepointtwolists/","text":"Find Merge Point of Two Lists Problem Category: Linked Lists Difficuly: Easy Given two linked lists that merge, determine which node they merge at. Input: \\(h_1\\) and \\(h_2\\) , the heads of two linked lists that share at least one node. \\(h_1 \\neq h_2\\) . class SinglyLinkedListNode { int data; SinglyLinkedListNode* next; } Output: the data value of the first node that is contained in both lists. Note that it is not just guaranteed that the lists have nodes that share the same value: it is guaranteed that the lists share a node in memory, and therefore share any nodes that come after it in the lists. Instead of checking whether nodes have the same data value, you should be checking whether your references to the nodes are equal. If you can create a set of references to nodes, a simple way to solve the problem is to add all of the nodes of \\(h_1\\) 's list to a set, and then read through \\(h_2\\) 's list until you find the first node that is present in the set. It is guaranteed that the first node in \\(h_2\\) 's list that is also in \\(h_1\\) 's list is their merge point. A clever way that doesn't require extra space involves cycling through both lists at the same time until your references coincide. Let \\(c_1 \\gets h_1\\) and \\(c_2 \\gets h_2\\) , and continue iterating \\(c_1 \\gets c_1\\) .next and \\(c_2 \\gets c_2\\) .next until \\(c_1 = c_2\\) . When either reference reaches the end of its list, reset it to the head of its list. It makes sense that \\(c_1\\) and \\(c_2\\) will be equal eventually if the lists have the same length, but it is not as obvious that they will eventually be equal if the lists have different lengths. Let \\(n_1\\) be the length of \\(h_1\\) 's list and \\(n_2\\) be the length of \\(h_2\\) 's list. Let \\(m_1\\) be the position of the merge point in \\(h_1\\) 's list and \\(m_2\\) be the position of the merge point in \\(h_2\\) 's list. \\[ 0 \\leq m_1 < n_1 \\] \\[ 0 \\leq m_2 < n_2 \\] After the merge point, the lists are the same, so they both have the same number of nodes after the merge point: \\[ n_1 - m_1 = n_2 - m_2 \\] Let \\(a = n_1 - m_1 = n_2 - m_2\\) . On the \\(i^{\\text{th}}\\) iteration, \\(c_1\\) will be at position \\(i \\bmod n_1\\) , and \\(c_2\\) will be at position \\(i \\bmod n_2\\) . We are looking for an \\(i\\) that solves the following system of congruences: \\[ \\begin{align*} i & \\equiv m_1 \\pmod {n_1} \\\\ i & \\equiv m_2 \\pmod {n_2} \\end{align*} \\] A solution is \\(i = \\text{lcm}(n_1, n_2) - a\\) , which has \\(i \\equiv -a \\pmod {n_1}\\) and \\(i \\equiv -a \\pmod {n_2}\\) . \\[ \\begin{align*} i & \\equiv -a \\equiv n_1 - a \\equiv m_1 \\pmod {n_1} \\\\ i & \\equiv -a \\equiv n_2 - a \\equiv m_2 \\pmod {n_2} \\end{align*} \\] The last thing to check is that \\(i \\geq 0\\) : this is true because \\(a \\leq n_1\\) and \\(a \\leq n_2\\) , so \\(a \\leq \\text{lcm}(n_1, n_2)\\) . Therefore, there will be an iteration for which \\(c_1\\) and \\(c_2\\) reference the same node. The first time this occurs has to be the merge point. This solution is easier and shorter to implement, and it suffices to solve this problem. Java 8: static int findMergeNode ( SinglyLinkedListNode head1 , SinglyLinkedListNode head2 ) { SinglyLinkedListNode current1 = head1 ; SinglyLinkedListNode current2 = head2 ; while ( current1 != current2 ) { current1 = current1 . next != null ? current1 . next : head1 ; current2 = current2 . next != null ? current2 . next : head2 ; } return current1 . data ; } C++: int findMergeNode ( SinglyLinkedListNode * head1 , SinglyLinkedListNode * head2 ) { set < SinglyLinkedListNode *> references ; SinglyLinkedListNode * current = head1 ; while ( current ) { references . insert ( current ); current = current -> next ; } current = head2 ; while ( references . find ( current ) == references . end ()) { current = current -> next ; } return current -> data ; } Python 3: def findMergeNode ( head1 , head2 ): current1 , current2 = head1 , head2 while current1 is not current2 : current1 = current1 . next if current1 . next else head1 current2 = current2 . next if current2 . next else head2 return current1 . data Alternate Python 3 solution: def findMergeNode ( head1 , head2 ): nodes = set () current = head1 while current : nodes . add ( current ) current = current . next current = head2 while current not in nodes : current = current . next return current . data Back","title":"Find Merge Point of Two Lists"},{"location":"interviewprep/linkedlists/findmergepointtwolists/#find-merge-point-of-two-lists","text":"Problem Category: Linked Lists Difficuly: Easy Given two linked lists that merge, determine which node they merge at. Input: \\(h_1\\) and \\(h_2\\) , the heads of two linked lists that share at least one node. \\(h_1 \\neq h_2\\) . class SinglyLinkedListNode { int data; SinglyLinkedListNode* next; } Output: the data value of the first node that is contained in both lists. Note that it is not just guaranteed that the lists have nodes that share the same value: it is guaranteed that the lists share a node in memory, and therefore share any nodes that come after it in the lists. Instead of checking whether nodes have the same data value, you should be checking whether your references to the nodes are equal. If you can create a set of references to nodes, a simple way to solve the problem is to add all of the nodes of \\(h_1\\) 's list to a set, and then read through \\(h_2\\) 's list until you find the first node that is present in the set. It is guaranteed that the first node in \\(h_2\\) 's list that is also in \\(h_1\\) 's list is their merge point. A clever way that doesn't require extra space involves cycling through both lists at the same time until your references coincide. Let \\(c_1 \\gets h_1\\) and \\(c_2 \\gets h_2\\) , and continue iterating \\(c_1 \\gets c_1\\) .next and \\(c_2 \\gets c_2\\) .next until \\(c_1 = c_2\\) . When either reference reaches the end of its list, reset it to the head of its list. It makes sense that \\(c_1\\) and \\(c_2\\) will be equal eventually if the lists have the same length, but it is not as obvious that they will eventually be equal if the lists have different lengths. Let \\(n_1\\) be the length of \\(h_1\\) 's list and \\(n_2\\) be the length of \\(h_2\\) 's list. Let \\(m_1\\) be the position of the merge point in \\(h_1\\) 's list and \\(m_2\\) be the position of the merge point in \\(h_2\\) 's list. \\[ 0 \\leq m_1 < n_1 \\] \\[ 0 \\leq m_2 < n_2 \\] After the merge point, the lists are the same, so they both have the same number of nodes after the merge point: \\[ n_1 - m_1 = n_2 - m_2 \\] Let \\(a = n_1 - m_1 = n_2 - m_2\\) . On the \\(i^{\\text{th}}\\) iteration, \\(c_1\\) will be at position \\(i \\bmod n_1\\) , and \\(c_2\\) will be at position \\(i \\bmod n_2\\) . We are looking for an \\(i\\) that solves the following system of congruences: \\[ \\begin{align*} i & \\equiv m_1 \\pmod {n_1} \\\\ i & \\equiv m_2 \\pmod {n_2} \\end{align*} \\] A solution is \\(i = \\text{lcm}(n_1, n_2) - a\\) , which has \\(i \\equiv -a \\pmod {n_1}\\) and \\(i \\equiv -a \\pmod {n_2}\\) . \\[ \\begin{align*} i & \\equiv -a \\equiv n_1 - a \\equiv m_1 \\pmod {n_1} \\\\ i & \\equiv -a \\equiv n_2 - a \\equiv m_2 \\pmod {n_2} \\end{align*} \\] The last thing to check is that \\(i \\geq 0\\) : this is true because \\(a \\leq n_1\\) and \\(a \\leq n_2\\) , so \\(a \\leq \\text{lcm}(n_1, n_2)\\) . Therefore, there will be an iteration for which \\(c_1\\) and \\(c_2\\) reference the same node. The first time this occurs has to be the merge point. This solution is easier and shorter to implement, and it suffices to solve this problem. Java 8: static int findMergeNode ( SinglyLinkedListNode head1 , SinglyLinkedListNode head2 ) { SinglyLinkedListNode current1 = head1 ; SinglyLinkedListNode current2 = head2 ; while ( current1 != current2 ) { current1 = current1 . next != null ? current1 . next : head1 ; current2 = current2 . next != null ? current2 . next : head2 ; } return current1 . data ; } C++: int findMergeNode ( SinglyLinkedListNode * head1 , SinglyLinkedListNode * head2 ) { set < SinglyLinkedListNode *> references ; SinglyLinkedListNode * current = head1 ; while ( current ) { references . insert ( current ); current = current -> next ; } current = head2 ; while ( references . find ( current ) == references . end ()) { current = current -> next ; } return current -> data ; } Python 3: def findMergeNode ( head1 , head2 ): current1 , current2 = head1 , head2 while current1 is not current2 : current1 = current1 . next if current1 . next else head1 current2 = current2 . next if current2 . next else head2 return current1 . data Alternate Python 3 solution: def findMergeNode ( head1 , head2 ): nodes = set () current = head1 while current : nodes . add ( current ) current = current . next current = head2 while current not in nodes : current = current . next return current . data Back","title":"Find Merge Point of Two Lists"},{"location":"interviewprep/linkedlists/insndll/","text":"Inserting a Node into a Sorted Doubly Linked List Problem Category: Linked Lists Difficulty: Easy Insert a new node into the correct position in a sorted doubly linked list. Input: the head of a doubly linked list with \\(n\\) nodes sorted by data values, and the data value \\(d\\) of a new node to be inserted. class DoublyLinkedListNode { int data; DoublyLinkedListNode* next; DoublyLinkedListNode* prev; DoublyLinkedListNode(int data) : data(data) {} } Output: the head of the updated linked list, where a node with data \\(d\\) has been inserted and the list is still sorted. We need to iterate through the linked list until we find the position where the new node should be inserted. A special case is when \\(d\\) is less than the head's data value: this means that the new node should become the new head of the list. The old head's prev pointer should point to the new node. Otherwise, we need to search the list for the insertion position. Because this is a doubly linked list, we will need to update the nodes immediately before and after the new node in the list. We want to find a node \\(c\\) such that \\(c\\) comes before the new node ( \\(c\\) .data \\(\\leq d\\) ), but \\(c\\) .next comes after the new node ( \\(c\\) .next.data \\(> d\\) ). The new node's prev and next pointers should point to \\(c\\) and \\(c\\) .next, respectively. \\(c\\) 's next pointer and \\(c\\) .next's prev pointer should each point to the new node. Note that if \\(d\\) is greater than every value in the list, then the new node should go at the end. \\(c\\) will be the last node, and \\(c\\) .next will not exist. In this case, the new node's next pointer should be null. Java 8: public static DoublyLinkedListNode sortedInsert ( DoublyLinkedListNode llist , int data ) { DoublyLinkedListNode newNode = new DoublyLinkedListNode ( data ); if ( data < llist . data ) { newNode . next = llist ; llist . prev = newNode ; return newNode ; } DoublyLinkedListNode current = llist ; while ( current . next != null && current . next . data <= data ) { current = current . next ; } newNode . next = current . next ; newNode . prev = current ; current . next = newNode ; if ( newNode . next != null ) { newNode . next . prev = newNode ; } return llist ; } C++: DoublyLinkedListNode * sortedInsert ( DoublyLinkedListNode * llist , int data ) { DoublyLinkedListNode * newNode = new DoublyLinkedListNode ( data ); if ( data < llist -> data ) { newNode -> next = llist ; llist -> prev = newNode ; return newNode ; } DoublyLinkedListNode * current = llist ; while ( current -> next && current -> next -> data <= data ) { current = current -> next ; } newNode -> next = current -> next ; newNode -> prev = current ; current -> next = newNode ; if ( newNode -> next ) { newNode -> next -> prev = newNode ; } return llist ; } Python 3: def sortedInsert ( llist , data ): node = DoublyLinkedListNode ( data ) if data < llist . data : node . next = llist llist . prev = node return node current = llist while current . next and current . next . data <= data : current = current . next node . next = current . next node . prev = current current . next = node if node . next : node . next . prev = node return llist Back","title":"Inserting a Node into a Sorted Doubly Linked List"},{"location":"interviewprep/linkedlists/insndll/#inserting-a-node-into-a-sorted-doubly-linked-list","text":"Problem Category: Linked Lists Difficulty: Easy Insert a new node into the correct position in a sorted doubly linked list. Input: the head of a doubly linked list with \\(n\\) nodes sorted by data values, and the data value \\(d\\) of a new node to be inserted. class DoublyLinkedListNode { int data; DoublyLinkedListNode* next; DoublyLinkedListNode* prev; DoublyLinkedListNode(int data) : data(data) {} } Output: the head of the updated linked list, where a node with data \\(d\\) has been inserted and the list is still sorted. We need to iterate through the linked list until we find the position where the new node should be inserted. A special case is when \\(d\\) is less than the head's data value: this means that the new node should become the new head of the list. The old head's prev pointer should point to the new node. Otherwise, we need to search the list for the insertion position. Because this is a doubly linked list, we will need to update the nodes immediately before and after the new node in the list. We want to find a node \\(c\\) such that \\(c\\) comes before the new node ( \\(c\\) .data \\(\\leq d\\) ), but \\(c\\) .next comes after the new node ( \\(c\\) .next.data \\(> d\\) ). The new node's prev and next pointers should point to \\(c\\) and \\(c\\) .next, respectively. \\(c\\) 's next pointer and \\(c\\) .next's prev pointer should each point to the new node. Note that if \\(d\\) is greater than every value in the list, then the new node should go at the end. \\(c\\) will be the last node, and \\(c\\) .next will not exist. In this case, the new node's next pointer should be null. Java 8: public static DoublyLinkedListNode sortedInsert ( DoublyLinkedListNode llist , int data ) { DoublyLinkedListNode newNode = new DoublyLinkedListNode ( data ); if ( data < llist . data ) { newNode . next = llist ; llist . prev = newNode ; return newNode ; } DoublyLinkedListNode current = llist ; while ( current . next != null && current . next . data <= data ) { current = current . next ; } newNode . next = current . next ; newNode . prev = current ; current . next = newNode ; if ( newNode . next != null ) { newNode . next . prev = newNode ; } return llist ; } C++: DoublyLinkedListNode * sortedInsert ( DoublyLinkedListNode * llist , int data ) { DoublyLinkedListNode * newNode = new DoublyLinkedListNode ( data ); if ( data < llist -> data ) { newNode -> next = llist ; llist -> prev = newNode ; return newNode ; } DoublyLinkedListNode * current = llist ; while ( current -> next && current -> next -> data <= data ) { current = current -> next ; } newNode -> next = current -> next ; newNode -> prev = current ; current -> next = newNode ; if ( newNode -> next ) { newNode -> next -> prev = newNode ; } return llist ; } Python 3: def sortedInsert ( llist , data ): node = DoublyLinkedListNode ( data ) if data < llist . data : node . next = llist llist . prev = node return node current = llist while current . next and current . next . data <= data : current = current . next node . next = current . next node . prev = current current . next = node if node . next : node . next . prev = node return llist Back","title":"Inserting a Node into a Sorted Doubly Linked List"},{"location":"interviewprep/linkedlists/isp/","text":"Insert a Node at a Specific Position in a Linked List Problem Category: Linked Lists Difficulty: Easy Insert a new node with the given data at the given position in a linked list. Input: the head of a linked list with \\(n\\) nodes, a data value \\(d\\) , and a position \\(p\\) . \\[ 1 \\leq n \\leq 1000 \\] \\[ 0 \\leq p \\leq n \\] class SinglyLinkedListNode { int data; SinglyLinkedListNode* next; SinglyLinkedListNode(int data) : data(data) {} } Output: The head of the updated linked list, where a new node with data \\(d\\) has been inserted at index \\(p\\) . There are two cases to consider. If \\(p = 0\\) , then the new node should be inserted at the front of the list, and it should become the new head, with its next pointer pointing to the old head. If \\(p > 0\\) , let \\(c\\) be the node at position \\(p - 1\\) . \\(c\\) .next should point to the new node, and the new node should point to the old value of \\(c\\) .next, the node which was originally at position \\(p\\) (and will now be at position \\(p + 1\\) ). Make sure you link your new node to \\(c\\) .next before linking \\(c\\) to your new node so you don't lose a pointer to the rest of the list. Java 8: public static SinglyLinkedListNode insertNodeAtPosition ( SinglyLinkedListNode llist , int data , int position ) { SinglyLinkedListNode newNode = new SinglyLinkedListNode ( data ); if ( position == 0 ) { newNode . next = llist ; return newNode ; } SinglyLinkedListNode current = llist ; int i = 1 ; while ( i < position ) { current = current . next ; i ++ ; } newNode . next = current . next ; current . next = newNode ; return llist ; } C++: SinglyLinkedListNode * insertNodeAtPosition ( SinglyLinkedListNode * llist , int data , int position ) { SinglyLinkedListNode * newNode = new SinglyLinkedListNode ( data ); if ( ! position ) { newNode -> next = llist ; return newNode ; } SinglyLinkedListNode * current = llist ; int i = 1 ; while ( i < position ) { current = current -> next ; i ++ ; } newNode -> next = current -> next ; current -> next = newNode ; return llist ; } Python 3: def insertNodeAtPosition ( llist , data , position ): node = SinglyLinkedListNode ( data ) if not position : node . next = llist return node current = llist i = 1 while i < position : current = current . next i += 1 node . next = current . next current . next = node return llist Back","title":"Insert a Node at a Specific Position in a Linked List"},{"location":"interviewprep/linkedlists/isp/#insert-a-node-at-a-specific-position-in-a-linked-list","text":"Problem Category: Linked Lists Difficulty: Easy Insert a new node with the given data at the given position in a linked list. Input: the head of a linked list with \\(n\\) nodes, a data value \\(d\\) , and a position \\(p\\) . \\[ 1 \\leq n \\leq 1000 \\] \\[ 0 \\leq p \\leq n \\] class SinglyLinkedListNode { int data; SinglyLinkedListNode* next; SinglyLinkedListNode(int data) : data(data) {} } Output: The head of the updated linked list, where a new node with data \\(d\\) has been inserted at index \\(p\\) . There are two cases to consider. If \\(p = 0\\) , then the new node should be inserted at the front of the list, and it should become the new head, with its next pointer pointing to the old head. If \\(p > 0\\) , let \\(c\\) be the node at position \\(p - 1\\) . \\(c\\) .next should point to the new node, and the new node should point to the old value of \\(c\\) .next, the node which was originally at position \\(p\\) (and will now be at position \\(p + 1\\) ). Make sure you link your new node to \\(c\\) .next before linking \\(c\\) to your new node so you don't lose a pointer to the rest of the list. Java 8: public static SinglyLinkedListNode insertNodeAtPosition ( SinglyLinkedListNode llist , int data , int position ) { SinglyLinkedListNode newNode = new SinglyLinkedListNode ( data ); if ( position == 0 ) { newNode . next = llist ; return newNode ; } SinglyLinkedListNode current = llist ; int i = 1 ; while ( i < position ) { current = current . next ; i ++ ; } newNode . next = current . next ; current . next = newNode ; return llist ; } C++: SinglyLinkedListNode * insertNodeAtPosition ( SinglyLinkedListNode * llist , int data , int position ) { SinglyLinkedListNode * newNode = new SinglyLinkedListNode ( data ); if ( ! position ) { newNode -> next = llist ; return newNode ; } SinglyLinkedListNode * current = llist ; int i = 1 ; while ( i < position ) { current = current -> next ; i ++ ; } newNode -> next = current -> next ; current -> next = newNode ; return llist ; } Python 3: def insertNodeAtPosition ( llist , data , position ): node = SinglyLinkedListNode ( data ) if not position : node . next = llist return node current = llist i = 1 while i < position : current = current . next i += 1 node . next = current . next current . next = node return llist Back","title":"Insert a Node at a Specific Position in a Linked List"},{"location":"interviewprep/linkedlists/reversedoublylinkedlist/","text":"Reverse a Doubly Linked List Problem Category: Linked Lists Difficulty: Easy Reverse the order of a given doubly linked list. Input: the head of a doubly linked list with \\(n\\) nodes. \\[ 1 \\leq n \\leq 1000 \\] class DoublyLinkedListNode { int data; DoublyLinkedListNode* next; DoublyLinkedListNode* prev; } Output: the new head of the linked list where every link has been reversed. Every node's next pointer points to the node before it in the original list, and every node's prev pointer points to the node after it in the original list. The new head will be the last node in the original list. A simple way to reverse a doubly linked list involves keeping track of three references: the current node \\(c\\) , its previous node \\(p\\) , and its next node \\(m\\) . Start with \\(c\\) as the head node and update its links: \\[ c.\\text{prev} \\gets m \\] \\[ c.\\text{next} \\gets p \\] and then update the references: \\[ p \\gets c \\] \\[ c \\gets m \\] \\[ m \\gets m.\\text{next} \\] Be careful to avoid dereferencing \\(m\\) when it becomes null at the end of the list. Note that this algorithm correctly handles the first node of the list, where \\(p\\) is null: it sets \\(c\\) .next to null, which is correct because \\(c\\) will become the last node of the reversed list. It also handles the last node of the list correctly, where \\(m\\) is null: it sets \\(c\\) .prev to null, and \\(c\\) will become the head of the new list. It even works if the list contains only one node, because it swaps the two null references \\(c\\) .next and \\(c\\) .prev. Java 8: public static DoublyLinkedListNode reverse ( DoublyLinkedListNode llist ) { DoublyLinkedListNode current = llist ; DoublyLinkedListNode prev = current . prev ; DoublyLinkedListNode next = current . next ; while ( next != null ) { current . next = prev ; current . prev = next ; prev = current ; current = next ; next = current . next ; } current . next = prev ; current . prev = next ; return current ; } C++: DoublyLinkedListNode * reverse ( DoublyLinkedListNode * llist ) { DoublyLinkedListNode * current = llist ; DoublyLinkedListNode * prev = current -> prev ; DoublyLinkedListNode * next = current -> next ; while ( next ) { current -> next = prev ; current -> prev = next ; prev = current ; current = next ; next = current -> next ; } current -> next = prev ; current -> prev = next ; return current ; } Python 3: def reverse ( llist ): current = llist prev = current . prev next_node = current . next while next_node : current . next = prev current . prev = next_node prev = current current = next_node next_node = current . next current . next = prev current . prev = next_node return current Back","title":"Reverse a Doubly Linked List"},{"location":"interviewprep/linkedlists/reversedoublylinkedlist/#reverse-a-doubly-linked-list","text":"Problem Category: Linked Lists Difficulty: Easy Reverse the order of a given doubly linked list. Input: the head of a doubly linked list with \\(n\\) nodes. \\[ 1 \\leq n \\leq 1000 \\] class DoublyLinkedListNode { int data; DoublyLinkedListNode* next; DoublyLinkedListNode* prev; } Output: the new head of the linked list where every link has been reversed. Every node's next pointer points to the node before it in the original list, and every node's prev pointer points to the node after it in the original list. The new head will be the last node in the original list. A simple way to reverse a doubly linked list involves keeping track of three references: the current node \\(c\\) , its previous node \\(p\\) , and its next node \\(m\\) . Start with \\(c\\) as the head node and update its links: \\[ c.\\text{prev} \\gets m \\] \\[ c.\\text{next} \\gets p \\] and then update the references: \\[ p \\gets c \\] \\[ c \\gets m \\] \\[ m \\gets m.\\text{next} \\] Be careful to avoid dereferencing \\(m\\) when it becomes null at the end of the list. Note that this algorithm correctly handles the first node of the list, where \\(p\\) is null: it sets \\(c\\) .next to null, which is correct because \\(c\\) will become the last node of the reversed list. It also handles the last node of the list correctly, where \\(m\\) is null: it sets \\(c\\) .prev to null, and \\(c\\) will become the head of the new list. It even works if the list contains only one node, because it swaps the two null references \\(c\\) .next and \\(c\\) .prev. Java 8: public static DoublyLinkedListNode reverse ( DoublyLinkedListNode llist ) { DoublyLinkedListNode current = llist ; DoublyLinkedListNode prev = current . prev ; DoublyLinkedListNode next = current . next ; while ( next != null ) { current . next = prev ; current . prev = next ; prev = current ; current = next ; next = current . next ; } current . next = prev ; current . prev = next ; return current ; } C++: DoublyLinkedListNode * reverse ( DoublyLinkedListNode * llist ) { DoublyLinkedListNode * current = llist ; DoublyLinkedListNode * prev = current -> prev ; DoublyLinkedListNode * next = current -> next ; while ( next ) { current -> next = prev ; current -> prev = next ; prev = current ; current = next ; next = current -> next ; } current -> next = prev ; current -> prev = next ; return current ; } Python 3: def reverse ( llist ): current = llist prev = current . prev next_node = current . next while next_node : current . next = prev current . prev = next_node prev = current current = next_node next_node = current . next current . next = prev current . prev = next_node return current Back","title":"Reverse a Doubly Linked List"},{"location":"interviewprep/misc/flippingbits/","text":"Flipping Bits Problem Category: Miscellaneous Difficulty: Easy Flip all of the bits of a 32-bit unsigned integer. Input: an unsigned integer \\(n\\) . \\[ 0 \\leq n < 2^{32} \\] Output: the unsigned integer result of flipping all 32 bits of \\(n\\) . To flip the bits of any bitstring, XOR it with a bitstring of all ones: \\[ 0 \\oplus 1 = 1, \\; 1 \\oplus 1 = 0 \\] \\[ b \\oplus 1 = \\lnot b \\; \\text{for} \\; b \\in \\{0, 1\\} \\] Another equivalent formula is to subtract \\(n\\) from the bitstring of all ones. Note that the input and output for this problem are actually 64-bit signed integers, even though \\(n\\) is small enough to fit in a 32-bit unsigned integer. This is why simply negating \\(n\\) does not give the desired answer. We only want to flip \\(n\\) 's lower 32 bits, so you should XOR \\(n\\) with a long integer that has 32 zeroes followed by 32 ones. You may have to be careful with your language's implicit casting: for example, 0xFFFFFFFF might be interpreted as the integer -1 , which could be cast as a long -1 with 64 ones if you try to XOR it with the long \\(n\\) . Calculating \\(2^{32} - 1\\) and subtracting \\(n\\) may be a less tricky way to achieve the same result. Java 8: public static long flippingBits ( long n ) { return n ^ 0xFFFFFFFFL ; } C++: long flippingBits ( long n ) { return n ^ 0xFFFFFFFF ; } Python 3: def flippingBits ( n ): return n ^ 0xFFFFFFFF Alternate Python 3 Solution: def flippingBits ( n ): return 2 ** 32 - 1 - n Back","title":"Flipping Bits"},{"location":"interviewprep/misc/flippingbits/#flipping-bits","text":"Problem Category: Miscellaneous Difficulty: Easy Flip all of the bits of a 32-bit unsigned integer. Input: an unsigned integer \\(n\\) . \\[ 0 \\leq n < 2^{32} \\] Output: the unsigned integer result of flipping all 32 bits of \\(n\\) . To flip the bits of any bitstring, XOR it with a bitstring of all ones: \\[ 0 \\oplus 1 = 1, \\; 1 \\oplus 1 = 0 \\] \\[ b \\oplus 1 = \\lnot b \\; \\text{for} \\; b \\in \\{0, 1\\} \\] Another equivalent formula is to subtract \\(n\\) from the bitstring of all ones. Note that the input and output for this problem are actually 64-bit signed integers, even though \\(n\\) is small enough to fit in a 32-bit unsigned integer. This is why simply negating \\(n\\) does not give the desired answer. We only want to flip \\(n\\) 's lower 32 bits, so you should XOR \\(n\\) with a long integer that has 32 zeroes followed by 32 ones. You may have to be careful with your language's implicit casting: for example, 0xFFFFFFFF might be interpreted as the integer -1 , which could be cast as a long -1 with 64 ones if you try to XOR it with the long \\(n\\) . Calculating \\(2^{32} - 1\\) and subtracting \\(n\\) may be a less tricky way to achieve the same result. Java 8: public static long flippingBits ( long n ) { return n ^ 0xFFFFFFFFL ; } C++: long flippingBits ( long n ) { return n ^ 0xFFFFFFFF ; } Python 3: def flippingBits ( n ): return n ^ 0xFFFFFFFF Alternate Python 3 Solution: def flippingBits ( n ): return 2 ** 32 - 1 - n Back","title":"Flipping Bits"},{"location":"interviewprep/recursionbacktracking/fibonaccinumbers/","text":"Recursion: Fibonacci Numbers Problem Category: Recursion and Backtracking Difficulty: Easy Given \\(n\\) , calculate the \\(n^{\\text{th}}\\) Fibonacci number. Input: \\(n\\) , the index into the Fibonacci sequence of the value to calculate. \\[ 1 \\leq n \\leq 30 \\] Output: the \\(n^{\\text{th}}\\) Fibonacci number, \\(f(n)\\) : \\[ f(n) = \\left\\{ \\begin{array}{ll} n & 0 \\leq n \\leq 1 \\\\ f(n - 1) + f(n - 2) & n > 1 \\\\ \\end{array} \\right. \\] The Fibonacci sequence is defined recursively, so it is easy to write a recursive function that computes it: f(n): if n <= 1: return n else: return f(n - 1) + f(n - 2) For this problem, that approach suffices. But this wouldn't cut it for large \\(n\\) because it does a lot of redundant work. Consider a call to \\(f(4)\\) : \\[ f(4) \\to \\left\\{ \\begin{array}{ll} f(3) & \\to \\left\\{ \\begin{array}{ll} f(2) & \\to \\left\\{ \\begin{array}{ll} f(1) & \\to 1 \\\\ f(0) & \\to 0 \\\\ \\end{array} \\right. \\\\ f(1) & \\to 1\\\\ \\end{array} \\right. \\\\ f(2) & \\to \\left\\{ \\begin{array}{ll} f(1) & \\to 1 \\\\ f(0) & \\to 0 \\\\ \\end{array} \\right. \\\\ \\end{array} \\right. \\] \\(f(4)\\) calls \\(f(3)\\) once and \\(f(2)\\) once. The result of \\(f(3)\\) is calculated with calls to \\(f(2)\\) and \\(f(1)\\) . Each call to \\(f(2)\\) makes calls to \\(f(1)\\) and \\(f(0)\\) . So to calculate \\(f(4)\\) , we made one call to \\(f(3)\\) , two calls to \\(f(2)\\) , three calls to \\(f(1)\\) , and two calls to \\(f(0)\\) . Why compute \\(f(0)\\) , \\(f(1)\\) , \\(f(2)\\) , or \\(f(3)\\) more than once? As \\(n\\) grows larger, the number of redundant calls to \\(f\\) becomes untenable. A better way to compute \\(f\\) is to start with 0 and 1 and build the sequence up to \\(n\\) . As a bonus, \\(f\\) is a constant-recursive sequence , and it turns out that there is a closed-form formula for the Fibonacci sequence . The formula looks like this: \\[ \\alpha = \\frac{1 + \\sqrt{5}}{2}, \\; \\beta = \\frac{1 - \\sqrt{5}}{2} \\] \\[ f(n) = \\frac{1}{\\sqrt{5}}(\\alpha^n - \\beta^n) \\] It's definitely not obvious that this works. How do we know that \\(f(n)\\) is even an integer after we divide by \\(\\sqrt{5}\\) ? It can be proven by induction. First, we can see that the formula works for \\(n = 0\\) and \\(n = 1\\) : \\[ f(0) = \\frac{1}{\\sqrt{5}}(\\alpha^0 - \\beta^0) = \\frac{1}{\\sqrt{5}}(1 - 1) = \\frac{1}{\\sqrt{5}} 0 = 0 \\] \\[ f(1) = \\frac{1}{\\sqrt{5}}(\\alpha^1 - \\beta^1) = \\frac{1}{\\sqrt{5}}\\left(\\frac{1 + \\sqrt{5}}{2} - \\frac{1 - \\sqrt{5}}{2}\\right) = \\frac{1}{\\sqrt{5}}\\left(\\frac{2\\sqrt{5}}{2}\\right) = 1 \\] Now, for some \\(k \\geq 0\\) , assume the formula holds for \\(k\\) and \\(k + 1\\) : \\[ f(k) = \\frac{1}{\\sqrt{5}}(\\alpha^k - \\beta^k) \\] \\[ f(k + 1) = \\frac{1}{\\sqrt{5}}(\\alpha^{k + 1} - \\beta^{k + 1}) \\] We need to show that it holds for \\(k + 2\\) . The trick is that \\(\\alpha\\) and \\(\\beta\\) are very special numbers: \\(x = \\alpha\\) and \\(x = \\beta\\) are the two solutions of the equation \\(x^2 = x + 1\\) . This means we can substitute \\(\\alpha^2\\) for \\(\\alpha + 1\\) and \\(\\beta^2\\) for \\(\\beta + 1\\) , and this is why the formula works: \\[ \\begin{align*} f(k + 2) & = \\frac{1}{\\sqrt{5}}(\\alpha^{k + 2} - \\beta^{k + 2}) \\\\ & = \\frac{1}{\\sqrt{5}}(\\alpha^2 \\alpha^k - \\beta^2 \\beta^k) \\\\ & = \\frac{1}{\\sqrt{5}}((\\alpha + 1)\\alpha^k - (\\beta + 1)\\beta^k) \\\\ & = \\frac{1}{\\sqrt{5}}(\\alpha^{k + 1} + \\alpha^k - \\beta^{k + 1} - \\beta^k) \\\\ & = \\frac{1}{\\sqrt{5}}(\\alpha^{k + 1} - \\beta^{k + 1}) - \\frac{1}{\\sqrt{5}}(\\alpha^k - \\beta^k) \\\\ & = f(k + 1) + f(k) \\end{align*} \\] \\(f(k + 2) = f(k + 1) + f(k)\\) , so \\(f(k + 2)\\) is the \\((k + 2)^\\text{th}\\) Fibonacci number and the formula is correct. The only issue could be imprecision of using \\(\\sqrt{5}\\) in the computations. Your \\(\\sqrt{5}\\) term might not cancel out correctly and you might be off by one if you truncate to the wrong integer. Here is a version of the formula that always floors to the correct integer: \\[ f(n) = \\left\\lfloor\\frac{1}{\\sqrt{5}}\\left(\\frac{1 + \\sqrt{5}}{2}\\right)^n + \\frac{1}{2}\\right\\rfloor \\] Java 8: public static int fibonacci ( int n ) { int prev = 0 ; int next = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { int temp = prev ; prev = next ; next += temp ; } return next ; } C++: int fibonacci ( int n ) { int prev = 0 ; int next = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { int temp = prev ; prev = next ; next += temp ; } return next ; } Python 3: def fibonacci ( n ): prev , current = 0 , 1 for _ in range ( n - 1 ): prev , current = current , current + prev return current Alternate Python 3 Solution: def fibonacci ( n ): sqrt5 = 5 ** 0.5 phi = ( 1 + sqrt5 ) / 2 return round ( phi ** n / sqrt5 ) Back","title":"Recursion: Fibonacci Numbers"},{"location":"interviewprep/recursionbacktracking/fibonaccinumbers/#recursion-fibonacci-numbers","text":"Problem Category: Recursion and Backtracking Difficulty: Easy Given \\(n\\) , calculate the \\(n^{\\text{th}}\\) Fibonacci number. Input: \\(n\\) , the index into the Fibonacci sequence of the value to calculate. \\[ 1 \\leq n \\leq 30 \\] Output: the \\(n^{\\text{th}}\\) Fibonacci number, \\(f(n)\\) : \\[ f(n) = \\left\\{ \\begin{array}{ll} n & 0 \\leq n \\leq 1 \\\\ f(n - 1) + f(n - 2) & n > 1 \\\\ \\end{array} \\right. \\] The Fibonacci sequence is defined recursively, so it is easy to write a recursive function that computes it: f(n): if n <= 1: return n else: return f(n - 1) + f(n - 2) For this problem, that approach suffices. But this wouldn't cut it for large \\(n\\) because it does a lot of redundant work. Consider a call to \\(f(4)\\) : \\[ f(4) \\to \\left\\{ \\begin{array}{ll} f(3) & \\to \\left\\{ \\begin{array}{ll} f(2) & \\to \\left\\{ \\begin{array}{ll} f(1) & \\to 1 \\\\ f(0) & \\to 0 \\\\ \\end{array} \\right. \\\\ f(1) & \\to 1\\\\ \\end{array} \\right. \\\\ f(2) & \\to \\left\\{ \\begin{array}{ll} f(1) & \\to 1 \\\\ f(0) & \\to 0 \\\\ \\end{array} \\right. \\\\ \\end{array} \\right. \\] \\(f(4)\\) calls \\(f(3)\\) once and \\(f(2)\\) once. The result of \\(f(3)\\) is calculated with calls to \\(f(2)\\) and \\(f(1)\\) . Each call to \\(f(2)\\) makes calls to \\(f(1)\\) and \\(f(0)\\) . So to calculate \\(f(4)\\) , we made one call to \\(f(3)\\) , two calls to \\(f(2)\\) , three calls to \\(f(1)\\) , and two calls to \\(f(0)\\) . Why compute \\(f(0)\\) , \\(f(1)\\) , \\(f(2)\\) , or \\(f(3)\\) more than once? As \\(n\\) grows larger, the number of redundant calls to \\(f\\) becomes untenable. A better way to compute \\(f\\) is to start with 0 and 1 and build the sequence up to \\(n\\) . As a bonus, \\(f\\) is a constant-recursive sequence , and it turns out that there is a closed-form formula for the Fibonacci sequence . The formula looks like this: \\[ \\alpha = \\frac{1 + \\sqrt{5}}{2}, \\; \\beta = \\frac{1 - \\sqrt{5}}{2} \\] \\[ f(n) = \\frac{1}{\\sqrt{5}}(\\alpha^n - \\beta^n) \\] It's definitely not obvious that this works. How do we know that \\(f(n)\\) is even an integer after we divide by \\(\\sqrt{5}\\) ? It can be proven by induction. First, we can see that the formula works for \\(n = 0\\) and \\(n = 1\\) : \\[ f(0) = \\frac{1}{\\sqrt{5}}(\\alpha^0 - \\beta^0) = \\frac{1}{\\sqrt{5}}(1 - 1) = \\frac{1}{\\sqrt{5}} 0 = 0 \\] \\[ f(1) = \\frac{1}{\\sqrt{5}}(\\alpha^1 - \\beta^1) = \\frac{1}{\\sqrt{5}}\\left(\\frac{1 + \\sqrt{5}}{2} - \\frac{1 - \\sqrt{5}}{2}\\right) = \\frac{1}{\\sqrt{5}}\\left(\\frac{2\\sqrt{5}}{2}\\right) = 1 \\] Now, for some \\(k \\geq 0\\) , assume the formula holds for \\(k\\) and \\(k + 1\\) : \\[ f(k) = \\frac{1}{\\sqrt{5}}(\\alpha^k - \\beta^k) \\] \\[ f(k + 1) = \\frac{1}{\\sqrt{5}}(\\alpha^{k + 1} - \\beta^{k + 1}) \\] We need to show that it holds for \\(k + 2\\) . The trick is that \\(\\alpha\\) and \\(\\beta\\) are very special numbers: \\(x = \\alpha\\) and \\(x = \\beta\\) are the two solutions of the equation \\(x^2 = x + 1\\) . This means we can substitute \\(\\alpha^2\\) for \\(\\alpha + 1\\) and \\(\\beta^2\\) for \\(\\beta + 1\\) , and this is why the formula works: \\[ \\begin{align*} f(k + 2) & = \\frac{1}{\\sqrt{5}}(\\alpha^{k + 2} - \\beta^{k + 2}) \\\\ & = \\frac{1}{\\sqrt{5}}(\\alpha^2 \\alpha^k - \\beta^2 \\beta^k) \\\\ & = \\frac{1}{\\sqrt{5}}((\\alpha + 1)\\alpha^k - (\\beta + 1)\\beta^k) \\\\ & = \\frac{1}{\\sqrt{5}}(\\alpha^{k + 1} + \\alpha^k - \\beta^{k + 1} - \\beta^k) \\\\ & = \\frac{1}{\\sqrt{5}}(\\alpha^{k + 1} - \\beta^{k + 1}) - \\frac{1}{\\sqrt{5}}(\\alpha^k - \\beta^k) \\\\ & = f(k + 1) + f(k) \\end{align*} \\] \\(f(k + 2) = f(k + 1) + f(k)\\) , so \\(f(k + 2)\\) is the \\((k + 2)^\\text{th}\\) Fibonacci number and the formula is correct. The only issue could be imprecision of using \\(\\sqrt{5}\\) in the computations. Your \\(\\sqrt{5}\\) term might not cancel out correctly and you might be off by one if you truncate to the wrong integer. Here is a version of the formula that always floors to the correct integer: \\[ f(n) = \\left\\lfloor\\frac{1}{\\sqrt{5}}\\left(\\frac{1 + \\sqrt{5}}{2}\\right)^n + \\frac{1}{2}\\right\\rfloor \\] Java 8: public static int fibonacci ( int n ) { int prev = 0 ; int next = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { int temp = prev ; prev = next ; next += temp ; } return next ; } C++: int fibonacci ( int n ) { int prev = 0 ; int next = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { int temp = prev ; prev = next ; next += temp ; } return next ; } Python 3: def fibonacci ( n ): prev , current = 0 , 1 for _ in range ( n - 1 ): prev , current = current , current + prev return current Alternate Python 3 Solution: def fibonacci ( n ): sqrt5 = 5 ** 0.5 phi = ( 1 + sqrt5 ) / 2 return round ( phi ** n / sqrt5 ) Back","title":"Recursion: Fibonacci Numbers"},{"location":"interviewprep/search/icecreamparlor/","text":"Hash Tables: Ice Cream Parlor Problem Category: Search Difficulty: Medium Given a list of flavor costs, find the pair of flavors that requires the given amount of money to buy. Input: an array of costs \\(c[n]\\) , and an integer \\(m\\) , the amount of money. Different flavors can have the same cost. \\[ 2 \\leq m \\leq 10^9 \\] \\[ 2 \\leq n \\leq 5 \\times 10^4 \\] \\[ 1 \\leq c[i] \\leq 10^9 \\; \\; \\forall \\; i \\] Output: two one-based indices that correspond to the two flavors whose costs add up to exactly \\(m\\) . Note that you can assume there is exactly one solution \\((i, j)\\) with \\(i < j\\) and \\(c[i] + c[j] = m\\) . The problem of finding two values in an array that add up to a target value is a popular coding problem. The simplest solution is to read through the array and maintain a set of the values seen so far. Before adding a value \\(c[i]\\) , check the set for its \"complement\" \\(m - c[i]\\) . If some previous \\(c[j]\\) has that value, then a solution has been found. Make sure you search for the complement before adding \\(c[i]\\) to the set, because you might have \\(c[i] = \\frac{m}{2}\\) and \\(c[i] = m - c[i]\\) , where you will incorrectly report that \\(c[i]\\) matches with itself. This version of the problem guarantees that a solution always exists, and it asks for the indices of the solution. Instead of a set, it will be helpful to use a map that maps each cost to its index in \\(c\\) . An interesting property of this problem is that while costs are not unique, there is guaranteed to be a unique solution, which means that if two costs \\(c[i]\\) and \\(c[j]\\) are the same, either they are the only solution ( \\(c[i] = c[j] = \\frac{m}{2}\\) and no other cost is \\(\\frac{m}{2}\\) ) or they are irrelevant to the solution. Therefore, if the same cost occurs multiple times in \\(c\\) , we don't need to worry about which index it maps to in our map. Don't forget to use one-based indices for the answer (which probably involves either storing one-based indices in your map or just adding 1 to each index at the end) and print the lower index first. Java 8: public static void whatFlavors ( List < Integer > cost , int money ) { Map < Integer , Integer > priceToIdx = new HashMap <> (); Iterator < Integer > readCosts = cost . iterator (); int id1 = - 1 ; int id2 = 0 ; while ( readCosts . hasNext () && id1 == - 1 ) { int c = readCosts . next (); if ( priceToIdx . containsKey ( money - c )) { id1 = priceToIdx . get ( money - c ); } else { priceToIdx . put ( c , id2 ); id2 ++ ; } } id1 ++ ; id2 ++ ; System . out . println ( id1 + \" \" + id2 ); } C++: void whatFlavors ( vector < int > cost , int money ) { map < int , int > priceToIdx ; int id1 = -1 ; int id2 = 0 ; auto readCost = cost . begin (); while ( readCost != cost . end () && id1 == -1 ) { auto complement = priceToIdx . find ( money - * readCost ); if ( complement != priceToIdx . end ()) { id1 = complement -> second ; } else { priceToIdx [ * readCost ] = id2 ; id2 ++ ; } readCost ++ ; } id1 ++ ; id2 ++ ; cout << id1 << \" \" << id2 << endl ; } Python 3: def whatFlavors ( cost , money ): price_to_idx = {} id1 , id2 = - 1 , 0 read_cost = iter ( cost ) while id1 == - 1 : c = next ( read_cost ) if money - c in price_to_idx : id1 = price_to_idx [ money - c ] else : price_to_idx [ c ] = id2 id2 += 1 id1 += 1 id2 += 1 print ( id1 , id2 ) Back","title":"Hash Tables: Ice Cream Parlor"},{"location":"interviewprep/search/icecreamparlor/#hash-tables-ice-cream-parlor","text":"Problem Category: Search Difficulty: Medium Given a list of flavor costs, find the pair of flavors that requires the given amount of money to buy. Input: an array of costs \\(c[n]\\) , and an integer \\(m\\) , the amount of money. Different flavors can have the same cost. \\[ 2 \\leq m \\leq 10^9 \\] \\[ 2 \\leq n \\leq 5 \\times 10^4 \\] \\[ 1 \\leq c[i] \\leq 10^9 \\; \\; \\forall \\; i \\] Output: two one-based indices that correspond to the two flavors whose costs add up to exactly \\(m\\) . Note that you can assume there is exactly one solution \\((i, j)\\) with \\(i < j\\) and \\(c[i] + c[j] = m\\) . The problem of finding two values in an array that add up to a target value is a popular coding problem. The simplest solution is to read through the array and maintain a set of the values seen so far. Before adding a value \\(c[i]\\) , check the set for its \"complement\" \\(m - c[i]\\) . If some previous \\(c[j]\\) has that value, then a solution has been found. Make sure you search for the complement before adding \\(c[i]\\) to the set, because you might have \\(c[i] = \\frac{m}{2}\\) and \\(c[i] = m - c[i]\\) , where you will incorrectly report that \\(c[i]\\) matches with itself. This version of the problem guarantees that a solution always exists, and it asks for the indices of the solution. Instead of a set, it will be helpful to use a map that maps each cost to its index in \\(c\\) . An interesting property of this problem is that while costs are not unique, there is guaranteed to be a unique solution, which means that if two costs \\(c[i]\\) and \\(c[j]\\) are the same, either they are the only solution ( \\(c[i] = c[j] = \\frac{m}{2}\\) and no other cost is \\(\\frac{m}{2}\\) ) or they are irrelevant to the solution. Therefore, if the same cost occurs multiple times in \\(c\\) , we don't need to worry about which index it maps to in our map. Don't forget to use one-based indices for the answer (which probably involves either storing one-based indices in your map or just adding 1 to each index at the end) and print the lower index first. Java 8: public static void whatFlavors ( List < Integer > cost , int money ) { Map < Integer , Integer > priceToIdx = new HashMap <> (); Iterator < Integer > readCosts = cost . iterator (); int id1 = - 1 ; int id2 = 0 ; while ( readCosts . hasNext () && id1 == - 1 ) { int c = readCosts . next (); if ( priceToIdx . containsKey ( money - c )) { id1 = priceToIdx . get ( money - c ); } else { priceToIdx . put ( c , id2 ); id2 ++ ; } } id1 ++ ; id2 ++ ; System . out . println ( id1 + \" \" + id2 ); } C++: void whatFlavors ( vector < int > cost , int money ) { map < int , int > priceToIdx ; int id1 = -1 ; int id2 = 0 ; auto readCost = cost . begin (); while ( readCost != cost . end () && id1 == -1 ) { auto complement = priceToIdx . find ( money - * readCost ); if ( complement != priceToIdx . end ()) { id1 = complement -> second ; } else { priceToIdx [ * readCost ] = id2 ; id2 ++ ; } readCost ++ ; } id1 ++ ; id2 ++ ; cout << id1 << \" \" << id2 << endl ; } Python 3: def whatFlavors ( cost , money ): price_to_idx = {} id1 , id2 = - 1 , 0 read_cost = iter ( cost ) while id1 == - 1 : c = next ( read_cost ) if money - c in price_to_idx : id1 = price_to_idx [ money - c ] else : price_to_idx [ c ] = id2 id2 += 1 id1 += 1 id2 += 1 print ( id1 , id2 ) Back","title":"Hash Tables: Ice Cream Parlor"},{"location":"interviewprep/search/minimumtimerequired/","text":"Minimum Time Required Problem Category: Search Difficulty: Medium Given the number of days it takes each machine to produce an item, determine how many days it will take to fulfill an order of items. Input: An array \\(m[n]\\) of machines and a goal \\(g\\) , where the \\(i^\\text{th}\\) machine produces 1 item after every \\(m[i]\\) days. \\[ 1 \\leq n \\leq 10^5 \\] \\[ 1 \\leq g \\leq 10^9 \\] \\[ 1 \\leq m[i] \\leq 10^9 \\; \\; \\forall \\; i \\] Output: the number of days it will take to produce at least \\(g\\) items. The first thing to observe is that, after a given number of days, we can compute how many items each machine has produced so far. Machine \\(i\\) produces an item after each \\(m[i]\\) days, so after \\(d\\) days, \\[ \\text{items}(d) = \\sum_{i=1}^n \\left\\lfloor\\frac{d}{m[i]}\\right\\rfloor \\] We need to search for the day \\(d\\) where the number of items is no longer less than \\(g\\) : \\[ \\text{items}(d - 1) < g \\leq \\text{items}(d) \\] It is easy to compute items \\((d)\\) for any \\(d\\) , but it might seem hard to find this point without just trying \\(d = 1, 2, 3, \\ldots\\) until you find it. A good way to do this is with an exponential search , which is similar to a binary search. The idea is to try \\(d = 1, 2, 4, 8, \\ldots\\) until you find some \\(2^k\\) that has \\(\\text{items}(2^{k - 1}) < g \\leq \\text{items}(2^k)\\) . Then, you do a binary search within the range \\([2^{k - 1}, 2^k]\\) to find the exact value \\(d\\) . Since \\(d\\) could be very large, this is usually significantly faster than a linear search. Java 8: static long minTime ( long [] machines , long goal ) { long target = 1L ; long itemCount = items ( machines , target ); while ( itemCount < goal ) { target *= 2L ; itemCount = items ( machines , target ); } long lowTarget = target / 2L ; long highTarget = target ; while ( lowTarget + 1 < highTarget ) { target = ( highTarget + lowTarget ) / 2L ; itemCount = items ( machines , target ); if ( itemCount < goal ) { lowTarget = target ; } else { highTarget = target ; } } return highTarget ; } private static long items ( long [] machines , long days ) { long result = 0 L ; for ( long machine : machines ) { result += days / machine ; } return result ; } C++: long items ( vector < long > , long ); long minTime ( vector < long > machines , long goal ) { long target = 1L ; long itemCount = items ( machines , target ); while ( itemCount < goal ) { target *= 2L ; itemCount = items ( machines , target ); } long lowTarget = target / 2L ; long highTarget = target ; while ( lowTarget + 1 < highTarget ) { target = ( highTarget + lowTarget ) / 2L ; itemCount = items ( machines , target ); if ( itemCount < goal ) { lowTarget = target ; } else { highTarget = target ; } } return highTarget ; } long items ( vector < long > machines , long days ) { long result = 0L ; for ( auto m = machines . begin (); m != machines . end (); m ++ ) { result += days / * m ; } return result ; } Python 3: def minTime ( machines , goal ): def items ( days ): return sum ( days // m for m in machines ) target = 1 item_count = items ( target ) while item_count < goal : target *= 2 item_count = items ( target ) low_target , high_target = target // 2 , target while low_target + 1 < high_target : target = ( high_target + low_target ) // 2 item_count = items ( target ) if item_count < goal : low_target = target else : high_target = target return high_target Back","title":"Minimum Time Required"},{"location":"interviewprep/search/minimumtimerequired/#minimum-time-required","text":"Problem Category: Search Difficulty: Medium Given the number of days it takes each machine to produce an item, determine how many days it will take to fulfill an order of items. Input: An array \\(m[n]\\) of machines and a goal \\(g\\) , where the \\(i^\\text{th}\\) machine produces 1 item after every \\(m[i]\\) days. \\[ 1 \\leq n \\leq 10^5 \\] \\[ 1 \\leq g \\leq 10^9 \\] \\[ 1 \\leq m[i] \\leq 10^9 \\; \\; \\forall \\; i \\] Output: the number of days it will take to produce at least \\(g\\) items. The first thing to observe is that, after a given number of days, we can compute how many items each machine has produced so far. Machine \\(i\\) produces an item after each \\(m[i]\\) days, so after \\(d\\) days, \\[ \\text{items}(d) = \\sum_{i=1}^n \\left\\lfloor\\frac{d}{m[i]}\\right\\rfloor \\] We need to search for the day \\(d\\) where the number of items is no longer less than \\(g\\) : \\[ \\text{items}(d - 1) < g \\leq \\text{items}(d) \\] It is easy to compute items \\((d)\\) for any \\(d\\) , but it might seem hard to find this point without just trying \\(d = 1, 2, 3, \\ldots\\) until you find it. A good way to do this is with an exponential search , which is similar to a binary search. The idea is to try \\(d = 1, 2, 4, 8, \\ldots\\) until you find some \\(2^k\\) that has \\(\\text{items}(2^{k - 1}) < g \\leq \\text{items}(2^k)\\) . Then, you do a binary search within the range \\([2^{k - 1}, 2^k]\\) to find the exact value \\(d\\) . Since \\(d\\) could be very large, this is usually significantly faster than a linear search. Java 8: static long minTime ( long [] machines , long goal ) { long target = 1L ; long itemCount = items ( machines , target ); while ( itemCount < goal ) { target *= 2L ; itemCount = items ( machines , target ); } long lowTarget = target / 2L ; long highTarget = target ; while ( lowTarget + 1 < highTarget ) { target = ( highTarget + lowTarget ) / 2L ; itemCount = items ( machines , target ); if ( itemCount < goal ) { lowTarget = target ; } else { highTarget = target ; } } return highTarget ; } private static long items ( long [] machines , long days ) { long result = 0 L ; for ( long machine : machines ) { result += days / machine ; } return result ; } C++: long items ( vector < long > , long ); long minTime ( vector < long > machines , long goal ) { long target = 1L ; long itemCount = items ( machines , target ); while ( itemCount < goal ) { target *= 2L ; itemCount = items ( machines , target ); } long lowTarget = target / 2L ; long highTarget = target ; while ( lowTarget + 1 < highTarget ) { target = ( highTarget + lowTarget ) / 2L ; itemCount = items ( machines , target ); if ( itemCount < goal ) { lowTarget = target ; } else { highTarget = target ; } } return highTarget ; } long items ( vector < long > machines , long days ) { long result = 0L ; for ( auto m = machines . begin (); m != machines . end (); m ++ ) { result += days / * m ; } return result ; } Python 3: def minTime ( machines , goal ): def items ( days ): return sum ( days // m for m in machines ) target = 1 item_count = items ( target ) while item_count < goal : target *= 2 item_count = items ( target ) low_target , high_target = target // 2 , target while low_target + 1 < high_target : target = ( high_target + low_target ) // 2 item_count = items ( target ) if item_count < goal : low_target = target else : high_target = target return high_target Back","title":"Minimum Time Required"},{"location":"interviewprep/search/pairs/","text":"Pairs Problem Category: Search Difficulty: Medium Given an array of unique integers and an integer \\(k\\) , count how many pairs of integers there are that are \\(k\\) apart. Input: an array of unique integers \\(a[n]\\) and a target value \\(k\\) . \\[ 2 \\leq n \\leq 10^5 \\] \\[ 1 \\leq k < 10^9 \\] \\[ 1 \\leq a[i] < 2^{31} - 1 \\; \\; \\forall \\; i \\] Output: the number of pairs \\((i, j)\\) such that \\(a[i] - a[j] = k\\) . Since \\(k > 0\\) , \\(i \\neq j\\) for all such pairs. This problem is similar to the classic problem of finding pairs in an array that add to the target value. There are \\({n \\choose 2}\\) possible \\((i, j)\\) pairs, and we need to count the ones for which \\(a[i]\\) and \\(a[j]\\) are \\(k\\) apart. In the sum version of the problem, we iterate over the array and check whether we have seen the \"complement\" of each element, \\(k - a[i]\\) , previously, and we use a set to track which values we have seen. Now, for each \\(a[i]\\) , the complement is \\(a[i] - k\\) : \\[ a[i] - (a[i] - k) = a[i] - a[i] + k = k \\] If \\(a[j] = a[i] - k\\) for some \\(j\\) , then \\((i, j)\\) is a pair that satisfies our condition. An interesting observation about this problem is that for the sum version, if you put all of the integers into a set first and then iterated over the \\(a[i]\\) and checked for each \\(k - a[i]\\) , you would double count every pair: at \\(i\\) you would find \\(a[j] = k - a[i]\\) and count \\((i, j)\\) , and at \\(j\\) you would find \\(a[i] = k - a[j]\\) and count \\((j, i)\\) . Note that that solution works fine if you divide your result by 2. For this problem, the double counting never happens: \\((i, j)\\) and \\((j, i)\\) cannot both satisfy the condition because \\(i \\neq j\\) implies \\(a[i] \\neq a[j]\\) . You can put all of the values into the set up front and the algorithm won't double count the pairs. If you wanted to add each element as you iterate instead, you would miss some of the pairs (the ones with \\(i < j\\) ). You could fix this by searching for both \"complements,\" \\(a[i] - k\\) and \\(a[i] + k\\) , the two values that are \\(k\\) away from \\(a[i]\\) . Java 8: public static int pairs ( int k , List < Integer > arr ) { Set < Integer > set = new HashSet <> ( arr ); int result = 0 ; for ( int val : arr ) { if ( set . contains ( val - k )) { result ++ ; } } return result ; } C++: int pairs ( int k , vector < int > arr ) { set < int > s ( arr . begin (), arr . end ()); int result = 0 ; for ( auto val = arr . begin (); val != arr . end (); val ++ ) { result += s . find ( * val - k ) != s . end (); } return result ; } Python 3: def pairs ( k , arr ): s = set ( arr ) return sum (( v - k ) in s for v in arr ) Back","title":"Pairs"},{"location":"interviewprep/search/pairs/#pairs","text":"Problem Category: Search Difficulty: Medium Given an array of unique integers and an integer \\(k\\) , count how many pairs of integers there are that are \\(k\\) apart. Input: an array of unique integers \\(a[n]\\) and a target value \\(k\\) . \\[ 2 \\leq n \\leq 10^5 \\] \\[ 1 \\leq k < 10^9 \\] \\[ 1 \\leq a[i] < 2^{31} - 1 \\; \\; \\forall \\; i \\] Output: the number of pairs \\((i, j)\\) such that \\(a[i] - a[j] = k\\) . Since \\(k > 0\\) , \\(i \\neq j\\) for all such pairs. This problem is similar to the classic problem of finding pairs in an array that add to the target value. There are \\({n \\choose 2}\\) possible \\((i, j)\\) pairs, and we need to count the ones for which \\(a[i]\\) and \\(a[j]\\) are \\(k\\) apart. In the sum version of the problem, we iterate over the array and check whether we have seen the \"complement\" of each element, \\(k - a[i]\\) , previously, and we use a set to track which values we have seen. Now, for each \\(a[i]\\) , the complement is \\(a[i] - k\\) : \\[ a[i] - (a[i] - k) = a[i] - a[i] + k = k \\] If \\(a[j] = a[i] - k\\) for some \\(j\\) , then \\((i, j)\\) is a pair that satisfies our condition. An interesting observation about this problem is that for the sum version, if you put all of the integers into a set first and then iterated over the \\(a[i]\\) and checked for each \\(k - a[i]\\) , you would double count every pair: at \\(i\\) you would find \\(a[j] = k - a[i]\\) and count \\((i, j)\\) , and at \\(j\\) you would find \\(a[i] = k - a[j]\\) and count \\((j, i)\\) . Note that that solution works fine if you divide your result by 2. For this problem, the double counting never happens: \\((i, j)\\) and \\((j, i)\\) cannot both satisfy the condition because \\(i \\neq j\\) implies \\(a[i] \\neq a[j]\\) . You can put all of the values into the set up front and the algorithm won't double count the pairs. If you wanted to add each element as you iterate instead, you would miss some of the pairs (the ones with \\(i < j\\) ). You could fix this by searching for both \"complements,\" \\(a[i] - k\\) and \\(a[i] + k\\) , the two values that are \\(k\\) away from \\(a[i]\\) . Java 8: public static int pairs ( int k , List < Integer > arr ) { Set < Integer > set = new HashSet <> ( arr ); int result = 0 ; for ( int val : arr ) { if ( set . contains ( val - k )) { result ++ ; } } return result ; } C++: int pairs ( int k , vector < int > arr ) { set < int > s ( arr . begin (), arr . end ()); int result = 0 ; for ( auto val = arr . begin (); val != arr . end (); val ++ ) { result += s . find ( * val - k ) != s . end (); } return result ; } Python 3: def pairs ( k , arr ): s = set ( arr ) return sum (( v - k ) in s for v in arr ) Back","title":"Pairs"},{"location":"interviewprep/search/swapnodes/","text":"Swap Nodes [Algo] Problem Category: Search Difficulty: Medium Given a binary tree and a list of swap queries, report the state of the tree after fulfilling each query. Input: a binary tree with \\(n\\) nodes represented by an \\(n \\times 2\\) array \\(T\\) , and an array \\(q[t]\\) of \\(t\\) queries. Each node \\(i\\) for \\(1 \\leq i \\leq n\\) has left child \\(T_{i, \\ell}\\) and right child \\(T_{i, r}\\) , either of which can be \\(-1\\) if no such child exists. Also, node 1 is the root, and each node has a lower index than its children. \\[ 1 \\leq n \\leq 2^{10} \\] \\[ T_{i, \\ell}, T_{i, r} \\in \\{-1, i + 1, i + 2, \\ldots, n\\} \\; \\; \\forall \\; i \\] \\[ 1 \\leq t \\leq 100 \\] \\[ 1 \\leq q[i] \\leq n \\; \\; \\forall \\; i \\] Output: a list of \\(t\\) inorder traversals of the tree, one after each of the \\(t\\) swap queries is fulfilled. Each swap query \\(k\\) should swap the left and right subtrees of every node whose depth is a multiple of \\(k\\) (the root has depth 1). Each inorder traversal is a list of the nodes 1 through \\(n\\) . If you are not familiar with pre-order, post-order, or inorder traversals, they are useful conventions for doing a depth-first search on a binary tree . Inorder traversal means that for each node you discover, you traverse its entire left subtree first, then add the node to the traversal, and then traverse the entire right subtree. The tree representation given to us in this problem (an \\(n \\times 2\\) array) is nice because we can access any node by index without having to search for it from the root. Still, it would be a pain if, say for a query \\(k = 2\\) , we had to do a breadth-first search to find and swap the children of every node with depth 2, 4, 6, and so on. It would be nice if we could look up the indices of every node with depth \\(k\\) , because if we know that, it is easy to index into the tree and swap the children of each node. Note that swapping never changes a node's parent, so it never changes the depth of any node. I used a table that maps each possible depth 1 through \\(n\\) to the set of nodes at that depth. To populate the sets in this table, you search the tree and calculate each node's depth. Since every node has a lower index than its children, you can use an even simpler dynamic programming approach: set \\(d[1] \\gets 1\\) for the root, and for each node \\(i = 1 \\ldots n\\) , set its children's depths to \\(d[i] + 1\\) . Once you have populated your depth lookup data structure, for each query \\(k\\) and each integer \\(m \\geq 1\\) such that \\(mk \\leq n\\) , you need to look up the set of nodes with depth \\(mk\\) and swap the left and right indices of each. Then, build the inorder traversal of the tree and append it to the output list. The inorder traversal is easiest to implement recursively, as the inorder traversal of any tree is inorderTraversal(left) + root + inorderTraversal(right) . Note that the indices of the given tree are one-based. In Java and C++, I use a copy of the tree that has an extra element at the front so that I can use the one-based index values in the tree to index into the tree itself, but this is definitely not required. Depending on how you handle this, you will probably need to watch out for off-by-one indexing errors. Java 8: public static List < List < Integer >> swapNodes ( List < List < Integer >> indexes , List < Integer > queries ) { int n = indexes . size (); int [][] tree = new int [ n + 1 ][ 2 ] ; int index = 1 ; for ( List < Integer > pair : indexes ) { tree [ index ][ 0 ] = pair . get ( 0 ); tree [ index ][ 1 ] = pair . get ( 1 ); index ++ ; } int [] depths = new int [ n + 1 ] ; List < Set < Integer >> depthLookup = new ArrayList <> (); for ( int i = 0 ; i <= n ; i ++ ) { depthLookup . add ( new HashSet <> ()); } depths [ 1 ] = 1 ; depthLookup . get ( 1 ). add ( 1 ); for ( int i = 1 ; i <= n ; i ++ ) { int left = tree [ i ][ 0 ] ; int right = tree [ i ][ 1 ] ; int nextDepth = depths [ i ] + 1 ; if ( left != - 1 ) { depths [ left ] = nextDepth ; depthLookup . get ( nextDepth ). add ( left ); } if ( right != - 1 ) { depths [ right ] = nextDepth ; depthLookup . get ( nextDepth ). add ( right ); } } List < List < Integer >> result = new LinkedList <> (); for ( int query : queries ) { int k = query ; while ( k <= n ) { for ( int node : depthLookup . get ( k )) { swap ( tree , node ); } k += query ; } List < Integer > traversal = new LinkedList <> (); inorderTraversal ( traversal , tree , 1 ); result . add ( traversal ); } return result ; } private static void swap ( int [][] tree , int node ) { int temp = tree [ node ][ 0 ] ; tree [ node ][ 0 ] = tree [ node ][ 1 ] ; tree [ node ][ 1 ] = temp ; } private static void inorderTraversal ( List < Integer > traversal , int [][] tree , int root ) { if ( root != - 1 ) { inorderTraversal ( traversal , tree , tree [ root ][ 0 ] ); traversal . add ( root ); inorderTraversal ( traversal , tree , tree [ root ][ 1 ] ); } } C++: void inorderTraversal ( vector < int >& , vector < pair < int , int >>& , int ); vector < vector < int >> swapNodes ( vector < vector < int >> indexes , vector < int > queries ) { vector < pair < int , int >> tree ; tree . emplace_back (); for ( auto index = indexes . begin (); index != indexes . end (); index ++ ) { tree . emplace_back ( index -> at ( 0 ), index -> at ( 1 )); } int n = indexes . size (); vector < int > depths ( n + 1 ); vector < set < int >> depthLookup ( n + 1 ); depths [ 1 ] = 1 ; depthLookup [ 1 ]. insert ( 1 ); for ( int i = 1 ; i <= n ; i ++ ) { int left = tree [ i ]. first ; int right = tree [ i ]. second ; int nextDepth = depths [ i ] + 1 ; if ( left != -1 ) { depths [ left ] = nextDepth ; depthLookup [ nextDepth ]. insert ( left ); } if ( right != -1 ) { depths [ right ] = nextDepth ; depthLookup [ nextDepth ]. insert ( right ); } } vector < vector < int >> result ; for ( auto query = queries . begin (); query != queries . end (); query ++ ) { int k = * query ; while ( k <= n ) { set < int >* depthSet = & depthLookup [ k ]; for ( auto node = depthSet -> begin (); node != depthSet -> end (); node ++ ) { swap ( tree [ * node ]. first , tree [ * node ]. second ); } k += * query ; } vector < int > traversal ; inorderTraversal ( traversal , tree , 1 ); result . push_back ( traversal ); } return result ; } void inorderTraversal ( vector < int >& traversal , vector < pair < int , int >>& tree , int root ) { if ( root != -1 ) { inorderTraversal ( traversal , tree , tree [ root ]. first ); traversal . push_back ( root ); inorderTraversal ( traversal , tree , tree [ root ]. second ); } } For Python, the simple recursive implementation of inorder traversal was exceeding the recursion limit for some test cases, so I wrote it without recursion. It's the same idea as the recursive implementation, but instead of handling nodes in the right order with the call stack by making recursive calls in the right order, we are using an explicit stack and pushing node indices onto it. Starting with the root, we make an inorder_push to the stack, which pushes the node and its children in reverse order (right child, parent, left child) so that they will be popped in the correct order. We use a list of boolean flags to keep track of which nodes we have done an inorder_push on. Until the stack is empty and the traversal is complete, we pop each node from the stack and do an inorder_push for that node if we haven't before or append it to the traversal if we have. This method is a bit longer and harder to write than the recursive method, but it scales better for large trees by avoiding making tons of recursive calls. Python 3: def swapNodes ( indexes , queries ): tree = tuple ( indexes ) n = len ( tree ) depths = [ 0 ] * ( n + 1 ) depth_lookup = [ set ()] for _ in depths : depth_lookup . append ( set ()) depths [ 1 ] = 1 depth_lookup [ 1 ] . add ( 1 ) for i , node in enumerate ( tree ): left , right = node next_depth = depths [ i + 1 ] + 1 if left != - 1 : depths [ left ] = next_depth depth_lookup [ next_depth ] . add ( left ) if right != - 1 : depths [ right ] = next_depth depth_lookup [ next_depth ] . add ( right ) result = [] for query in queries : k = query while k <= n : for node in depth_lookup [ k ]: tree [ node - 1 ] . reverse () k += query result . append ( inorder_traversal ( tree )) return result def inorder_traversal ( tree ): visited = [ False ] * ( len ( tree ) + 1 ) stack = [] def inorder_push ( node ): left , right = tree [ node - 1 ] if right != - 1 : stack . append ( right ) stack . append ( node ) if left != - 1 : stack . append ( left ) visited [ node ] = True traversal = [] inorder_push ( 1 ) while stack : node = stack . pop () if visited [ node ]: traversal . append ( node ) else : inorder_push ( node ) return traversal Back","title":"Swap Nodes [Algo]"},{"location":"interviewprep/search/swapnodes/#swap-nodes-algo","text":"Problem Category: Search Difficulty: Medium Given a binary tree and a list of swap queries, report the state of the tree after fulfilling each query. Input: a binary tree with \\(n\\) nodes represented by an \\(n \\times 2\\) array \\(T\\) , and an array \\(q[t]\\) of \\(t\\) queries. Each node \\(i\\) for \\(1 \\leq i \\leq n\\) has left child \\(T_{i, \\ell}\\) and right child \\(T_{i, r}\\) , either of which can be \\(-1\\) if no such child exists. Also, node 1 is the root, and each node has a lower index than its children. \\[ 1 \\leq n \\leq 2^{10} \\] \\[ T_{i, \\ell}, T_{i, r} \\in \\{-1, i + 1, i + 2, \\ldots, n\\} \\; \\; \\forall \\; i \\] \\[ 1 \\leq t \\leq 100 \\] \\[ 1 \\leq q[i] \\leq n \\; \\; \\forall \\; i \\] Output: a list of \\(t\\) inorder traversals of the tree, one after each of the \\(t\\) swap queries is fulfilled. Each swap query \\(k\\) should swap the left and right subtrees of every node whose depth is a multiple of \\(k\\) (the root has depth 1). Each inorder traversal is a list of the nodes 1 through \\(n\\) . If you are not familiar with pre-order, post-order, or inorder traversals, they are useful conventions for doing a depth-first search on a binary tree . Inorder traversal means that for each node you discover, you traverse its entire left subtree first, then add the node to the traversal, and then traverse the entire right subtree. The tree representation given to us in this problem (an \\(n \\times 2\\) array) is nice because we can access any node by index without having to search for it from the root. Still, it would be a pain if, say for a query \\(k = 2\\) , we had to do a breadth-first search to find and swap the children of every node with depth 2, 4, 6, and so on. It would be nice if we could look up the indices of every node with depth \\(k\\) , because if we know that, it is easy to index into the tree and swap the children of each node. Note that swapping never changes a node's parent, so it never changes the depth of any node. I used a table that maps each possible depth 1 through \\(n\\) to the set of nodes at that depth. To populate the sets in this table, you search the tree and calculate each node's depth. Since every node has a lower index than its children, you can use an even simpler dynamic programming approach: set \\(d[1] \\gets 1\\) for the root, and for each node \\(i = 1 \\ldots n\\) , set its children's depths to \\(d[i] + 1\\) . Once you have populated your depth lookup data structure, for each query \\(k\\) and each integer \\(m \\geq 1\\) such that \\(mk \\leq n\\) , you need to look up the set of nodes with depth \\(mk\\) and swap the left and right indices of each. Then, build the inorder traversal of the tree and append it to the output list. The inorder traversal is easiest to implement recursively, as the inorder traversal of any tree is inorderTraversal(left) + root + inorderTraversal(right) . Note that the indices of the given tree are one-based. In Java and C++, I use a copy of the tree that has an extra element at the front so that I can use the one-based index values in the tree to index into the tree itself, but this is definitely not required. Depending on how you handle this, you will probably need to watch out for off-by-one indexing errors. Java 8: public static List < List < Integer >> swapNodes ( List < List < Integer >> indexes , List < Integer > queries ) { int n = indexes . size (); int [][] tree = new int [ n + 1 ][ 2 ] ; int index = 1 ; for ( List < Integer > pair : indexes ) { tree [ index ][ 0 ] = pair . get ( 0 ); tree [ index ][ 1 ] = pair . get ( 1 ); index ++ ; } int [] depths = new int [ n + 1 ] ; List < Set < Integer >> depthLookup = new ArrayList <> (); for ( int i = 0 ; i <= n ; i ++ ) { depthLookup . add ( new HashSet <> ()); } depths [ 1 ] = 1 ; depthLookup . get ( 1 ). add ( 1 ); for ( int i = 1 ; i <= n ; i ++ ) { int left = tree [ i ][ 0 ] ; int right = tree [ i ][ 1 ] ; int nextDepth = depths [ i ] + 1 ; if ( left != - 1 ) { depths [ left ] = nextDepth ; depthLookup . get ( nextDepth ). add ( left ); } if ( right != - 1 ) { depths [ right ] = nextDepth ; depthLookup . get ( nextDepth ). add ( right ); } } List < List < Integer >> result = new LinkedList <> (); for ( int query : queries ) { int k = query ; while ( k <= n ) { for ( int node : depthLookup . get ( k )) { swap ( tree , node ); } k += query ; } List < Integer > traversal = new LinkedList <> (); inorderTraversal ( traversal , tree , 1 ); result . add ( traversal ); } return result ; } private static void swap ( int [][] tree , int node ) { int temp = tree [ node ][ 0 ] ; tree [ node ][ 0 ] = tree [ node ][ 1 ] ; tree [ node ][ 1 ] = temp ; } private static void inorderTraversal ( List < Integer > traversal , int [][] tree , int root ) { if ( root != - 1 ) { inorderTraversal ( traversal , tree , tree [ root ][ 0 ] ); traversal . add ( root ); inorderTraversal ( traversal , tree , tree [ root ][ 1 ] ); } } C++: void inorderTraversal ( vector < int >& , vector < pair < int , int >>& , int ); vector < vector < int >> swapNodes ( vector < vector < int >> indexes , vector < int > queries ) { vector < pair < int , int >> tree ; tree . emplace_back (); for ( auto index = indexes . begin (); index != indexes . end (); index ++ ) { tree . emplace_back ( index -> at ( 0 ), index -> at ( 1 )); } int n = indexes . size (); vector < int > depths ( n + 1 ); vector < set < int >> depthLookup ( n + 1 ); depths [ 1 ] = 1 ; depthLookup [ 1 ]. insert ( 1 ); for ( int i = 1 ; i <= n ; i ++ ) { int left = tree [ i ]. first ; int right = tree [ i ]. second ; int nextDepth = depths [ i ] + 1 ; if ( left != -1 ) { depths [ left ] = nextDepth ; depthLookup [ nextDepth ]. insert ( left ); } if ( right != -1 ) { depths [ right ] = nextDepth ; depthLookup [ nextDepth ]. insert ( right ); } } vector < vector < int >> result ; for ( auto query = queries . begin (); query != queries . end (); query ++ ) { int k = * query ; while ( k <= n ) { set < int >* depthSet = & depthLookup [ k ]; for ( auto node = depthSet -> begin (); node != depthSet -> end (); node ++ ) { swap ( tree [ * node ]. first , tree [ * node ]. second ); } k += * query ; } vector < int > traversal ; inorderTraversal ( traversal , tree , 1 ); result . push_back ( traversal ); } return result ; } void inorderTraversal ( vector < int >& traversal , vector < pair < int , int >>& tree , int root ) { if ( root != -1 ) { inorderTraversal ( traversal , tree , tree [ root ]. first ); traversal . push_back ( root ); inorderTraversal ( traversal , tree , tree [ root ]. second ); } } For Python, the simple recursive implementation of inorder traversal was exceeding the recursion limit for some test cases, so I wrote it without recursion. It's the same idea as the recursive implementation, but instead of handling nodes in the right order with the call stack by making recursive calls in the right order, we are using an explicit stack and pushing node indices onto it. Starting with the root, we make an inorder_push to the stack, which pushes the node and its children in reverse order (right child, parent, left child) so that they will be popped in the correct order. We use a list of boolean flags to keep track of which nodes we have done an inorder_push on. Until the stack is empty and the traversal is complete, we pop each node from the stack and do an inorder_push for that node if we haven't before or append it to the traversal if we have. This method is a bit longer and harder to write than the recursive method, but it scales better for large trees by avoiding making tons of recursive calls. Python 3: def swapNodes ( indexes , queries ): tree = tuple ( indexes ) n = len ( tree ) depths = [ 0 ] * ( n + 1 ) depth_lookup = [ set ()] for _ in depths : depth_lookup . append ( set ()) depths [ 1 ] = 1 depth_lookup [ 1 ] . add ( 1 ) for i , node in enumerate ( tree ): left , right = node next_depth = depths [ i + 1 ] + 1 if left != - 1 : depths [ left ] = next_depth depth_lookup [ next_depth ] . add ( left ) if right != - 1 : depths [ right ] = next_depth depth_lookup [ next_depth ] . add ( right ) result = [] for query in queries : k = query while k <= n : for node in depth_lookup [ k ]: tree [ node - 1 ] . reverse () k += query result . append ( inorder_traversal ( tree )) return result def inorder_traversal ( tree ): visited = [ False ] * ( len ( tree ) + 1 ) stack = [] def inorder_push ( node ): left , right = tree [ node - 1 ] if right != - 1 : stack . append ( right ) stack . append ( node ) if left != - 1 : stack . append ( left ) visited [ node ] = True traversal = [] inorder_push ( 1 ) while stack : node = stack . pop () if visited [ node ]: traversal . append ( node ) else : inorder_push ( node ) return traversal Back","title":"Swap Nodes [Algo]"},{"location":"interviewprep/search/triplesum/","text":"Triple Sum Problem Category: Search Difficulty: Medium Given three arrays, find the number of unique triples ( \\((p, q, r)\\) with one from each array) where the middle value (the one from the second array) is the largest. Input: three arrays \\(a[n_a]\\) , \\(b[n_b]\\) , and \\(c[n_c]\\) , which need not be the same size. \\[ 1 \\leq n_a, n_b, n_c \\leq 10^5 \\] \\[ 1 \\leq a[i], b[i], c[i] \\leq 10^8 \\; \\; \\forall \\; i \\] Output: the number of unique pairs \\((p, q, r)\\) with \\(p \\in a\\) , \\(q \\in b\\) , \\(r \\in c\\) , and \\(p \\leq q \\geq r\\) or \\(q = \\max(p, q, r)\\) . The first useful steps are to sort the arrays and remove any duplicate values. We don't want any duplicates within each array because we are only interested in counting unique \\((p, q, r)\\) triples. Duplicates are generally easiest to remove after sorting, because then any duplicate values will be adjacent to each other. However, you can also just put each array's elements into a set to remove duplicates first. From here, consider each \\(q \\in b\\) . How many \\((p, q, r)\\) triples can we make with that \\(q\\) ? For each \\(p \\in a\\) with \\(p \\leq q\\) , we can take each \\(r \\in c\\) with \\(r \\leq q\\) and make a \\((p, q, r)\\) triple. You can imagine taking the prefix of \\(a\\) with values at most \\(q\\) and the prefix of \\(c\\) with values at most \\(q\\) and taking their cross product (multiplying their lengths). Start with empty prefixes for \\(a\\) and \\(c\\) , and then for each \\(q \\in b\\) , extend the prefixes until they include all values that are less than or equal to \\(q\\) , and then add the product of the prefixes' new lengths to your result. Java 8: static long triplets ( int [] a , int [] b , int [] c ) { Set < Integer > aSet = new TreeSet <> (); Set < Integer > bSet = new TreeSet <> (); Set < Integer > cSet = new TreeSet <> (); for ( int v : a ) { aSet . add ( v ); } for ( int v : b ) { bSet . add ( v ); } for ( int v : c ) { cSet . add ( v ); } List < Integer > aSorted = new ArrayList <> ( aSet ); List < Integer > cSorted = new ArrayList <> ( cSet ); int aIdx = 0 ; int cIdx = 0 ; long result = 0 L ; for ( int v : bSet ) { while ( aIdx < aSorted . size () && aSorted . get ( aIdx ) <= v ) { aIdx ++ ; } while ( cIdx < cSorted . size () && cSorted . get ( cIdx ) <= v ) { cIdx ++ ; } result += ( long ) aIdx * cIdx ; } return result ; } C++: long triplets ( vector < int > a , vector < int > b , vector < int > c ) { sort ( a . begin (), a . end ()); sort ( b . begin (), b . end ()); sort ( c . begin (), c . end ()); a . resize ( distance ( a . begin (), unique ( a . begin (), a . end ()))); b . resize ( distance ( b . begin (), unique ( b . begin (), b . end ()))); c . resize ( distance ( c . begin (), unique ( c . begin (), c . end ()))); int aIdx = 0 ; int cIdx = 0 ; long result = 0L ; for ( auto val = b . begin (); val != b . end (); val ++ ) { while ( aIdx < a . size () && a [ aIdx ] <= * val ) { aIdx ++ ; } while ( cIdx < c . size () && c [ cIdx ] <= * val ) { cIdx ++ ; } result += ( long ) aIdx * cIdx ; } return result ; } Python 3 def triplets ( a , b , c ): a = sorted ( set ( a )) b = sorted ( set ( b )) c = sorted ( set ( c )) a_idx , c_idx = 0 , 0 result = 0 for v in b : while a_idx < len ( a ) and a [ a_idx ] <= v : a_idx += 1 while c_idx < len ( a ) and c [ c_idx ] <= v : c_idx += 1 result += a_idx * c_idx return result Back","title":"Triple Sum"},{"location":"interviewprep/search/triplesum/#triple-sum","text":"Problem Category: Search Difficulty: Medium Given three arrays, find the number of unique triples ( \\((p, q, r)\\) with one from each array) where the middle value (the one from the second array) is the largest. Input: three arrays \\(a[n_a]\\) , \\(b[n_b]\\) , and \\(c[n_c]\\) , which need not be the same size. \\[ 1 \\leq n_a, n_b, n_c \\leq 10^5 \\] \\[ 1 \\leq a[i], b[i], c[i] \\leq 10^8 \\; \\; \\forall \\; i \\] Output: the number of unique pairs \\((p, q, r)\\) with \\(p \\in a\\) , \\(q \\in b\\) , \\(r \\in c\\) , and \\(p \\leq q \\geq r\\) or \\(q = \\max(p, q, r)\\) . The first useful steps are to sort the arrays and remove any duplicate values. We don't want any duplicates within each array because we are only interested in counting unique \\((p, q, r)\\) triples. Duplicates are generally easiest to remove after sorting, because then any duplicate values will be adjacent to each other. However, you can also just put each array's elements into a set to remove duplicates first. From here, consider each \\(q \\in b\\) . How many \\((p, q, r)\\) triples can we make with that \\(q\\) ? For each \\(p \\in a\\) with \\(p \\leq q\\) , we can take each \\(r \\in c\\) with \\(r \\leq q\\) and make a \\((p, q, r)\\) triple. You can imagine taking the prefix of \\(a\\) with values at most \\(q\\) and the prefix of \\(c\\) with values at most \\(q\\) and taking their cross product (multiplying their lengths). Start with empty prefixes for \\(a\\) and \\(c\\) , and then for each \\(q \\in b\\) , extend the prefixes until they include all values that are less than or equal to \\(q\\) , and then add the product of the prefixes' new lengths to your result. Java 8: static long triplets ( int [] a , int [] b , int [] c ) { Set < Integer > aSet = new TreeSet <> (); Set < Integer > bSet = new TreeSet <> (); Set < Integer > cSet = new TreeSet <> (); for ( int v : a ) { aSet . add ( v ); } for ( int v : b ) { bSet . add ( v ); } for ( int v : c ) { cSet . add ( v ); } List < Integer > aSorted = new ArrayList <> ( aSet ); List < Integer > cSorted = new ArrayList <> ( cSet ); int aIdx = 0 ; int cIdx = 0 ; long result = 0 L ; for ( int v : bSet ) { while ( aIdx < aSorted . size () && aSorted . get ( aIdx ) <= v ) { aIdx ++ ; } while ( cIdx < cSorted . size () && cSorted . get ( cIdx ) <= v ) { cIdx ++ ; } result += ( long ) aIdx * cIdx ; } return result ; } C++: long triplets ( vector < int > a , vector < int > b , vector < int > c ) { sort ( a . begin (), a . end ()); sort ( b . begin (), b . end ()); sort ( c . begin (), c . end ()); a . resize ( distance ( a . begin (), unique ( a . begin (), a . end ()))); b . resize ( distance ( b . begin (), unique ( b . begin (), b . end ()))); c . resize ( distance ( c . begin (), unique ( c . begin (), c . end ()))); int aIdx = 0 ; int cIdx = 0 ; long result = 0L ; for ( auto val = b . begin (); val != b . end (); val ++ ) { while ( aIdx < a . size () && a [ aIdx ] <= * val ) { aIdx ++ ; } while ( cIdx < c . size () && c [ cIdx ] <= * val ) { cIdx ++ ; } result += ( long ) aIdx * cIdx ; } return result ; } Python 3 def triplets ( a , b , c ): a = sorted ( set ( a )) b = sorted ( set ( b )) c = sorted ( set ( c )) a_idx , c_idx = 0 , 0 result = 0 for v in b : while a_idx < len ( a ) and a [ a_idx ] <= v : a_idx += 1 while c_idx < len ( a ) and c [ c_idx ] <= v : c_idx += 1 result += a_idx * c_idx return result Back","title":"Triple Sum"},{"location":"interviewprep/sorting/bubblesort/","text":"Sorting: Bubble Sort Problem Category: Sorting Difficulty: Easy Given an array, return how many swaps are needed to sort the array with Bubble Sort. Input: an array \\(a[n]\\) of integers. \\[ 2 \\leq n \\leq 600 \\] \\[ 1 \\leq a[i] \\leq 2 \\times 10^6 \\; \\forall \\; i \\] Output: a message containing the number of swaps needed to sort \\(a\\) , as well as elements \\(a[0]\\) and \\(a[n - 1]\\) after \\(a\\) is sorted. The problem gives you an example implementation of bubble sort, and it suffices to use bubble sort on \\(a\\) and count the number of times you swapped two elements. Java 8: public static void countSwaps ( List < Integer > a ) { final int N = a . size (); Integer [] arr = a . toArray ( new Integer [ N ] ); int swaps = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N - 1 ; j ++ ) { if ( arr [ j ] > arr [ j + 1 ] ) { swaps ++ ; int temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; } } } a . clear (); for ( int val : arr ) { a . add ( val ); } System . out . println ( \"Array is sorted in \" + swaps + \" swaps.\" ); System . out . println ( \"First Element: \" + arr [ 0 ] ); System . out . println ( \"Last Element: \" + arr [ N - 1 ] ); } C++: void countSwaps ( vector < int > a ) { const int n = a . size (); int swaps = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n - 1 ; j ++ ) { if ( a [ j ] > a [ j + 1 ]) { swaps ++ ; int temp = a [ j ]; a [ j ] = a [ j + 1 ]; a [ j + 1 ] = temp ; } } } cout << \"Array is sorted in \" << swaps << \" swaps.\" << endl ; cout << \"First Element: \" << a [ 0 ] << endl ; cout << \"Last Element: \" << a [ n - 1 ] << endl ; } Python 3: def countSwaps ( a ): swaps = 0 for _ in list ( a ): for i in range ( len ( a ) - 1 ): if a [ i ] > a [ i + 1 ]: swaps += 1 a [ i ], a [ i + 1 ] = a [ i + 1 ], a [ i ] print ( \"Array is sorted in\" , swaps , \"swaps.\" ) print ( \"First Element:\" , a [ 0 ]) print ( \"Last Element:\" , a [ - 1 ]) Back","title":"Sorting: Bubble Sort"},{"location":"interviewprep/sorting/bubblesort/#sorting-bubble-sort","text":"Problem Category: Sorting Difficulty: Easy Given an array, return how many swaps are needed to sort the array with Bubble Sort. Input: an array \\(a[n]\\) of integers. \\[ 2 \\leq n \\leq 600 \\] \\[ 1 \\leq a[i] \\leq 2 \\times 10^6 \\; \\forall \\; i \\] Output: a message containing the number of swaps needed to sort \\(a\\) , as well as elements \\(a[0]\\) and \\(a[n - 1]\\) after \\(a\\) is sorted. The problem gives you an example implementation of bubble sort, and it suffices to use bubble sort on \\(a\\) and count the number of times you swapped two elements. Java 8: public static void countSwaps ( List < Integer > a ) { final int N = a . size (); Integer [] arr = a . toArray ( new Integer [ N ] ); int swaps = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N - 1 ; j ++ ) { if ( arr [ j ] > arr [ j + 1 ] ) { swaps ++ ; int temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; } } } a . clear (); for ( int val : arr ) { a . add ( val ); } System . out . println ( \"Array is sorted in \" + swaps + \" swaps.\" ); System . out . println ( \"First Element: \" + arr [ 0 ] ); System . out . println ( \"Last Element: \" + arr [ N - 1 ] ); } C++: void countSwaps ( vector < int > a ) { const int n = a . size (); int swaps = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n - 1 ; j ++ ) { if ( a [ j ] > a [ j + 1 ]) { swaps ++ ; int temp = a [ j ]; a [ j ] = a [ j + 1 ]; a [ j + 1 ] = temp ; } } } cout << \"Array is sorted in \" << swaps << \" swaps.\" << endl ; cout << \"First Element: \" << a [ 0 ] << endl ; cout << \"Last Element: \" << a [ n - 1 ] << endl ; } Python 3: def countSwaps ( a ): swaps = 0 for _ in list ( a ): for i in range ( len ( a ) - 1 ): if a [ i ] > a [ i + 1 ]: swaps += 1 a [ i ], a [ i + 1 ] = a [ i + 1 ], a [ i ] print ( \"Array is sorted in\" , swaps , \"swaps.\" ) print ( \"First Element:\" , a [ 0 ]) print ( \"Last Element:\" , a [ - 1 ]) Back","title":"Sorting: Bubble Sort"},{"location":"interviewprep/sorting/comparator/","text":"Sorting: Comparator Problem Category: Sorting Difficulty: Medium Write a function that can be used as a comparator to sort players by their scores and names. Input: two Player objects \\(a\\) and \\(b\\) . \\(a\\) and \\(b\\) 's names have only lowercase English letters. class Player { string name; int score; } \\[ 0 \\leq a.\\text{score}, b.\\text{score} \\leq 1000 \\] Output: an integer that is: less than 0 if \\(a < b\\) : \\(a\\) scored more points than \\(b\\) , or if they scored the same number of points, \\(a\\) 's name comes before \\(b\\) 's alphabetically. \\(a\\) should come before \\(b\\) in the sorted list of players. 0 if \\(a = b\\) : \\(a\\) and \\(b\\) scored the same number of points and have the same name. more than 0 if \\(a > b\\) : \\(a\\) scored fewer points than \\(b\\) , or if they scored the same number of points, \\(a\\) 's name comes after \\(b\\) 's alphabetically. \\(a\\) should come after \\(b\\) in the sorted list of players. The names are only relevant to the comparison if the players' scores are equal. If \\(a\\) .score \\(\\neq b\\) .score, a good value to return is \\(b\\) .score \\(- a\\) .score. This will be less than 0 if \\(a\\) scored more points than \\(b\\) and more than 0 if \\(a\\) scored fewer points. If \\(a\\) .score \\(= b\\) .score, the problem reduces to comparing \\(a\\) .name and \\(b\\) .name. We want all of the names with a given score to be in their natural, alphabetical ordering, and many languages have string classes with comparators or operators that achieve this for us. For example, Java's String implements Comparable<String> , so it has a compareTo we can use. C++'s string::compare method works similarly. Java 8: public int compare ( Player a , Player b ) { if ( a . score == b . score ) { return a . name . compareTo ( b . name ); } return b . score - a . score ; } Note: as of January 2022, there seems to be a bug in HackerRank's C++ boilerplate code for this problem. It expects your comparator to return -1 if and only if \\(a > b\\) . -1 should signify that \\(a < b\\) , and typically it should be appropriate to return any value less than 0 if \\(a < b\\) . HackerRank provides no boilerplate for C++20, so I copied over the C++ boilerplate and fixed it. C++20: struct Player { int score ; string name ; }; class Checker { public : static int comparator ( Player a , Player b ) { if ( a . score == b . score ) { return a . name . compare ( b . name ); } return b . score - a . score ; } }; bool compare ( Player a , Player b ) { return Checker :: comparator ( a , b ) < 0 ; } int main () { int n ; cin >> n ; vector < Player > players ; for ( int i = 0 ; i < n ; i ++ ) { Player player ; cin >> player . name >> player . score ; players . push_back ( player ); } sort ( players . begin (), players . end (), compare ); for ( auto player = players . begin (); player != players . end (); player ++ ) { cout << player -> name << \" \" << player -> score << endl ; } return 0 ; } Python 3: class Player : def __init__ ( self , name , score ): self . name = name self . score = score def __repr__ ( self ): return f \" { self . name } { self . score } \" def comparator ( a , b ): if a . score == b . score : return - 1 if a . name < b . name else int ( a . name > b . name ) return b . score - a . score Back","title":"Sorting: Comparator"},{"location":"interviewprep/sorting/comparator/#sorting-comparator","text":"Problem Category: Sorting Difficulty: Medium Write a function that can be used as a comparator to sort players by their scores and names. Input: two Player objects \\(a\\) and \\(b\\) . \\(a\\) and \\(b\\) 's names have only lowercase English letters. class Player { string name; int score; } \\[ 0 \\leq a.\\text{score}, b.\\text{score} \\leq 1000 \\] Output: an integer that is: less than 0 if \\(a < b\\) : \\(a\\) scored more points than \\(b\\) , or if they scored the same number of points, \\(a\\) 's name comes before \\(b\\) 's alphabetically. \\(a\\) should come before \\(b\\) in the sorted list of players. 0 if \\(a = b\\) : \\(a\\) and \\(b\\) scored the same number of points and have the same name. more than 0 if \\(a > b\\) : \\(a\\) scored fewer points than \\(b\\) , or if they scored the same number of points, \\(a\\) 's name comes after \\(b\\) 's alphabetically. \\(a\\) should come after \\(b\\) in the sorted list of players. The names are only relevant to the comparison if the players' scores are equal. If \\(a\\) .score \\(\\neq b\\) .score, a good value to return is \\(b\\) .score \\(- a\\) .score. This will be less than 0 if \\(a\\) scored more points than \\(b\\) and more than 0 if \\(a\\) scored fewer points. If \\(a\\) .score \\(= b\\) .score, the problem reduces to comparing \\(a\\) .name and \\(b\\) .name. We want all of the names with a given score to be in their natural, alphabetical ordering, and many languages have string classes with comparators or operators that achieve this for us. For example, Java's String implements Comparable<String> , so it has a compareTo we can use. C++'s string::compare method works similarly. Java 8: public int compare ( Player a , Player b ) { if ( a . score == b . score ) { return a . name . compareTo ( b . name ); } return b . score - a . score ; } Note: as of January 2022, there seems to be a bug in HackerRank's C++ boilerplate code for this problem. It expects your comparator to return -1 if and only if \\(a > b\\) . -1 should signify that \\(a < b\\) , and typically it should be appropriate to return any value less than 0 if \\(a < b\\) . HackerRank provides no boilerplate for C++20, so I copied over the C++ boilerplate and fixed it. C++20: struct Player { int score ; string name ; }; class Checker { public : static int comparator ( Player a , Player b ) { if ( a . score == b . score ) { return a . name . compare ( b . name ); } return b . score - a . score ; } }; bool compare ( Player a , Player b ) { return Checker :: comparator ( a , b ) < 0 ; } int main () { int n ; cin >> n ; vector < Player > players ; for ( int i = 0 ; i < n ; i ++ ) { Player player ; cin >> player . name >> player . score ; players . push_back ( player ); } sort ( players . begin (), players . end (), compare ); for ( auto player = players . begin (); player != players . end (); player ++ ) { cout << player -> name << \" \" << player -> score << endl ; } return 0 ; } Python 3: class Player : def __init__ ( self , name , score ): self . name = name self . score = score def __repr__ ( self ): return f \" { self . name } { self . score } \" def comparator ( a , b ): if a . score == b . score : return - 1 if a . name < b . name else int ( a . name > b . name ) return b . score - a . score Back","title":"Sorting: Comparator"},{"location":"interviewprep/sorting/countinversions/","text":"Sorting: Bubble Sort Problem Category: Sorting Difficulty: Easy Given an array, return how many swaps are needed to sort the array with Bubble Sort. Input: an array \\(a[n]\\) of integers. \\(2 \\leq n \\leq 600\\) \\(1 \\leq a[i] \\leq 2 \\times 10^6 \\; \\forall \\; i\\) Output: a message containing the number of swaps needed to sort \\(a\\) , as well as elements \\(a[0]\\) and \\(a[n - 1]\\) after \\(a\\) is sorted. The problem gives you an example implementation of bubble sort, so it would be easy enough to use bubble sort on \\(a\\) and count the number of times you swapped two elements. The number of times bubble sort swaps two elements is the same as the number of inversions in the array: an inversion occurs whenever any two elements in the array are out of order and the larger one comes first. You can use a merge sort instead of a bubble sort and count the inversions to get the correct number of swaps. Consider merging two sorted arrays \\(l\\) and \\(r\\) : Start with the first elements of \\(l\\) and \\(r\\) : \\(i \\gets 0, j \\gets 0\\) . If \\(l[i] \\leq r[j]\\) , then add \\(l[i]\\) to the merged array and increment \\(i\\) . If \\(l[i] > r[j]\\) , then add \\(r[j]\\) to the merged array and increment \\(j\\) . If \\(i\\) reaches the end of \\(l\\) , add the remaining elements of \\(r\\) to the merged array. If \\(j\\) reaches the end of \\(r\\) , add the remaining elements of \\(l\\) to the merged array. Note that every value in \\(l\\) occurs before every value in \\(r\\) in the original array. When \\(r[j]\\) is placed before \\(l[i]\\) in the merged array, there is an inversion. But if \\(r[j]\\) is in front of \\(l[i]\\) , it will also go in front of the remaining elements in \\(l\\) after \\(i\\) . So when \\(r[j]\\) is added to the merged array, that represents \\(l.\\text{length} - i\\) inversions. A good way to count the total swaps needed to sort the array is to write a recursive merge sort function that returns the number of swaps made. This way, you can split the array into left and right halves, sum up the swaps incurred by each recursive call, and then add the the number of swaps counted when merging the two sorted arrays. Java 8: static long countInversions(int[] arr) { return mergeSort(Arrays.copyOf(arr, arr.length), 0, arr.length); } private static long mergeSort(int[] arr, int start, int end) { if (start >= end - 1) { return 0; } int mid = (start + end) / 2; long swaps = mergeSort(arr, start, mid); swaps += mergeSort(arr, mid, end); int[] temp = new int[end - start]; int i = start; int j = mid; int pos = 0; while (i < mid && j < end) { if (arr[i] <= arr[j]) { temp[pos] = arr[i]; i++; } else { swaps += mid - i; temp[pos] = arr[j]; j++; } pos++; } while (i < mid) { temp[pos] = arr[i]; i++; pos++; } while (j < end) { temp[pos] = arr[j]; j++; pos++; } for (int k = 0; k < temp.length; k++) { arr[start + k] = temp[k]; } return swaps; } C++: int mergeSort(vector<int>&, int, int); void countSwaps(vector<int> a) { const int n = a.size(); int swaps = mergeSort(a, 0, n); cout << \"Array is sorted in \" << swaps << \" swaps.\" << endl; cout << \"First Element: \" << a[0] << endl; cout << \"Last Element: \" << a[n - 1] << endl; } int mergeSort(vector<int>& a, int start, int end) { if (start >= end - 1) { return 0; } const int mid = (start + end) / 2; int swaps = mergeSort(a, start, mid); swaps += mergeSort(a, mid, end); vector<int> temp; int i = start; int j = mid; while (i < mid && j < end) { if (a[i] <= a[j]) { temp.push_back(a[i]); i++; } else { swaps += mid - i; temp.push_back(a[j]); j++; } } while (i < mid) { temp.push_back(a[i]); i++; } while (j < end) { temp.push_back(a[j]); j++; } for (int k = 0; k < temp.size(); k++) { a[start + k] = temp[k]; } return swaps; } Python 3: def countSwaps(a): swaps = mergeSort(a) print(\"Array is sorted in\", swaps, \"swaps.\") print(\"First Element:\", a[0]) print(\"Last Element:\", a[-1]) def mergeSort(a): if len(a) <= 1: return 0 mid = len(a) // 2 left = a[:mid] right = a[mid:] swaps = mergeSort(left) + mergeSort(right) i = 0 j = 0 a.clear() while i < len(left) and j < len(right): if left[i] <= right[j]: a.append(left[i]) i += 1 else: swaps += len(left) - i a.append(right[j]) j += 1 a.extend(left[i:]) a.extend(right[j:]) return swaps Back","title":"Sorting: Bubble Sort"},{"location":"interviewprep/sorting/countinversions/#sorting-bubble-sort","text":"Problem Category: Sorting Difficulty: Easy Given an array, return how many swaps are needed to sort the array with Bubble Sort. Input: an array \\(a[n]\\) of integers. \\(2 \\leq n \\leq 600\\) \\(1 \\leq a[i] \\leq 2 \\times 10^6 \\; \\forall \\; i\\) Output: a message containing the number of swaps needed to sort \\(a\\) , as well as elements \\(a[0]\\) and \\(a[n - 1]\\) after \\(a\\) is sorted. The problem gives you an example implementation of bubble sort, so it would be easy enough to use bubble sort on \\(a\\) and count the number of times you swapped two elements. The number of times bubble sort swaps two elements is the same as the number of inversions in the array: an inversion occurs whenever any two elements in the array are out of order and the larger one comes first. You can use a merge sort instead of a bubble sort and count the inversions to get the correct number of swaps. Consider merging two sorted arrays \\(l\\) and \\(r\\) : Start with the first elements of \\(l\\) and \\(r\\) : \\(i \\gets 0, j \\gets 0\\) . If \\(l[i] \\leq r[j]\\) , then add \\(l[i]\\) to the merged array and increment \\(i\\) . If \\(l[i] > r[j]\\) , then add \\(r[j]\\) to the merged array and increment \\(j\\) . If \\(i\\) reaches the end of \\(l\\) , add the remaining elements of \\(r\\) to the merged array. If \\(j\\) reaches the end of \\(r\\) , add the remaining elements of \\(l\\) to the merged array. Note that every value in \\(l\\) occurs before every value in \\(r\\) in the original array. When \\(r[j]\\) is placed before \\(l[i]\\) in the merged array, there is an inversion. But if \\(r[j]\\) is in front of \\(l[i]\\) , it will also go in front of the remaining elements in \\(l\\) after \\(i\\) . So when \\(r[j]\\) is added to the merged array, that represents \\(l.\\text{length} - i\\) inversions. A good way to count the total swaps needed to sort the array is to write a recursive merge sort function that returns the number of swaps made. This way, you can split the array into left and right halves, sum up the swaps incurred by each recursive call, and then add the the number of swaps counted when merging the two sorted arrays. Java 8: static long countInversions(int[] arr) { return mergeSort(Arrays.copyOf(arr, arr.length), 0, arr.length); } private static long mergeSort(int[] arr, int start, int end) { if (start >= end - 1) { return 0; } int mid = (start + end) / 2; long swaps = mergeSort(arr, start, mid); swaps += mergeSort(arr, mid, end); int[] temp = new int[end - start]; int i = start; int j = mid; int pos = 0; while (i < mid && j < end) { if (arr[i] <= arr[j]) { temp[pos] = arr[i]; i++; } else { swaps += mid - i; temp[pos] = arr[j]; j++; } pos++; } while (i < mid) { temp[pos] = arr[i]; i++; pos++; } while (j < end) { temp[pos] = arr[j]; j++; pos++; } for (int k = 0; k < temp.length; k++) { arr[start + k] = temp[k]; } return swaps; } C++: int mergeSort(vector<int>&, int, int); void countSwaps(vector<int> a) { const int n = a.size(); int swaps = mergeSort(a, 0, n); cout << \"Array is sorted in \" << swaps << \" swaps.\" << endl; cout << \"First Element: \" << a[0] << endl; cout << \"Last Element: \" << a[n - 1] << endl; } int mergeSort(vector<int>& a, int start, int end) { if (start >= end - 1) { return 0; } const int mid = (start + end) / 2; int swaps = mergeSort(a, start, mid); swaps += mergeSort(a, mid, end); vector<int> temp; int i = start; int j = mid; while (i < mid && j < end) { if (a[i] <= a[j]) { temp.push_back(a[i]); i++; } else { swaps += mid - i; temp.push_back(a[j]); j++; } } while (i < mid) { temp.push_back(a[i]); i++; } while (j < end) { temp.push_back(a[j]); j++; } for (int k = 0; k < temp.size(); k++) { a[start + k] = temp[k]; } return swaps; } Python 3: def countSwaps(a): swaps = mergeSort(a) print(\"Array is sorted in\", swaps, \"swaps.\") print(\"First Element:\", a[0]) print(\"Last Element:\", a[-1]) def mergeSort(a): if len(a) <= 1: return 0 mid = len(a) // 2 left = a[:mid] right = a[mid:] swaps = mergeSort(left) + mergeSort(right) i = 0 j = 0 a.clear() while i < len(left) and j < len(right): if left[i] <= right[j]: a.append(left[i]) i += 1 else: swaps += len(left) - i a.append(right[j]) j += 1 a.extend(left[i:]) a.extend(right[j:]) return swaps Back","title":"Sorting: Bubble Sort"},{"location":"interviewprep/sorting/fraudactivitynotifications/","text":"Fraudulent Activity Notifications Problem Category: Sorting Difficulty: Medium Given a list of a client's expenditures for each day, determine how many potential fraud alerts should be issued to them. Input: an array \\(x[n]\\) of the expenditures of each day for \\(n\\) days, and a number of trailing days to consider, \\(d\\) . \\[ 1 \\leq d \\leq n \\leq 2 \\times 10^5 \\] \\[ 0 \\leq x[i] \\leq 200 \\; \\forall \\; i \\] Output: the number of times a potential fraud notification should have been issued. A potential fraud notification is issued if a day's expenditures are at least \\(2m\\) , where \\(m\\) is the median of the previous \\(d\\) days' expenditures. On each day \\(i\\) , we care about how \\(x[i]\\) compares to the median of the previous \\(d\\) days, from \\(i - 1\\) to \\(i - d\\) . For the next day, we will need a new median, with day \\(i\\) replacing the day that was previously \\(d\\) days ago. If we have a list of \\(d\\) numbers and change one of them arbitrarily, it is hard to know exactly how the median will change without recomputing it from scratch. The expenditures only range from 0 to 200. Consider a table \\(f(v)\\) that stores the frequency of each value. Let the table only counts the frequencies over the previous \\(d\\) days: \\[ \\sum_{i=0}^{200} f(i) = d \\] How would you find the median value over the previous \\(d\\) days with this table? It is easy to find the median of a sorted list: it is the middle entry if \\(d\\) is odd and the average of the two middle entries if \\(d\\) is even. It is possible to use the table to recreate a sorted list of the previous \\(d\\) days, but it is also possible to compute the median from the table directly. The middle entry is the lowest value \\(m\\) for which the cumulative sum \\(\\sum_{i=0}^m f(i) > \\lfloor\\frac{d}{2}\\rfloor\\) . Note that you will need the average of two middle values if \\(d\\) is even, but the two middle values might be the same. The lower middle value \\(m^-\\) is the highest value for which the sum is less than \\(\\lfloor\\frac{d}{2}\\rfloor\\) , and the higher middle value \\(m^+\\) is \\(m\\) as before. You only need to compute a median if \\(d\\) days have past, and to update the table, you increment \\(f(x[i])\\) and decrement \\(f(x[i - d])\\) . Java 8: static int activityNotifications ( int [] expenditure , int d ) { Map < Integer , Integer > counts = new TreeMap <> (); int result = 0 ; for ( int i = 0 ; i < expenditure . length ; i ++ ) { if ( i >= d ) { if ( expenditure [ i ] >= Math . round ( 2.0 * median ( counts , d ))) { result ++ ; } counts . put ( expenditure [ i - d ] , counts . get ( expenditure [ i - d ] ) - 1 ); } counts . put ( expenditure [ i ] , counts . getOrDefault ( expenditure [ i ] , 0 ) + 1 ); } return result ; } private static double median ( Map < Integer , Integer > counts , int d ) { int total = 0 ; int low = 0 ; int high = 0 ; Iterator < Integer > iter = counts . keySet (). iterator (); int i = iter . next (); while ( total <= d / 2 ) { high = i ; if ( total < d / 2 ) { low = i ; } total += counts . get ( i ); i = iter . next (); } return d % 2 == 0 ? ( high + low ) / 2.0 : high ; } C++: double median ( map < int , int >& , int ); int activityNotifications ( vector < int > expenditure , int d ) { map < int , int > counts ; int result = 0 ; for ( int i = 0 ; i < expenditure . size (); i ++ ) { if ( i >= d ) { result += expenditure [ i ] >= round ( 2.0 * median ( counts , d )); counts [ expenditure [ i - d ]] -- ; } counts [ expenditure [ i ]] ++ ; } return result ; } double median ( map < int , int >& counts , int d ) { int total = 0 ; int high = 0 ; int low = 0 ; int i = 0 ; while ( total <= d / 2 ) { high = i ; if ( total < d / 2 ) { low = i ; } total += counts [ i ]; i ++ ; } return d % 2 ? high : ( high + low ) / 2.0 ; } Python 3: def activityNotifications ( expenditure , d ): def median ( counts , d ): total = 0 high , low = 0 , 0 i = 0 while total <= d // 2 : high = i if total < d // 2 : low = i total += counts . get ( i , 0 ) i += 1 return high if d % 2 else ( high + low ) / 2 counts = {} result = 0 for i , exp in enumerate ( expenditure ): if i >= d : if exp >= round ( 2 * median ( counts , d )): result += 1 counts [ expenditure [ i - d ]] -= 1 counts [ exp ] = counts . get ( exp , 0 ) + 1 return result Back","title":"Fraudulent Activity Notifications"},{"location":"interviewprep/sorting/fraudactivitynotifications/#fraudulent-activity-notifications","text":"Problem Category: Sorting Difficulty: Medium Given a list of a client's expenditures for each day, determine how many potential fraud alerts should be issued to them. Input: an array \\(x[n]\\) of the expenditures of each day for \\(n\\) days, and a number of trailing days to consider, \\(d\\) . \\[ 1 \\leq d \\leq n \\leq 2 \\times 10^5 \\] \\[ 0 \\leq x[i] \\leq 200 \\; \\forall \\; i \\] Output: the number of times a potential fraud notification should have been issued. A potential fraud notification is issued if a day's expenditures are at least \\(2m\\) , where \\(m\\) is the median of the previous \\(d\\) days' expenditures. On each day \\(i\\) , we care about how \\(x[i]\\) compares to the median of the previous \\(d\\) days, from \\(i - 1\\) to \\(i - d\\) . For the next day, we will need a new median, with day \\(i\\) replacing the day that was previously \\(d\\) days ago. If we have a list of \\(d\\) numbers and change one of them arbitrarily, it is hard to know exactly how the median will change without recomputing it from scratch. The expenditures only range from 0 to 200. Consider a table \\(f(v)\\) that stores the frequency of each value. Let the table only counts the frequencies over the previous \\(d\\) days: \\[ \\sum_{i=0}^{200} f(i) = d \\] How would you find the median value over the previous \\(d\\) days with this table? It is easy to find the median of a sorted list: it is the middle entry if \\(d\\) is odd and the average of the two middle entries if \\(d\\) is even. It is possible to use the table to recreate a sorted list of the previous \\(d\\) days, but it is also possible to compute the median from the table directly. The middle entry is the lowest value \\(m\\) for which the cumulative sum \\(\\sum_{i=0}^m f(i) > \\lfloor\\frac{d}{2}\\rfloor\\) . Note that you will need the average of two middle values if \\(d\\) is even, but the two middle values might be the same. The lower middle value \\(m^-\\) is the highest value for which the sum is less than \\(\\lfloor\\frac{d}{2}\\rfloor\\) , and the higher middle value \\(m^+\\) is \\(m\\) as before. You only need to compute a median if \\(d\\) days have past, and to update the table, you increment \\(f(x[i])\\) and decrement \\(f(x[i - d])\\) . Java 8: static int activityNotifications ( int [] expenditure , int d ) { Map < Integer , Integer > counts = new TreeMap <> (); int result = 0 ; for ( int i = 0 ; i < expenditure . length ; i ++ ) { if ( i >= d ) { if ( expenditure [ i ] >= Math . round ( 2.0 * median ( counts , d ))) { result ++ ; } counts . put ( expenditure [ i - d ] , counts . get ( expenditure [ i - d ] ) - 1 ); } counts . put ( expenditure [ i ] , counts . getOrDefault ( expenditure [ i ] , 0 ) + 1 ); } return result ; } private static double median ( Map < Integer , Integer > counts , int d ) { int total = 0 ; int low = 0 ; int high = 0 ; Iterator < Integer > iter = counts . keySet (). iterator (); int i = iter . next (); while ( total <= d / 2 ) { high = i ; if ( total < d / 2 ) { low = i ; } total += counts . get ( i ); i = iter . next (); } return d % 2 == 0 ? ( high + low ) / 2.0 : high ; } C++: double median ( map < int , int >& , int ); int activityNotifications ( vector < int > expenditure , int d ) { map < int , int > counts ; int result = 0 ; for ( int i = 0 ; i < expenditure . size (); i ++ ) { if ( i >= d ) { result += expenditure [ i ] >= round ( 2.0 * median ( counts , d )); counts [ expenditure [ i - d ]] -- ; } counts [ expenditure [ i ]] ++ ; } return result ; } double median ( map < int , int >& counts , int d ) { int total = 0 ; int high = 0 ; int low = 0 ; int i = 0 ; while ( total <= d / 2 ) { high = i ; if ( total < d / 2 ) { low = i ; } total += counts [ i ]; i ++ ; } return d % 2 ? high : ( high + low ) / 2.0 ; } Python 3: def activityNotifications ( expenditure , d ): def median ( counts , d ): total = 0 high , low = 0 , 0 i = 0 while total <= d // 2 : high = i if total < d // 2 : low = i total += counts . get ( i , 0 ) i += 1 return high if d % 2 else ( high + low ) / 2 counts = {} result = 0 for i , exp in enumerate ( expenditure ): if i >= d : if exp >= round ( 2 * median ( counts , d )): result += 1 counts [ expenditure [ i - d ]] -= 1 counts [ exp ] = counts . get ( exp , 0 ) + 1 return result Back","title":"Fraudulent Activity Notifications"},{"location":"interviewprep/sorting/markandtoys/","text":"Mark and Toys Problem Category: Sorting Difficulty: Easy Given prices of toys and a budget, determine the greatest number of toys that can be bought. Input: an array \\(p[n]\\) of prices of toys, and a budget \\(k\\) . \\[ 1 \\leq n \\leq 10^5 \\] \\[ 1 \\leq k \\leq 10^9 \\] \\[ 1 \\leq p[i] \\leq 10^9 \\; \\forall \\; i \\] Output: the greatest number of toys that can be bought with \\(k\\) units of currency. For prices \\(p_1, \\ldots, p_n\\) , we are trying to pick toys \\(I \\subseteq \\{1, \\ldots, n\\}\\) with maximum \\(|I|\\) such that: \\[ \\sum_{i \\in I} p_i \\leq k \\] To maximize the number of toys purchased, you can use a greedy algorithm to always buy the cheapest toys possible. Sort \\(p\\) from lowest to highest and read through the prices, subtracting each one from the budget. Once the budget or list of prices runs out, the number of toys bought is the correct answer. The greedy approach works because maximumToys \\((p, \\cdot)\\) is monotonic: for any \\(j \\leq k\\) , you can buy at least as many toys from \\(p\\) with \\(k\\) units of currency as you can with \\(j\\) units of currency. Choosing the cheapest toy leaves the greatest amount of currency remaining, which means you can buy the greatest number of toys possible out of the remaining options. Java 8: public static int maximumToys ( List < Integer > prices , int k ) { final int N = prices . size (); Integer [] p = prices . toArray ( new Integer [ N ] ); Arrays . sort ( p ); int toys = 0 ; while ( toys < N && p [ toys ] <= k ) { k -= p [ toys ] ; toys ++ ; } return toys ; } C++: int maximumToys ( vector < int > prices , int k ) { vector < int > p = prices ; sort ( p . begin (), p . end ()); const int n = p . size (); int toys = 0 ; while ( toys < n && p [ toys ] <= k ) { k -= p [ toys ]; toys ++ ; } return toys ; } Python 3: def maximumToys ( prices , k ): toys = 0 for toy in sorted ( prices ): if k >= toy : k -= toy toys += 1 else : return toys return toys Back","title":"Mark and Toys"},{"location":"interviewprep/sorting/markandtoys/#mark-and-toys","text":"Problem Category: Sorting Difficulty: Easy Given prices of toys and a budget, determine the greatest number of toys that can be bought. Input: an array \\(p[n]\\) of prices of toys, and a budget \\(k\\) . \\[ 1 \\leq n \\leq 10^5 \\] \\[ 1 \\leq k \\leq 10^9 \\] \\[ 1 \\leq p[i] \\leq 10^9 \\; \\forall \\; i \\] Output: the greatest number of toys that can be bought with \\(k\\) units of currency. For prices \\(p_1, \\ldots, p_n\\) , we are trying to pick toys \\(I \\subseteq \\{1, \\ldots, n\\}\\) with maximum \\(|I|\\) such that: \\[ \\sum_{i \\in I} p_i \\leq k \\] To maximize the number of toys purchased, you can use a greedy algorithm to always buy the cheapest toys possible. Sort \\(p\\) from lowest to highest and read through the prices, subtracting each one from the budget. Once the budget or list of prices runs out, the number of toys bought is the correct answer. The greedy approach works because maximumToys \\((p, \\cdot)\\) is monotonic: for any \\(j \\leq k\\) , you can buy at least as many toys from \\(p\\) with \\(k\\) units of currency as you can with \\(j\\) units of currency. Choosing the cheapest toy leaves the greatest amount of currency remaining, which means you can buy the greatest number of toys possible out of the remaining options. Java 8: public static int maximumToys ( List < Integer > prices , int k ) { final int N = prices . size (); Integer [] p = prices . toArray ( new Integer [ N ] ); Arrays . sort ( p ); int toys = 0 ; while ( toys < N && p [ toys ] <= k ) { k -= p [ toys ] ; toys ++ ; } return toys ; } C++: int maximumToys ( vector < int > prices , int k ) { vector < int > p = prices ; sort ( p . begin (), p . end ()); const int n = p . size (); int toys = 0 ; while ( toys < n && p [ toys ] <= k ) { k -= p [ toys ]; toys ++ ; } return toys ; } Python 3: def maximumToys ( prices , k ): toys = 0 for toy in sorted ( prices ): if k >= toy : k -= toy toys += 1 else : return toys return toys Back","title":"Mark and Toys"},{"location":"interviewprep/stringmanipulation/alternatingcharacters/","text":"Alternating Characters Problem Category: String Manipulation Difficulty: Easy Given two strings of A's and B's, determine the minimum number of character deletions required to make the string have alternating characters. Input: a string \\(s\\) of which every character is 'A' or 'B' . \\[ 1 \\leq |s| \\leq 10^5 \\] Output: the minimum number of character deletions required to make \\(s\\) have no two consecutive A's or B's in a row (such that it follows the pattern \"ABAB...\" or \"BABA...\" ). If we delete every character that matches the character before it, that is sufficient to leave \\(s\\) with alternating characters. There is no need to actually modify the string or build a new string, because we only need to count how many times a character \\(s[i]\\) matches the character before it, \\(s[i - 1]\\) . Java 8: public static int alternatingCharacters ( String s ) { int deletions = 0 ; for ( int i = 1 ; i < s . length (); i ++ ) { if ( s . charAt ( i ) == s . charAt ( i - 1 )) { deletions ++ ; } } return deletions ; } C++: int alternatingCharacters ( string s ) { int deletions = 0 ; for ( int i = 1 ; i < s . size (); i ++ ) { deletions += s [ i ] == s [ i - 1 ]; } return deletions ; } Python 3: def alternatingCharacters ( s ): return sum ( s [ i ] == s [ i - 1 ] for i in range ( 1 , len ( s ))) Back","title":"Alternating Characters"},{"location":"interviewprep/stringmanipulation/alternatingcharacters/#alternating-characters","text":"Problem Category: String Manipulation Difficulty: Easy Given two strings of A's and B's, determine the minimum number of character deletions required to make the string have alternating characters. Input: a string \\(s\\) of which every character is 'A' or 'B' . \\[ 1 \\leq |s| \\leq 10^5 \\] Output: the minimum number of character deletions required to make \\(s\\) have no two consecutive A's or B's in a row (such that it follows the pattern \"ABAB...\" or \"BABA...\" ). If we delete every character that matches the character before it, that is sufficient to leave \\(s\\) with alternating characters. There is no need to actually modify the string or build a new string, because we only need to count how many times a character \\(s[i]\\) matches the character before it, \\(s[i - 1]\\) . Java 8: public static int alternatingCharacters ( String s ) { int deletions = 0 ; for ( int i = 1 ; i < s . length (); i ++ ) { if ( s . charAt ( i ) == s . charAt ( i - 1 )) { deletions ++ ; } } return deletions ; } C++: int alternatingCharacters ( string s ) { int deletions = 0 ; for ( int i = 1 ; i < s . size (); i ++ ) { deletions += s [ i ] == s [ i - 1 ]; } return deletions ; } Python 3: def alternatingCharacters ( s ): return sum ( s [ i ] == s [ i - 1 ] for i in range ( 1 , len ( s ))) Back","title":"Alternating Characters"},{"location":"interviewprep/stringmanipulation/commonchild/","text":"Common Child Problem Category: String Manipulation Difficulty: Medium Given two strings, determine the length of the longest string that can be constructed from both by only deleting letters. Input: two strings \\(s_1\\) and \\(s_2\\) of uppercase English letters. \\[ 1 \\leq |s_1|, |s_2| \\leq 5000 \\] Output: the length of the longest string that is a child of both \\(s_1\\) and \\(s_2\\) . A string \\(s'\\) is a child of another string \\(s\\) if you can construct \\(s'\\) by deleting any number of characters from \\(s\\) . For example, \"ABACUS\" and \"CRABCAKE\" share a common child \"ABC\" . Note that we can delete as many letters as we want from anywhere in the string to produce a child, but we cannot rearrange or replace any of the letters. A good way to solve this problem is with dynamic programming. Suppose you already know how long the longest possible common child of \\(s_1\\) and \\(s_2\\) is, and I add the letter A to the end of \\(s_1\\) . What happened to the length of the longest common child now? It could be the same as it was before, or it could be one longer, since we might be able to use that A in \\(s_1\\) to make a longer common child. How do we know if we can do that? It depends on whether there is an instance of the longest common child in \\(s_2\\) that has an A after its last character. Let \\(m = |s_1|\\) , \\(n = |s_2|\\) , and \\(A\\) be an \\((m + 1) \\times (n + 1)\\) matrix with entries \\(A_{0,0} \\ldots A_{m,n}\\) . Let \\(A_{i,j}\\) be the length of the longest common child that can be made using only the first \\(i\\) characters of \\(s_1\\) and the first \\(j\\) characters of \\(s_2\\) . If \\(i\\) or \\(j\\) is 0, then we can't use any characters from one of the strings, so the longest common child is length 0: \\[ \\begin{align*} A_{i,0} & \\gets 0 \\; \\; \\forall \\; 0 \\leq i \\leq m \\\\ A_{0,j} & \\gets 0 \\; \\; \\forall \\; 0 \\leq j \\leq n \\end{align*} \\] To compute \\(A_{i,j}\\) , we need to compare the \\(i^\\text{th}\\) character of \\(s_1\\) to the \\(j^\\text{th}\\) character of \\(s_2\\) . If they are the same, then we know this character can be added to the end of any common child of the first \\(i - 1\\) characters of \\(s_1\\) and the first \\(j - 1\\) characters of \\(s_2\\) . Therefore, we should take \\(A_{i,j} \\gets A_{i-1,j-1} + 1\\) . Otherwise, the \\(i^\\text{th}\\) character of \\(s_1\\) or the \\(j^\\text{th}\\) character of \\(s_2\\) (but not both) could still contribute to the longest common child. We take the first \\(i - 1\\) characters of \\(s_1\\) and the first \\(j - 1\\) characters of \\(s_2\\) and consider adding either the \\(i^\\text{th}\\) character of \\(s_1\\) or the \\(j^\\text{th}\\) character of \\(s_2\\) . These options give us common children of length \\(A_{i,j-1}\\) and \\(A_{i-1,j}\\) , so we should take whichever is larger to be the value of \\(A_{i,j}\\) . \\[ A_{i,j} \\gets \\left\\{ \\begin{array}{ll} A_{i-1,j-1} + 1 & \\text{if} \\; s_1[i] = s_2[j] \\\\ \\max(A_{i,j-1}, A_{i-1,j}) & \\text{if} \\; s_1[i] \\neq s_2[j] \\end{array} \\right. \\] After calculating the entire matrix, the answer is \\(A_{m,n}\\) , the length of the longest common child that considers all \\(m\\) characters of \\(s_1\\) and all \\(n\\) characters of \\(s_2\\) . Java 8: static int commonChild ( String s1 , String s2 ) { int m = s1 . length (); int n = s2 . length (); int [][] dp = new int [ m + 1 ][ n + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( s1 . charAt ( i - 1 ) == s2 . charAt ( j - 1 )) { dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] + 1 ; } else { dp [ i ][ j ] = Math . max ( dp [ i ][ j - 1 ] , dp [ i - 1 ][ j ] ); } } } return dp [ m ][ n ] ; } C++: int commonChild ( string s1 , string s2 ) { int m = s1 . size (); int n = s2 . size (); int ** dp = new int * [ m + 1 ]; for ( int i = 0 ; i <= m ; i ++ ) { dp [ i ] = new int [ n + 1 ]; dp [ 0 ][ i ] = 0 ; dp [ i ][ 0 ] = 0 ; } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( s1 [ i - 1 ] == s2 [ j - 1 ]) { dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] + 1 ; } else { dp [ i ][ j ] = max ( dp [ i - 1 ][ j ], dp [ i ][ j - 1 ]); } } } return dp [ m ][ n ]; } It was actually pretty difficult to get this solution to run fast enough to pass the test cases for Python 3. I think this solution barely passes (it fails if you replace dp1[j] = dp1[j - 1] if dp1[j - 1] > dp0[j] else dp0[j] with dp1[j] = max(dp1[j - 1], dp0[j]) ). It might be easier just to switch your language from Python 3 to Pypy 3, which is more likely to run your code fast enough to pass its test cases. I also used a fairly common space optimization that I didn't use in the other implementations or describe above: I only store two rows of the matrix at a time (the current row \\(i\\) and the previous row \\(i - 1\\) ). If you are calculating the entries of \\(A\\) in row-major order (as in \\(A_{1,1}\\) through \\(A_{1,n}\\) , then \\(A_{2,1}\\) through \\(A_{2,n}\\) , and so on), once you calculate an entire row, you no longer need any of the rows above it to compute subsequent rows. Python 3: def commonChild ( s1 , s2 ): m , n = len ( s1 ), len ( s2 ) dp0 = [ 0 ] * ( n + 1 ) dp1 = [ 0 ] * ( n + 1 ) for i in range ( 1 , m + 1 ): for j in range ( 1 , n + 1 ): if s1 [ i - 1 ] == s2 [ j - 1 ]: dp1 [ j ] = dp0 [ j - 1 ] + 1 else : dp1 [ j ] = dp1 [ j - 1 ] if dp1 [ j - 1 ] > dp0 [ j ] else dp0 [ j ] dp0 , dp1 = dp1 , dp0 return dp0 [ n ] Back","title":"Common Child"},{"location":"interviewprep/stringmanipulation/commonchild/#common-child","text":"Problem Category: String Manipulation Difficulty: Medium Given two strings, determine the length of the longest string that can be constructed from both by only deleting letters. Input: two strings \\(s_1\\) and \\(s_2\\) of uppercase English letters. \\[ 1 \\leq |s_1|, |s_2| \\leq 5000 \\] Output: the length of the longest string that is a child of both \\(s_1\\) and \\(s_2\\) . A string \\(s'\\) is a child of another string \\(s\\) if you can construct \\(s'\\) by deleting any number of characters from \\(s\\) . For example, \"ABACUS\" and \"CRABCAKE\" share a common child \"ABC\" . Note that we can delete as many letters as we want from anywhere in the string to produce a child, but we cannot rearrange or replace any of the letters. A good way to solve this problem is with dynamic programming. Suppose you already know how long the longest possible common child of \\(s_1\\) and \\(s_2\\) is, and I add the letter A to the end of \\(s_1\\) . What happened to the length of the longest common child now? It could be the same as it was before, or it could be one longer, since we might be able to use that A in \\(s_1\\) to make a longer common child. How do we know if we can do that? It depends on whether there is an instance of the longest common child in \\(s_2\\) that has an A after its last character. Let \\(m = |s_1|\\) , \\(n = |s_2|\\) , and \\(A\\) be an \\((m + 1) \\times (n + 1)\\) matrix with entries \\(A_{0,0} \\ldots A_{m,n}\\) . Let \\(A_{i,j}\\) be the length of the longest common child that can be made using only the first \\(i\\) characters of \\(s_1\\) and the first \\(j\\) characters of \\(s_2\\) . If \\(i\\) or \\(j\\) is 0, then we can't use any characters from one of the strings, so the longest common child is length 0: \\[ \\begin{align*} A_{i,0} & \\gets 0 \\; \\; \\forall \\; 0 \\leq i \\leq m \\\\ A_{0,j} & \\gets 0 \\; \\; \\forall \\; 0 \\leq j \\leq n \\end{align*} \\] To compute \\(A_{i,j}\\) , we need to compare the \\(i^\\text{th}\\) character of \\(s_1\\) to the \\(j^\\text{th}\\) character of \\(s_2\\) . If they are the same, then we know this character can be added to the end of any common child of the first \\(i - 1\\) characters of \\(s_1\\) and the first \\(j - 1\\) characters of \\(s_2\\) . Therefore, we should take \\(A_{i,j} \\gets A_{i-1,j-1} + 1\\) . Otherwise, the \\(i^\\text{th}\\) character of \\(s_1\\) or the \\(j^\\text{th}\\) character of \\(s_2\\) (but not both) could still contribute to the longest common child. We take the first \\(i - 1\\) characters of \\(s_1\\) and the first \\(j - 1\\) characters of \\(s_2\\) and consider adding either the \\(i^\\text{th}\\) character of \\(s_1\\) or the \\(j^\\text{th}\\) character of \\(s_2\\) . These options give us common children of length \\(A_{i,j-1}\\) and \\(A_{i-1,j}\\) , so we should take whichever is larger to be the value of \\(A_{i,j}\\) . \\[ A_{i,j} \\gets \\left\\{ \\begin{array}{ll} A_{i-1,j-1} + 1 & \\text{if} \\; s_1[i] = s_2[j] \\\\ \\max(A_{i,j-1}, A_{i-1,j}) & \\text{if} \\; s_1[i] \\neq s_2[j] \\end{array} \\right. \\] After calculating the entire matrix, the answer is \\(A_{m,n}\\) , the length of the longest common child that considers all \\(m\\) characters of \\(s_1\\) and all \\(n\\) characters of \\(s_2\\) . Java 8: static int commonChild ( String s1 , String s2 ) { int m = s1 . length (); int n = s2 . length (); int [][] dp = new int [ m + 1 ][ n + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( s1 . charAt ( i - 1 ) == s2 . charAt ( j - 1 )) { dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] + 1 ; } else { dp [ i ][ j ] = Math . max ( dp [ i ][ j - 1 ] , dp [ i - 1 ][ j ] ); } } } return dp [ m ][ n ] ; } C++: int commonChild ( string s1 , string s2 ) { int m = s1 . size (); int n = s2 . size (); int ** dp = new int * [ m + 1 ]; for ( int i = 0 ; i <= m ; i ++ ) { dp [ i ] = new int [ n + 1 ]; dp [ 0 ][ i ] = 0 ; dp [ i ][ 0 ] = 0 ; } for ( int i = 1 ; i <= m ; i ++ ) { for ( int j = 1 ; j <= n ; j ++ ) { if ( s1 [ i - 1 ] == s2 [ j - 1 ]) { dp [ i ][ j ] = dp [ i - 1 ][ j - 1 ] + 1 ; } else { dp [ i ][ j ] = max ( dp [ i - 1 ][ j ], dp [ i ][ j - 1 ]); } } } return dp [ m ][ n ]; } It was actually pretty difficult to get this solution to run fast enough to pass the test cases for Python 3. I think this solution barely passes (it fails if you replace dp1[j] = dp1[j - 1] if dp1[j - 1] > dp0[j] else dp0[j] with dp1[j] = max(dp1[j - 1], dp0[j]) ). It might be easier just to switch your language from Python 3 to Pypy 3, which is more likely to run your code fast enough to pass its test cases. I also used a fairly common space optimization that I didn't use in the other implementations or describe above: I only store two rows of the matrix at a time (the current row \\(i\\) and the previous row \\(i - 1\\) ). If you are calculating the entries of \\(A\\) in row-major order (as in \\(A_{1,1}\\) through \\(A_{1,n}\\) , then \\(A_{2,1}\\) through \\(A_{2,n}\\) , and so on), once you calculate an entire row, you no longer need any of the rows above it to compute subsequent rows. Python 3: def commonChild ( s1 , s2 ): m , n = len ( s1 ), len ( s2 ) dp0 = [ 0 ] * ( n + 1 ) dp1 = [ 0 ] * ( n + 1 ) for i in range ( 1 , m + 1 ): for j in range ( 1 , n + 1 ): if s1 [ i - 1 ] == s2 [ j - 1 ]: dp1 [ j ] = dp0 [ j - 1 ] + 1 else : dp1 [ j ] = dp1 [ j - 1 ] if dp1 [ j - 1 ] > dp0 [ j ] else dp0 [ j ] dp0 , dp1 = dp1 , dp0 return dp0 [ n ] Back","title":"Common Child"},{"location":"interviewprep/stringmanipulation/makinganagrams/","text":"Strings: Making Anagrams Problem Category: String Manipulation Difficulty: Easy Given two strings, determine the minimum number of character deletions required to make the strings anagrams of each other. Input: two strings \\(a\\) and \\(b\\) of lowercase English letters. \\[ 1 \\leq |a|, |b| \\leq 10^4 \\] Output: the minimum number of character deletions required (total character deletions from \\(a\\) and \\(b\\) ) to make \\(a\\) and \\(b\\) anagrams (the letters of \\(a\\) can be rearranged to create \\(b\\) , and vice versa). For this problem, it is useful to create frequency tables that store how many instances of each letter occur in \\(a\\) and \\(b\\) . Two strings are anagrams of each other if their frequency tables are the same. For example, \"hello\" and \"leloh\" are anagrams because both strings contain 1 'h' , 1 'e' , 2 'l' s, and 1 'o' . If \\(a\\) and \\(b\\) have the same frequencies for a letter \\(c\\) , then no instances of \\(c\\) need to be deleted from either string. However, if they do not have the same number of \\(c\\) 's, then the string with more \\(c\\) 's needs to delete some instances until both strings have the same number. Let \\(c_a\\) and \\(c_b\\) be the number of instances of character \\(c \\in [\\text{a-z}]\\) in \\(a\\) and \\(b\\) respectively. The minimum number of deletions needed \\(d\\) is: \\[ d = \\sum_{c \\in [\\text{a-z}]} |c_a - c_b| \\] You can use maps for your frequency tables, or you can simply use arrays of 26 integers because the characters are limited to lowercase letters. With maps, it would be easier to extend your solution to allow more characters. Java 8: public static int makeAnagram ( String a , String b ) { Map < Character , Integer > aFreqMap = new HashMap <> (); Map < Character , Integer > bFreqMap = new HashMap <> (); for ( int i = 0 ; i < a . length (); i ++ ) { char ch = a . charAt ( i ); aFreqMap . put ( ch , aFreqMap . getOrDefault ( ch , 0 ) + 1 ); } for ( int i = 0 ; i < b . length (); i ++ ) { char ch = b . charAt ( i ); bFreqMap . put ( ch , bFreqMap . getOrDefault ( ch , 0 ) + 1 ); } int deletions = 0 ; for ( char ch = 'a' ; ch <= 'z' ; ch ++ ) { int aFreq = aFreqMap . getOrDefault ( ch , 0 ); int bFreq = bFreqMap . getOrDefault ( ch , 0 ); deletions += Math . abs ( aFreq - bFreq ); } return deletions ; } C++: int makeAnagram ( string a , string b ) { map < char , int > aFreqMap , bFreqMap ; for ( auto ch = a . begin (); ch != a . end (); ch ++ ) { aFreqMap [ * ch ] ++ ; } for ( auto ch = b . begin (); ch != b . end (); ch ++ ) { bFreqMap [ * ch ] ++ ; } int deletions = 0 ; for ( char ch = 'a' ; ch <= 'z' ; ch ++ ) { deletions += abs ( aFreqMap [ ch ] - bFreqMap [ ch ]); } return deletions ; } Python 3: def makeAnagram ( a , b ): letters = set ( a ) | set ( b ) a_freq = { ch : 0 for ch in letters } b_freq = { ch : 0 for ch in letters } for ch in a : a_freq [ ch ] += 1 for ch in b : b_freq [ ch ] += 1 deletions = 0 for ch in letters : deletions += abs ( a_freq [ ch ] - b_freq [ ch ]) return deletions Back","title":"Strings: Making Anagrams"},{"location":"interviewprep/stringmanipulation/makinganagrams/#strings-making-anagrams","text":"Problem Category: String Manipulation Difficulty: Easy Given two strings, determine the minimum number of character deletions required to make the strings anagrams of each other. Input: two strings \\(a\\) and \\(b\\) of lowercase English letters. \\[ 1 \\leq |a|, |b| \\leq 10^4 \\] Output: the minimum number of character deletions required (total character deletions from \\(a\\) and \\(b\\) ) to make \\(a\\) and \\(b\\) anagrams (the letters of \\(a\\) can be rearranged to create \\(b\\) , and vice versa). For this problem, it is useful to create frequency tables that store how many instances of each letter occur in \\(a\\) and \\(b\\) . Two strings are anagrams of each other if their frequency tables are the same. For example, \"hello\" and \"leloh\" are anagrams because both strings contain 1 'h' , 1 'e' , 2 'l' s, and 1 'o' . If \\(a\\) and \\(b\\) have the same frequencies for a letter \\(c\\) , then no instances of \\(c\\) need to be deleted from either string. However, if they do not have the same number of \\(c\\) 's, then the string with more \\(c\\) 's needs to delete some instances until both strings have the same number. Let \\(c_a\\) and \\(c_b\\) be the number of instances of character \\(c \\in [\\text{a-z}]\\) in \\(a\\) and \\(b\\) respectively. The minimum number of deletions needed \\(d\\) is: \\[ d = \\sum_{c \\in [\\text{a-z}]} |c_a - c_b| \\] You can use maps for your frequency tables, or you can simply use arrays of 26 integers because the characters are limited to lowercase letters. With maps, it would be easier to extend your solution to allow more characters. Java 8: public static int makeAnagram ( String a , String b ) { Map < Character , Integer > aFreqMap = new HashMap <> (); Map < Character , Integer > bFreqMap = new HashMap <> (); for ( int i = 0 ; i < a . length (); i ++ ) { char ch = a . charAt ( i ); aFreqMap . put ( ch , aFreqMap . getOrDefault ( ch , 0 ) + 1 ); } for ( int i = 0 ; i < b . length (); i ++ ) { char ch = b . charAt ( i ); bFreqMap . put ( ch , bFreqMap . getOrDefault ( ch , 0 ) + 1 ); } int deletions = 0 ; for ( char ch = 'a' ; ch <= 'z' ; ch ++ ) { int aFreq = aFreqMap . getOrDefault ( ch , 0 ); int bFreq = bFreqMap . getOrDefault ( ch , 0 ); deletions += Math . abs ( aFreq - bFreq ); } return deletions ; } C++: int makeAnagram ( string a , string b ) { map < char , int > aFreqMap , bFreqMap ; for ( auto ch = a . begin (); ch != a . end (); ch ++ ) { aFreqMap [ * ch ] ++ ; } for ( auto ch = b . begin (); ch != b . end (); ch ++ ) { bFreqMap [ * ch ] ++ ; } int deletions = 0 ; for ( char ch = 'a' ; ch <= 'z' ; ch ++ ) { deletions += abs ( aFreqMap [ ch ] - bFreqMap [ ch ]); } return deletions ; } Python 3: def makeAnagram ( a , b ): letters = set ( a ) | set ( b ) a_freq = { ch : 0 for ch in letters } b_freq = { ch : 0 for ch in letters } for ch in a : a_freq [ ch ] += 1 for ch in b : b_freq [ ch ] += 1 deletions = 0 for ch in letters : deletions += abs ( a_freq [ ch ] - b_freq [ ch ]) return deletions Back","title":"Strings: Making Anagrams"},{"location":"interviewprep/stringmanipulation/sherlockvalidstring/","text":"Sherlock and the Valid String Problem Category: String Manipulation Difficulty: Medium Given a string, determine whether either every character in the string occurs an equal number of times, or one character could be deleted to achieve this condition. Input: a string \\(s\\) of lowercase English letters. \\[ 1 \\leq |s| \\leq 10^5 \\] Output: the string \"YES\" if every letter in \\(s\\) occurs with the same frequency, or if they would all occur with the same frequency if a single character was deleted, otherwise the string \"NO\". We can make a table of the frequency of each letter a-z in \\(s\\) , and then we need to check whether the values in that table meet the condition. The answer is Yes if and only if at least one of these conditions holds for some \\(k\\) : the frequency of every letter in \\(s\\) is \\(k\\) the frequency of every letter in \\(s\\) is \\(k\\) except for one letter, which has frequency \\(k + 1\\) the frequency of every letter in \\(s\\) is \\(k\\) except for one letter, which has frequency 1 Note that deleting an instance of a letter with \\(k + 1\\) instances causes all letters to have frequency \\(k\\) , but so does removing a letter with frequency 1, as that would remove the letter from consideration. It is possible to check this condition with one pass over the values of the table by keeping some properties in mind: If you find 3 distinct values, the answer is No. If every value is the same and there is only one distinct value, the answer is Yes. If you find two values that are the same, that must be the common frequency. If you find 2 distinct values with a difference of more than 1, then the answer is No, unless one of the values is 1 (in which case, that value must be deleted). My solutions keep a couple flags and check several conditions in order to output No as soon as the condition becomes impossible to satisfy. However, as there can only be at most 26 frequency values in your table, it is fine to make many more passes over the values to achieve a simpler solution. Java 8: public static String isValid ( String s ) { Map < Character , Integer > freq = new HashMap <> (); for ( int i = 0 ; i < s . length (); i ++ ) { char ch = s . charAt ( i ); freq . put ( ch , freq . getOrDefault ( ch , 0 ) + 1 ); } boolean foundRemoval = false ; boolean foundMatch = false ; int commonFreq = 0 ; for ( int value : freq . values ()) { if ( commonFreq == 0 ) { commonFreq = value ; } else if ( commonFreq == value ) { foundMatch = true ; } else { if ( foundRemoval ) { return \"NO\" ; } if ( value - 1 == commonFreq || value == 1 ) { foundRemoval = true ; } else if (( value + 1 == commonFreq || commonFreq == 1 ) && ! foundMatch ) { commonFreq = value ; foundMatch = true ; foundRemoval = true ; } else { return \"NO\" ; } } } return \"YES\" ; } C++: string isValid ( string s ) { map < char , int > freq ; for ( auto ch = s . begin (); ch != s . end (); ch ++ ) { freq [ * ch ] ++ ; } bool foundRemoval = false ; bool foundMatch = false ; int commonFreq = 0 ; for ( auto it = freq . begin (); it != freq . end (); it ++ ) { int value = it -> second ; if ( ! commonFreq ) { commonFreq = value ; } else if ( commonFreq == value ) { foundMatch = true ; } else { if ( foundRemoval ) { return \"NO\" ; } if ( value - 1 == commonFreq || value == 1 ) { foundRemoval = true ; } else if (( value + 1 == commonFreq || commonFreq == 1 ) && ! foundMatch ) { commonFreq = value ; foundMatch = true ; foundRemoval = true ; } else { return \"NO\" ; } } } return \"YES\" ; } Python 3: def isValid ( s ): freq = {} for ch in s : freq [ ch ] = freq . get ( ch , 0 ) + 1 found_removal = False found_match = False common_freq = 0 for v in freq . values (): if not common_freq : common_freq = v elif common_freq == v : found_match = True else : if found_removal : return \"NO\" if v - 1 == common_freq or v == 1 : found_removal = True elif ( v + 1 == common_freq or common_freq == 1 ) and not found_match : common_freq = v found_match = True found_removal = True else : return \"NO\" return \"YES\" Alternate Python 3 Solution: def isValid ( s ): freq = {} for ch in s : freq [ ch ] = freq . get ( ch , 0 ) + 1 values = tuple ( freq . values ()) value_count = len ( set ( values )) if value_count >= 3 : return \"NO\" if value_count <= 1 : return \"YES\" v1 , v2 = tuple ( set ( values )) value_freqs = { v : values . count ( v ) for v in ( v1 , v2 )} required_freq = len ( freq ) - 1 v1_match = value_freqs [ v1 ] == required_freq v2_match = value_freqs [ v2 ] == required_freq v1_remove = value_freqs [ v1 ] == 1 and ( v1 in ( 1 , v2 + 1 )) v2_remove = value_freqs [ v2 ] == 1 and ( v2 in ( 1 , v1 + 1 )) return \"YES\" if v1_match and v2_remove or v2_match and v1_remove else \"NO\" Back","title":"Sherlock and the Valid String"},{"location":"interviewprep/stringmanipulation/sherlockvalidstring/#sherlock-and-the-valid-string","text":"Problem Category: String Manipulation Difficulty: Medium Given a string, determine whether either every character in the string occurs an equal number of times, or one character could be deleted to achieve this condition. Input: a string \\(s\\) of lowercase English letters. \\[ 1 \\leq |s| \\leq 10^5 \\] Output: the string \"YES\" if every letter in \\(s\\) occurs with the same frequency, or if they would all occur with the same frequency if a single character was deleted, otherwise the string \"NO\". We can make a table of the frequency of each letter a-z in \\(s\\) , and then we need to check whether the values in that table meet the condition. The answer is Yes if and only if at least one of these conditions holds for some \\(k\\) : the frequency of every letter in \\(s\\) is \\(k\\) the frequency of every letter in \\(s\\) is \\(k\\) except for one letter, which has frequency \\(k + 1\\) the frequency of every letter in \\(s\\) is \\(k\\) except for one letter, which has frequency 1 Note that deleting an instance of a letter with \\(k + 1\\) instances causes all letters to have frequency \\(k\\) , but so does removing a letter with frequency 1, as that would remove the letter from consideration. It is possible to check this condition with one pass over the values of the table by keeping some properties in mind: If you find 3 distinct values, the answer is No. If every value is the same and there is only one distinct value, the answer is Yes. If you find two values that are the same, that must be the common frequency. If you find 2 distinct values with a difference of more than 1, then the answer is No, unless one of the values is 1 (in which case, that value must be deleted). My solutions keep a couple flags and check several conditions in order to output No as soon as the condition becomes impossible to satisfy. However, as there can only be at most 26 frequency values in your table, it is fine to make many more passes over the values to achieve a simpler solution. Java 8: public static String isValid ( String s ) { Map < Character , Integer > freq = new HashMap <> (); for ( int i = 0 ; i < s . length (); i ++ ) { char ch = s . charAt ( i ); freq . put ( ch , freq . getOrDefault ( ch , 0 ) + 1 ); } boolean foundRemoval = false ; boolean foundMatch = false ; int commonFreq = 0 ; for ( int value : freq . values ()) { if ( commonFreq == 0 ) { commonFreq = value ; } else if ( commonFreq == value ) { foundMatch = true ; } else { if ( foundRemoval ) { return \"NO\" ; } if ( value - 1 == commonFreq || value == 1 ) { foundRemoval = true ; } else if (( value + 1 == commonFreq || commonFreq == 1 ) && ! foundMatch ) { commonFreq = value ; foundMatch = true ; foundRemoval = true ; } else { return \"NO\" ; } } } return \"YES\" ; } C++: string isValid ( string s ) { map < char , int > freq ; for ( auto ch = s . begin (); ch != s . end (); ch ++ ) { freq [ * ch ] ++ ; } bool foundRemoval = false ; bool foundMatch = false ; int commonFreq = 0 ; for ( auto it = freq . begin (); it != freq . end (); it ++ ) { int value = it -> second ; if ( ! commonFreq ) { commonFreq = value ; } else if ( commonFreq == value ) { foundMatch = true ; } else { if ( foundRemoval ) { return \"NO\" ; } if ( value - 1 == commonFreq || value == 1 ) { foundRemoval = true ; } else if (( value + 1 == commonFreq || commonFreq == 1 ) && ! foundMatch ) { commonFreq = value ; foundMatch = true ; foundRemoval = true ; } else { return \"NO\" ; } } } return \"YES\" ; } Python 3: def isValid ( s ): freq = {} for ch in s : freq [ ch ] = freq . get ( ch , 0 ) + 1 found_removal = False found_match = False common_freq = 0 for v in freq . values (): if not common_freq : common_freq = v elif common_freq == v : found_match = True else : if found_removal : return \"NO\" if v - 1 == common_freq or v == 1 : found_removal = True elif ( v + 1 == common_freq or common_freq == 1 ) and not found_match : common_freq = v found_match = True found_removal = True else : return \"NO\" return \"YES\" Alternate Python 3 Solution: def isValid ( s ): freq = {} for ch in s : freq [ ch ] = freq . get ( ch , 0 ) + 1 values = tuple ( freq . values ()) value_count = len ( set ( values )) if value_count >= 3 : return \"NO\" if value_count <= 1 : return \"YES\" v1 , v2 = tuple ( set ( values )) value_freqs = { v : values . count ( v ) for v in ( v1 , v2 )} required_freq = len ( freq ) - 1 v1_match = value_freqs [ v1 ] == required_freq v2_match = value_freqs [ v2 ] == required_freq v1_remove = value_freqs [ v1 ] == 1 and ( v1 in ( 1 , v2 + 1 )) v2_remove = value_freqs [ v2 ] == 1 and ( v2 in ( 1 , v1 + 1 )) return \"YES\" if v1_match and v2_remove or v2_match and v1_remove else \"NO\" Back","title":"Sherlock and the Valid String"},{"location":"interviewprep/stringmanipulation/specialstringagain/","text":"Special String Again Problem Category: String Manipulation Difficulty: Medium Given a string, determine the number of \"special\" substrings it contains. Input: a string \\(s\\) of \\(n\\) lowercase English letters. \\[ 1 \\leq n \\leq 10^6 \\] Output: the number of \"special\" substrings of \\(s\\) . A string is special if, for some letter \\(c \\in [\\text{a-z}]\\) , one of the following is true: Every character is \\(c\\) The length is odd, every character before the middle character is \\(c\\) , and every character after the middle character is \\(c\\) . For example, \"aaabaaa\" . The middle character does not have to be \\(c\\) You might define that a string \\(s\\) of length \\(n\\) is special if and only if there exists a \\(c \\in [\\text{a-z}]\\) such that: \\[ i < \\left\\lfloor\\frac{n}{2}\\right\\rfloor \\; \\lor \\; i \\geq \\left\\lceil\\frac{n}{2}\\right\\rceil \\implies s[i] = c \\] where if \\(n\\) is even, every character has to be \\(c\\) , but if \\(n\\) is odd, there is a middle character we can ignore. Note that each character by itself counts as a special substring of length 1. A natural solution would be to start at each character \\(c_i\\) and look forwards and backwards in the string to see how many special substrings there are with \\(c_i\\) at the center. You would need to be careful about counting the number of substrings of consecutive runs like aaaa correctly. A good approach would be to count backwards from each character the number of consecutive matching characters. However, there is a way to avoid these extra passes forward and backward in the array and solve the problem in linear time. You can use two arrays of length \\(n\\) : \\(p^-_i\\) counts the length of a consecutive run of \\(c_i\\) up to index \\(i\\) \\(p^+_i\\) counts the length of a consecutive run of \\(c_i\\) that starts at index \\(i\\) For example, for \\(s =\\) \"aaabaabc\" : s = a a a b a a b c p- = [1, 2, 3, 1, 1, 2, 1, 1] p+ = [3, 2, 1, 1, 2, 1, 1, 1] \\(p^-\\) and \\(p^+\\) can each be built with a forward and backward pass over \\(s\\) , respectively. Once you have stored this information, you can make an additional pass over \\(s\\) which counts all special substrings. For each \\(0 \\leq i < n\\) : Add \\(p^-_i\\) to the result. This counts special substrings where every character is the same. Count how many special strings have position \\(i\\) at the center. If there are matching characters before and after \\(i\\) that are not \\(c_i\\) ( \\(c_{i-1} = c_{i+1} = c' \\neq c_i\\) ), then there is at least one. \\(p^-_{i-1}\\) is the number of consecutive instances of \\(c'\\) right before \\(i\\) , and \\(p^+_{i+1}\\) is the number of consecutive instances of \\(c'\\) right after \\(i\\) , so the minimum of these values is the number of special substrings to count. Java 8: static long substrCount ( int n , String s ) { long result = 0 L ; int [] preConsecutive = new int [ n ] ; int [] postConsecutive = new int [ n ] ; preConsecutive [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i - 1 ) == s . charAt ( i )) { preConsecutive [ i ] = preConsecutive [ i - 1 ] + 1 ; } else { preConsecutive [ i ] = 1 ; } } postConsecutive [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( s . charAt ( i ) == s . charAt ( i + 1 )) { postConsecutive [ i ] = postConsecutive [ i + 1 ] + 1 ; } else { postConsecutive [ i ] = 1 ; } } for ( int i = 0 ; i < n ; i ++ ) { result += preConsecutive [ i ] ; if ( i > 0 && i + 1 < n && s . charAt ( i - 1 ) == s . charAt ( i + 1 ) && s . charAt ( i - 1 ) != s . charAt ( i )) { int pre = preConsecutive [ i - 1 ] ; int post = postConsecutive [ i + 1 ] ; result += Math . min ( pre , post ); } } return result ; } C++: long substrCount ( int n , string s ) { int * preConsecutive = new int [ n ]; int * postConsecutive = new int [ n ]; preConsecutive [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { preConsecutive [ i ] = 1 ; if ( s [ i - 1 ] == s [ i ]) { preConsecutive [ i ] += preConsecutive [ i - 1 ]; } } postConsecutive [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { postConsecutive [ i ] = 1 ; if ( s [ i ] == s [ i + 1 ]) { postConsecutive [ i ] += postConsecutive [ i + 1 ]; } } long result = 0L ; for ( int i = 0 ; i < n ; i ++ ) { result += preConsecutive [ i ]; if ( i > 0 && i + 1 < n && s [ i - 1 ] != s [ i ] && s [ i - 1 ] == s [ i + 1 ]) { result += min ( preConsecutive [ i - 1 ], postConsecutive [ i + 1 ]); } } return result ; } Python 3: def substrCount ( n , s ): pre = [ 1 ] * n post = [ 1 ] * n for i in range ( 1 , n ): if s [ i - 1 ] == s [ i ]: pre [ i ] += pre [ i - 1 ] for i in range ( n - 2 , - 1 , - 1 ): if s [ i ] == s [ i + 1 ]: post [ i ] += post [ i + 1 ] result = sum ( pre ) for i in range ( 1 , n - 1 ): if s [ i - 1 ] != s [ i ] and s [ i - 1 ] == s [ i + 1 ]: result += min ( pre [ i - 1 ], post [ i + 1 ]) return result Back","title":"Special String Again"},{"location":"interviewprep/stringmanipulation/specialstringagain/#special-string-again","text":"Problem Category: String Manipulation Difficulty: Medium Given a string, determine the number of \"special\" substrings it contains. Input: a string \\(s\\) of \\(n\\) lowercase English letters. \\[ 1 \\leq n \\leq 10^6 \\] Output: the number of \"special\" substrings of \\(s\\) . A string is special if, for some letter \\(c \\in [\\text{a-z}]\\) , one of the following is true: Every character is \\(c\\) The length is odd, every character before the middle character is \\(c\\) , and every character after the middle character is \\(c\\) . For example, \"aaabaaa\" . The middle character does not have to be \\(c\\) You might define that a string \\(s\\) of length \\(n\\) is special if and only if there exists a \\(c \\in [\\text{a-z}]\\) such that: \\[ i < \\left\\lfloor\\frac{n}{2}\\right\\rfloor \\; \\lor \\; i \\geq \\left\\lceil\\frac{n}{2}\\right\\rceil \\implies s[i] = c \\] where if \\(n\\) is even, every character has to be \\(c\\) , but if \\(n\\) is odd, there is a middle character we can ignore. Note that each character by itself counts as a special substring of length 1. A natural solution would be to start at each character \\(c_i\\) and look forwards and backwards in the string to see how many special substrings there are with \\(c_i\\) at the center. You would need to be careful about counting the number of substrings of consecutive runs like aaaa correctly. A good approach would be to count backwards from each character the number of consecutive matching characters. However, there is a way to avoid these extra passes forward and backward in the array and solve the problem in linear time. You can use two arrays of length \\(n\\) : \\(p^-_i\\) counts the length of a consecutive run of \\(c_i\\) up to index \\(i\\) \\(p^+_i\\) counts the length of a consecutive run of \\(c_i\\) that starts at index \\(i\\) For example, for \\(s =\\) \"aaabaabc\" : s = a a a b a a b c p- = [1, 2, 3, 1, 1, 2, 1, 1] p+ = [3, 2, 1, 1, 2, 1, 1, 1] \\(p^-\\) and \\(p^+\\) can each be built with a forward and backward pass over \\(s\\) , respectively. Once you have stored this information, you can make an additional pass over \\(s\\) which counts all special substrings. For each \\(0 \\leq i < n\\) : Add \\(p^-_i\\) to the result. This counts special substrings where every character is the same. Count how many special strings have position \\(i\\) at the center. If there are matching characters before and after \\(i\\) that are not \\(c_i\\) ( \\(c_{i-1} = c_{i+1} = c' \\neq c_i\\) ), then there is at least one. \\(p^-_{i-1}\\) is the number of consecutive instances of \\(c'\\) right before \\(i\\) , and \\(p^+_{i+1}\\) is the number of consecutive instances of \\(c'\\) right after \\(i\\) , so the minimum of these values is the number of special substrings to count. Java 8: static long substrCount ( int n , String s ) { long result = 0 L ; int [] preConsecutive = new int [ n ] ; int [] postConsecutive = new int [ n ] ; preConsecutive [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i - 1 ) == s . charAt ( i )) { preConsecutive [ i ] = preConsecutive [ i - 1 ] + 1 ; } else { preConsecutive [ i ] = 1 ; } } postConsecutive [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( s . charAt ( i ) == s . charAt ( i + 1 )) { postConsecutive [ i ] = postConsecutive [ i + 1 ] + 1 ; } else { postConsecutive [ i ] = 1 ; } } for ( int i = 0 ; i < n ; i ++ ) { result += preConsecutive [ i ] ; if ( i > 0 && i + 1 < n && s . charAt ( i - 1 ) == s . charAt ( i + 1 ) && s . charAt ( i - 1 ) != s . charAt ( i )) { int pre = preConsecutive [ i - 1 ] ; int post = postConsecutive [ i + 1 ] ; result += Math . min ( pre , post ); } } return result ; } C++: long substrCount ( int n , string s ) { int * preConsecutive = new int [ n ]; int * postConsecutive = new int [ n ]; preConsecutive [ 0 ] = 1 ; for ( int i = 1 ; i < n ; i ++ ) { preConsecutive [ i ] = 1 ; if ( s [ i - 1 ] == s [ i ]) { preConsecutive [ i ] += preConsecutive [ i - 1 ]; } } postConsecutive [ n - 1 ] = 1 ; for ( int i = n - 2 ; i >= 0 ; i -- ) { postConsecutive [ i ] = 1 ; if ( s [ i ] == s [ i + 1 ]) { postConsecutive [ i ] += postConsecutive [ i + 1 ]; } } long result = 0L ; for ( int i = 0 ; i < n ; i ++ ) { result += preConsecutive [ i ]; if ( i > 0 && i + 1 < n && s [ i - 1 ] != s [ i ] && s [ i - 1 ] == s [ i + 1 ]) { result += min ( preConsecutive [ i - 1 ], postConsecutive [ i + 1 ]); } } return result ; } Python 3: def substrCount ( n , s ): pre = [ 1 ] * n post = [ 1 ] * n for i in range ( 1 , n ): if s [ i - 1 ] == s [ i ]: pre [ i ] += pre [ i - 1 ] for i in range ( n - 2 , - 1 , - 1 ): if s [ i ] == s [ i + 1 ]: post [ i ] += post [ i + 1 ] result = sum ( pre ) for i in range ( 1 , n - 1 ): if s [ i - 1 ] != s [ i ] and s [ i - 1 ] == s [ i + 1 ]: result += min ( pre [ i - 1 ], post [ i + 1 ]) return result Back","title":"Special String Again"},{"location":"interviewprep/trees/heightofbinarytree/","text":"Trees: Height of Binary Tree Problem Category: Trees Difficulty: Easy Determine the height of a given binary tree. Input: the root of a binary tree with \\(n\\) nodes. \\[ 1 \\leq n \\leq 20 \\] class Node { int data; Node* left; Node* right; } Output: the height of the tree, or the number of edges along the longest path from the root to a leaf node. The height of a tree is best found recursively. If the root is a leaf node, then its height is 0. Otherwise, the height of the tree is either the height of the left subtree plus 1, or the height of the right subtree plus 1, whichever is larger. The longest path to a leaf node is either on the left side or the right side of the tree. It is useful to define the height of a null tree as -1. This way, the height of the left/right subtree plus 1 evaluates to 0 if there is no left/right subtree. This is okay because the original tree is guaranteed to have at least one node. Java 8: public static int height ( Node root ) { if ( root == null ) { return - 1 ; } return 1 + Math . max ( height ( root . left ), height ( root . right )); } C++: int height ( Node * root ) { if ( ! root ) { return -1 ; } return 1 + max ( height ( root -> left ), height ( root -> right )); } Python 3: def height ( root ): if not root : return - 1 return 1 + max ( height ( root . left ), height ( root . right )) Back","title":"Trees: Height of Binary Tree"},{"location":"interviewprep/trees/heightofbinarytree/#trees-height-of-binary-tree","text":"Problem Category: Trees Difficulty: Easy Determine the height of a given binary tree. Input: the root of a binary tree with \\(n\\) nodes. \\[ 1 \\leq n \\leq 20 \\] class Node { int data; Node* left; Node* right; } Output: the height of the tree, or the number of edges along the longest path from the root to a leaf node. The height of a tree is best found recursively. If the root is a leaf node, then its height is 0. Otherwise, the height of the tree is either the height of the left subtree plus 1, or the height of the right subtree plus 1, whichever is larger. The longest path to a leaf node is either on the left side or the right side of the tree. It is useful to define the height of a null tree as -1. This way, the height of the left/right subtree plus 1 evaluates to 0 if there is no left/right subtree. This is okay because the original tree is guaranteed to have at least one node. Java 8: public static int height ( Node root ) { if ( root == null ) { return - 1 ; } return 1 + Math . max ( height ( root . left ), height ( root . right )); } C++: int height ( Node * root ) { if ( ! root ) { return -1 ; } return 1 + max ( height ( root -> left ), height ( root -> right )); } Python 3: def height ( root ): if not root : return - 1 return 1 + max ( height ( root . left ), height ( root . right )) Back","title":"Trees: Height of Binary Tree"},{"location":"interviewprep/trees/lowestcommonancestor/","text":"Binary Search Tree: Lowest Common Ancestor Problem Category: Trees Difficulty: Easy Given two values in a binary search tree, find their lowest common ancestor. Input: the root of a binary search tree with \\(n\\) nodes, and two values \\(v_1, v_2\\) from the tree. \\[ 1 \\leq n \\leq 25 \\] \\[ 1 \\leq v_1, v_2 \\leq 25, \\; v_1 \\neq v_2 \\] class Node { int data; Node* left; Node* right; } Output: the lowest common ancestor node of \\(v_1\\) and \\(v_2\\) in the tree. If node \\(k\\) is an ancestor of node \\(v\\) , then the subtree with root \\(k\\) contains \\(v\\) , and the path from the root to \\(v\\) passes through \\(k\\) . The lowest common ancestor is the highest-depth node (lowest in the tree) that is both an ancestor to \\(v_1\\) and \\(v_2\\) . The key observation for this problem is that the answer depends on how the root node's value compares to \\(v_1\\) and \\(v_2\\) . If one of the values is in the left subtree and the other value is in the right subtree, then the root is the lowest common ancestor. If the root's value is equal to \\(v_1\\) or \\(v_2\\) , then the root is also the lowest common ancestor. In these cases, there is no lower common ancestor than the root beacuse no subtrees contain both \\(v_1\\) and \\(v_2\\) . If neither of these conditions are true, then either both values are in the left subtree or both values are in the right subtree, so their common ancestor is also in that subtree. You can determine whether \\(v_1\\) and \\(v_2\\) are to the left or the right of the root because the tree is a binary search tree: all values less than the root's value are in the left subtree, and all values greater than the root's value are in the right subtree. Java 8: public static Node lca ( Node root , int v1 , int v2 ) { if ( root . data == v1 || root . data == v2 ) { return root ; } if ( root . data > v1 && root . data > v2 ) { return lca ( root . left , v1 , v2 ); } if ( root . data < v1 && root . data < v2 ) { return lca ( root . right , v1 , v2 ); } return root ; } C++: Node * lca ( Node * root , int v1 , int v2 ) { if ( root -> data == v1 || root -> data == v2 ) { return root ; } if ( root -> data > v1 && root -> data > v2 ) { return lca ( root -> left , v1 , v2 ); } if ( root -> data < v1 && root -> data < v2 ) { return lca ( root -> right , v1 , v2 ); } return root ; } Python 3: def lca ( root , v1 , v2 ): if root . info == v1 or root . info == v2 : return root if root . info > v1 and root . info > v2 : return lca ( root . left , v1 , v2 ) if root . info < v1 and root . info < v2 : return lca ( root . right , v1 , v2 ) return root Back","title":"Binary Search Tree: Lowest Common Ancestor"},{"location":"interviewprep/trees/lowestcommonancestor/#binary-search-tree-lowest-common-ancestor","text":"Problem Category: Trees Difficulty: Easy Given two values in a binary search tree, find their lowest common ancestor. Input: the root of a binary search tree with \\(n\\) nodes, and two values \\(v_1, v_2\\) from the tree. \\[ 1 \\leq n \\leq 25 \\] \\[ 1 \\leq v_1, v_2 \\leq 25, \\; v_1 \\neq v_2 \\] class Node { int data; Node* left; Node* right; } Output: the lowest common ancestor node of \\(v_1\\) and \\(v_2\\) in the tree. If node \\(k\\) is an ancestor of node \\(v\\) , then the subtree with root \\(k\\) contains \\(v\\) , and the path from the root to \\(v\\) passes through \\(k\\) . The lowest common ancestor is the highest-depth node (lowest in the tree) that is both an ancestor to \\(v_1\\) and \\(v_2\\) . The key observation for this problem is that the answer depends on how the root node's value compares to \\(v_1\\) and \\(v_2\\) . If one of the values is in the left subtree and the other value is in the right subtree, then the root is the lowest common ancestor. If the root's value is equal to \\(v_1\\) or \\(v_2\\) , then the root is also the lowest common ancestor. In these cases, there is no lower common ancestor than the root beacuse no subtrees contain both \\(v_1\\) and \\(v_2\\) . If neither of these conditions are true, then either both values are in the left subtree or both values are in the right subtree, so their common ancestor is also in that subtree. You can determine whether \\(v_1\\) and \\(v_2\\) are to the left or the right of the root because the tree is a binary search tree: all values less than the root's value are in the left subtree, and all values greater than the root's value are in the right subtree. Java 8: public static Node lca ( Node root , int v1 , int v2 ) { if ( root . data == v1 || root . data == v2 ) { return root ; } if ( root . data > v1 && root . data > v2 ) { return lca ( root . left , v1 , v2 ); } if ( root . data < v1 && root . data < v2 ) { return lca ( root . right , v1 , v2 ); } return root ; } C++: Node * lca ( Node * root , int v1 , int v2 ) { if ( root -> data == v1 || root -> data == v2 ) { return root ; } if ( root -> data > v1 && root -> data > v2 ) { return lca ( root -> left , v1 , v2 ); } if ( root -> data < v1 && root -> data < v2 ) { return lca ( root -> right , v1 , v2 ); } return root ; } Python 3: def lca ( root , v1 , v2 ): if root . info == v1 or root . info == v2 : return root if root . info > v1 and root . info > v2 : return lca ( root . left , v1 , v2 ) if root . info < v1 and root . info < v2 : return lca ( root . right , v1 , v2 ) return root Back","title":"Binary Search Tree: Lowest Common Ancestor"},{"location":"interviewprep/warmup/countingvalleys/","text":"Counting Valleys Problem Category: Warm-up Challenges Difficulty: Easy Given a path of steps, which are either up or down, starting at sea level, determine the number of valleys crossed. A valley is a sequence of steps that starts at sea level, descends below sea level, and then returns to sea level. Input: a number of steps \\(s\\) and a path \\(p \\in \\{U, D\\}^s\\) , where \\(U\\) represents a step up and \\(D\\) represents a step down. The path begins and ends at sea level, so \\(p\\) has an equal number of \\(U\\) 's and \\(D\\) 's. \\[ 2 \\leq s \\leq 10^6 \\] \\[ |\\{i : p_i = U\\}| = |\\{i : p_i = D\\}| = \\frac{s}{2} \\] Output: the number of valleys (sequences that start at sea level, descend below sea level, and then return up to sea level). Read through the path and keep track of what elevation each step reaches. For example: \"UDDDUDUU\" \\(\\to 0, 1, 0, -1, -2, -1, -2, -1, 0\\) We can see that a valley ends whenever we step up from elevation -1 to 0. The path is guaranteed to return to sea level (elevation 0) by the end, so every valley ends, and the number of times we step up from -1 to 0 is the number of valleys. Java 8: public static int countingValleys ( int steps , String path ) { int count = 0 ; int level = 0 ; for ( int i = 0 ; i < steps ; i ++ ) { if ( path . charAt ( i ) == 'U' ) { level ++ ; if ( level == 0 ) { count ++ ; } } else { level -- ; } } return count ; } C++: int countingValleys ( int steps , string path ) { int count = 0 ; int level = 0 ; for ( int i = 0 ; i < steps ; i ++ ) { if ( path [ i ] == 'U' ) { level ++ ; count += level == 0 ; } else { level -- ; } } return count ; } Python 3: def countingValleys ( steps , path ): level = 0 count = 0 for step in path : if step == \"U\" : level += 1 if level == 0 : count += 1 else : level -= 1 return count Back","title":"Counting Valleys"},{"location":"interviewprep/warmup/countingvalleys/#counting-valleys","text":"Problem Category: Warm-up Challenges Difficulty: Easy Given a path of steps, which are either up or down, starting at sea level, determine the number of valleys crossed. A valley is a sequence of steps that starts at sea level, descends below sea level, and then returns to sea level. Input: a number of steps \\(s\\) and a path \\(p \\in \\{U, D\\}^s\\) , where \\(U\\) represents a step up and \\(D\\) represents a step down. The path begins and ends at sea level, so \\(p\\) has an equal number of \\(U\\) 's and \\(D\\) 's. \\[ 2 \\leq s \\leq 10^6 \\] \\[ |\\{i : p_i = U\\}| = |\\{i : p_i = D\\}| = \\frac{s}{2} \\] Output: the number of valleys (sequences that start at sea level, descend below sea level, and then return up to sea level). Read through the path and keep track of what elevation each step reaches. For example: \"UDDDUDUU\" \\(\\to 0, 1, 0, -1, -2, -1, -2, -1, 0\\) We can see that a valley ends whenever we step up from elevation -1 to 0. The path is guaranteed to return to sea level (elevation 0) by the end, so every valley ends, and the number of times we step up from -1 to 0 is the number of valleys. Java 8: public static int countingValleys ( int steps , String path ) { int count = 0 ; int level = 0 ; for ( int i = 0 ; i < steps ; i ++ ) { if ( path . charAt ( i ) == 'U' ) { level ++ ; if ( level == 0 ) { count ++ ; } } else { level -- ; } } return count ; } C++: int countingValleys ( int steps , string path ) { int count = 0 ; int level = 0 ; for ( int i = 0 ; i < steps ; i ++ ) { if ( path [ i ] == 'U' ) { level ++ ; count += level == 0 ; } else { level -- ; } } return count ; } Python 3: def countingValleys ( steps , path ): level = 0 count = 0 for step in path : if step == \"U\" : level += 1 if level == 0 : count += 1 else : level -= 1 return count Back","title":"Counting Valleys"},{"location":"interviewprep/warmup/jumpingontheclouds/","text":"Jumping on the Clouds Problem Category: Warm-Up Challenges Difficulty: Easy Given a pattern of safe and dangerous clouds leading to a goal, determine the minimum number of jumps required to reach the end safely. Input: a number of clouds \\(n\\) and a pattern \\(c_1, \\ldots c_n\\) where \\(c_1 = 0\\) , \\(c_n = 0\\) , and \\(c_i \\in \\{0, 1\\}\\) for \\(1 < i < n\\) . \\(c_i = 0\\) means cloud \\(i\\) is safe, and \\(c_i = 1\\) means cloud \\(i\\) must be avoided. \\[ 2 \\leq n \\leq 100 \\] Output: the minimum number of jumps needed to win the game. The player starts on cloud 1 and must reach cloud \\(n\\) . They can jump forward 1 or 2 clouds at a time. It is guaranteed that the player can win, so there will never be two dangerous clouds in a row. We can be greedy by taking advantage of the fact that there is always a path to the end. If the player is at cloud \\(i\\) (starting at cloud 0), look at cloud \\(i + 2\\) : If cloud \\(i + 2\\) is safe, you should always jump 2 spaces forward to that cloud. If cloud \\(i + 2\\) is dangerous, you can (and should) jump 1 space forward to cloud \\(i + 1\\) instead. The first cloud is safe, and there are no two consecutive dangerous clouds. Therefore, for any safe cloud at \\(i\\) , if you can't jump to \\(i + 2\\) , you can jump to \\(i + 1\\) and then to \\(i + 3\\) and so on. For the Java solution, c is given as a List instead of an array, so my solution converts it into an array first. You only need to read through the list once sequentially to solve the problem, so it is possible to use an iterator over the list instead of converting it into an array and indexing into it. Java 8: public static int jumpingOnClouds ( List < Integer > c ) { final int N = c . size (); Integer [] clouds = c . toArray ( new Integer [ N ] ); int jumps = 0 ; int position = 0 ; while ( position + 1 < N ) { if ( position + 2 < N && clouds [ position + 2 ] == 0 ) { position += 2 ; } else { position ++ ; } jumps ++ ; } return jumps ; } C++: int jumpingOnClouds ( vector < int > c ) { const int n = c . size (); int jumps = 0 ; int position = 0 ; while ( position + 1 < n ) { position += 1 + ( position + 2 < n && ! c [ position + 2 ]); jumps ++ ; } return jumps ; } Python 3: def jumpingOnClouds ( c ): n = len ( c ) position = 0 jumps = 0 while position + 1 < n : if position + 2 < n and c [ position + 2 ] == 0 : position += 2 else : position += 1 jumps += 1 return jumps Back","title":"Jumping on the Clouds"},{"location":"interviewprep/warmup/jumpingontheclouds/#jumping-on-the-clouds","text":"Problem Category: Warm-Up Challenges Difficulty: Easy Given a pattern of safe and dangerous clouds leading to a goal, determine the minimum number of jumps required to reach the end safely. Input: a number of clouds \\(n\\) and a pattern \\(c_1, \\ldots c_n\\) where \\(c_1 = 0\\) , \\(c_n = 0\\) , and \\(c_i \\in \\{0, 1\\}\\) for \\(1 < i < n\\) . \\(c_i = 0\\) means cloud \\(i\\) is safe, and \\(c_i = 1\\) means cloud \\(i\\) must be avoided. \\[ 2 \\leq n \\leq 100 \\] Output: the minimum number of jumps needed to win the game. The player starts on cloud 1 and must reach cloud \\(n\\) . They can jump forward 1 or 2 clouds at a time. It is guaranteed that the player can win, so there will never be two dangerous clouds in a row. We can be greedy by taking advantage of the fact that there is always a path to the end. If the player is at cloud \\(i\\) (starting at cloud 0), look at cloud \\(i + 2\\) : If cloud \\(i + 2\\) is safe, you should always jump 2 spaces forward to that cloud. If cloud \\(i + 2\\) is dangerous, you can (and should) jump 1 space forward to cloud \\(i + 1\\) instead. The first cloud is safe, and there are no two consecutive dangerous clouds. Therefore, for any safe cloud at \\(i\\) , if you can't jump to \\(i + 2\\) , you can jump to \\(i + 1\\) and then to \\(i + 3\\) and so on. For the Java solution, c is given as a List instead of an array, so my solution converts it into an array first. You only need to read through the list once sequentially to solve the problem, so it is possible to use an iterator over the list instead of converting it into an array and indexing into it. Java 8: public static int jumpingOnClouds ( List < Integer > c ) { final int N = c . size (); Integer [] clouds = c . toArray ( new Integer [ N ] ); int jumps = 0 ; int position = 0 ; while ( position + 1 < N ) { if ( position + 2 < N && clouds [ position + 2 ] == 0 ) { position += 2 ; } else { position ++ ; } jumps ++ ; } return jumps ; } C++: int jumpingOnClouds ( vector < int > c ) { const int n = c . size (); int jumps = 0 ; int position = 0 ; while ( position + 1 < n ) { position += 1 + ( position + 2 < n && ! c [ position + 2 ]); jumps ++ ; } return jumps ; } Python 3: def jumpingOnClouds ( c ): n = len ( c ) position = 0 jumps = 0 while position + 1 < n : if position + 2 < n and c [ position + 2 ] == 0 : position += 2 else : position += 1 jumps += 1 return jumps Back","title":"Jumping on the Clouds"},{"location":"interviewprep/warmup/repeatedstring/","text":"Repeated String Problem Category: Warm-up Challenges Difficulty: Easy Find the number of a's in the first \\(n\\) letters of an infinitely repeating string. Input: a string \\(s\\) of lowercase English letters, and \\(n\\) , the length of the substring to consider when \\(s\\) is repeated infinitely. \\[ 1 \\leq |s| \\leq 100 \\] \\[ 1 \\leq n \\leq 10^{12} \\] Output: the number of a's in the first \\(n\\) characters of the infinitely repeating string generated by \\(s\\) . \\(n\\) can be a very large number, so you cannot store the entire \\(n\\) -length substring to count the number of a's. However, we know the substring will contain \\(\\lfloor \\frac{n}{|s|} \\rfloor\\) complete instances of \\(s\\) , and then the remainder will be the first \\(k = n \\bmod |s|\\) characters of \\(s\\) . Count the number of a's in the first \\(k\\) characters of \\(s\\) , as well as the number of a's in all of \\(s\\) , and you can calculate the number of a's in the \\(n\\) characters generated by repeating \\(s\\) . Java 8: public static long repeatedString ( String s , long n ) { long fullCount = n / s . length (); int partial = ( int ) ( n % s . length ()); int count = 0 ; int partialCount = 0 ; for ( int i = 0 ; i < s . length (); i ++ ) { if ( s . charAt ( i ) == 'a' ) { if ( i < partial ) { partialCount ++ ; } count ++ ; } } return fullCount * count + partialCount ; } C++: long repeatedString ( string s , long n ) { const long fullCount = n / s . size (); const int part = n % s . size (); int count = 0 ; int partialCount = 0 ; for ( int i = 0 ; i < s . size (); i ++ ) { if ( s [ i ] == 'a' ) { if ( i < part ) { partialCount ++ ; } count ++ ; } i ++ ; } return fullCount * count + partialCount ; } Python 3: def repeatedString ( s , n ): full_count = n // len ( s ) partial = s [:( n % len ( s ))] return full_count * s . count ( 'a' ) + partial . count ( 'a' ) Back","title":"Repeated String"},{"location":"interviewprep/warmup/repeatedstring/#repeated-string","text":"Problem Category: Warm-up Challenges Difficulty: Easy Find the number of a's in the first \\(n\\) letters of an infinitely repeating string. Input: a string \\(s\\) of lowercase English letters, and \\(n\\) , the length of the substring to consider when \\(s\\) is repeated infinitely. \\[ 1 \\leq |s| \\leq 100 \\] \\[ 1 \\leq n \\leq 10^{12} \\] Output: the number of a's in the first \\(n\\) characters of the infinitely repeating string generated by \\(s\\) . \\(n\\) can be a very large number, so you cannot store the entire \\(n\\) -length substring to count the number of a's. However, we know the substring will contain \\(\\lfloor \\frac{n}{|s|} \\rfloor\\) complete instances of \\(s\\) , and then the remainder will be the first \\(k = n \\bmod |s|\\) characters of \\(s\\) . Count the number of a's in the first \\(k\\) characters of \\(s\\) , as well as the number of a's in all of \\(s\\) , and you can calculate the number of a's in the \\(n\\) characters generated by repeating \\(s\\) . Java 8: public static long repeatedString ( String s , long n ) { long fullCount = n / s . length (); int partial = ( int ) ( n % s . length ()); int count = 0 ; int partialCount = 0 ; for ( int i = 0 ; i < s . length (); i ++ ) { if ( s . charAt ( i ) == 'a' ) { if ( i < partial ) { partialCount ++ ; } count ++ ; } } return fullCount * count + partialCount ; } C++: long repeatedString ( string s , long n ) { const long fullCount = n / s . size (); const int part = n % s . size (); int count = 0 ; int partialCount = 0 ; for ( int i = 0 ; i < s . size (); i ++ ) { if ( s [ i ] == 'a' ) { if ( i < part ) { partialCount ++ ; } count ++ ; } i ++ ; } return fullCount * count + partialCount ; } Python 3: def repeatedString ( s , n ): full_count = n // len ( s ) partial = s [:( n % len ( s ))] return full_count * s . count ( 'a' ) + partial . count ( 'a' ) Back","title":"Repeated String"},{"location":"interviewprep/warmup/salesbymatch/","text":"Sales by Match Problem Category: Warm-up Challenges Difficulty: Easy Given a list of socks, determine how many pairs of matching-color socks can be made. Input: a list of socks \\(ar[n]\\) , where \\(ar[i]\\) is an integer representing the color of sock \\(i\\) . \\[ 1 \\leq n \\leq 100 \\] \\[ 1 \\leq ar[i] \\leq 100 \\; \\forall \\; i \\] Output: the maximum number of pairs that can be achieved by pairing socks that have the same color We don't need the number of total possible ways to pair the socks; we just need to maximum number of pairs achievable by any pairing where no sock is matched to a sock of a different color. For example, [1, 1, 1, 1, 1] has at most 2 matches: one way to achieve this is by matching sock 0 to sock 1 and sock 2 to sock 3, leaving sock 4 unpaired. Make a set to store available sock colors and loop through the list of socks. Check if each sock's color is in the set so far: If sock \\(i\\) 's color is not in the set, then you have no sock to pair with \\(i\\) . \\(i\\) is a loose sock available for a future pairing. If sock \\(i\\) 's color is in the set, then there is a previous sock available to pair with \\(i\\) . Remove \\(i\\) 's color from the set and record that a pair has been made. Another solution could be to count how many socks there are of each color. If a color appears on \\(k\\) socks, then \\(\\lfloor \\frac{k}{2} \\rfloor\\) is the number of pairs that can be made with that color. Java 8: public static int sockMerchant ( int n , List < Integer > ar ) { int count = 0 ; Set < Integer > colors = new HashSet <> (); for ( int sock : ar ) { if ( colors . remove ( sock )) { count ++ ; } else { colors . add ( sock ); } } return count ; } C++: int sockMerchant ( int n , vector < int > ar ) { int count = 0 ; set < int > colors ; for ( int i = 0 ; i < n ; i ++ ) { if ( colors . erase ( ar [ i ])) { count ++ ; } else { colors . insert ( ar [ i ]); } } return count ; } Python 3: def sockMerchant ( n , ar ): colors = set () count = 0 for i in ar : if i in colors : count += 1 colors . remove ( i ) else : colors . add ( i ) return count Python 3 Alternate Solution: def sockMerchant ( n , ar ): sock_freq = { sock : ar . count ( sock ) for sock in ar } return sum ( v // 2 for _ , v in sock_freq . items ()) Back","title":"Sales by Match"},{"location":"interviewprep/warmup/salesbymatch/#sales-by-match","text":"Problem Category: Warm-up Challenges Difficulty: Easy Given a list of socks, determine how many pairs of matching-color socks can be made. Input: a list of socks \\(ar[n]\\) , where \\(ar[i]\\) is an integer representing the color of sock \\(i\\) . \\[ 1 \\leq n \\leq 100 \\] \\[ 1 \\leq ar[i] \\leq 100 \\; \\forall \\; i \\] Output: the maximum number of pairs that can be achieved by pairing socks that have the same color We don't need the number of total possible ways to pair the socks; we just need to maximum number of pairs achievable by any pairing where no sock is matched to a sock of a different color. For example, [1, 1, 1, 1, 1] has at most 2 matches: one way to achieve this is by matching sock 0 to sock 1 and sock 2 to sock 3, leaving sock 4 unpaired. Make a set to store available sock colors and loop through the list of socks. Check if each sock's color is in the set so far: If sock \\(i\\) 's color is not in the set, then you have no sock to pair with \\(i\\) . \\(i\\) is a loose sock available for a future pairing. If sock \\(i\\) 's color is in the set, then there is a previous sock available to pair with \\(i\\) . Remove \\(i\\) 's color from the set and record that a pair has been made. Another solution could be to count how many socks there are of each color. If a color appears on \\(k\\) socks, then \\(\\lfloor \\frac{k}{2} \\rfloor\\) is the number of pairs that can be made with that color. Java 8: public static int sockMerchant ( int n , List < Integer > ar ) { int count = 0 ; Set < Integer > colors = new HashSet <> (); for ( int sock : ar ) { if ( colors . remove ( sock )) { count ++ ; } else { colors . add ( sock ); } } return count ; } C++: int sockMerchant ( int n , vector < int > ar ) { int count = 0 ; set < int > colors ; for ( int i = 0 ; i < n ; i ++ ) { if ( colors . erase ( ar [ i ])) { count ++ ; } else { colors . insert ( ar [ i ]); } } return count ; } Python 3: def sockMerchant ( n , ar ): colors = set () count = 0 for i in ar : if i in colors : count += 1 colors . remove ( i ) else : colors . add ( i ) return count Python 3 Alternate Solution: def sockMerchant ( n , ar ): sock_freq = { sock : ar . count ( sock ) for sock in ar } return sum ( v // 2 for _ , v in sock_freq . items ()) Back","title":"Sales by Match"}]}